{"ast":null,"code":"/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)\n\nAbly JavaScript Library v2.0.2\nhttps://github.com/ably/ably-js\n\nReleased under the Apache Licence v2.0*/(function (g, f) {\n  if (\"object\" == typeof exports && \"object\" == typeof module) {\n    module.exports = f();\n  } else if (\"function\" == typeof define && define.amd) {\n    define([], f);\n  } else if (\"object\" == typeof exports) {\n    exports[\"Ably\"] = f();\n  } else {\n    g[\"Ably\"] = f();\n  }\n})(this, () => {\n  var exports = {};\n  var module = {\n    exports\n  };\n  \"use strict\";\n  var __defProp = Object.defineProperty;\n  var __defProps = Object.defineProperties;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getOwnPropSymbols = Object.getOwnPropertySymbols;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __propIsEnum = Object.prototype.propertyIsEnumerable;\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value\n  }) : obj[key] = value;\n  var __spreadValues = (a, b) => {\n    for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n  };\n  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n  var __objRest = (source, exclude) => {\n    var target = {};\n    for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n    }\n    return target;\n  };\n  var __export = (target, all) => {\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n        get: () => from[key],\n        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n      });\n    }\n    return to;\n  };\n  var __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n    value: true\n  }), mod);\n\n  // src/platform/web/index.ts\n  var web_exports = {};\n  __export(web_exports, {\n    Realtime: () => DefaultRealtime,\n    Rest: () => DefaultRest,\n    default: () => web_default,\n    msgpack: () => msgpack_default,\n    protocolMessageFromDeserialized: () => fromDeserializedIncludingDependencies\n  });\n  module.exports = __toCommonJS(web_exports);\n\n  // src/common/platform.ts\n  var Platform = class {};\n\n  // src/common/lib/util/logger.ts\n  var globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : self;\n  function pad(timeSegment, three) {\n    return `${timeSegment}`.padStart(three ? 3 : 2, \"0\");\n  }\n  function getHandler(logger) {\n    return Platform.Config.logTimestamps ? function (msg) {\n      const time = /* @__PURE__ */new Date();\n      logger(pad(time.getHours()) + \":\" + pad(time.getMinutes()) + \":\" + pad(time.getSeconds()) + \".\" + pad(time.getMilliseconds(), 1) + \" \" + msg);\n    } : logger;\n  }\n  var getDefaultLoggers = () => {\n    var _a2;\n    let consoleLogger;\n    let errorLogger;\n    if (typeof ((_a2 = globalObject == null ? void 0 : globalObject.console) == null ? void 0 : _a2.log) === \"function\") {\n      consoleLogger = function (...args) {\n        console.log.apply(console, args);\n      };\n      errorLogger = console.warn ? function (...args) {\n        console.warn.apply(console, args);\n      } : consoleLogger;\n    } else {\n      consoleLogger = errorLogger = function () {};\n    }\n    return [consoleLogger, errorLogger].map(getHandler);\n  };\n  var _Logger = class _Logger {\n    constructor() {\n      _Logger.logLevel = _Logger.LOG_DEFAULT;\n    }\n    static initLogHandlers() {\n      const [logHandler, logErrorHandler] = getDefaultLoggers();\n      this.logHandler = logHandler;\n      this.logErrorHandler = logErrorHandler;\n    }\n    /**\n     * Calls to this method are never stripped by the `stripLogs` esbuild plugin. Use it for log statements that you wish to always be included in the modular variant of the SDK.\n     */\n    static logActionNoStrip(level, action, message) {\n      if (_Logger.shouldLog(level)) {\n        (level === 1 /* Error */ ? _Logger.logErrorHandler : _Logger.logHandler)(\"Ably: \" + action + \": \" + message);\n      }\n    }\n    static renamedClientOption(oldName, newName) {\n      _Logger.deprecationWarning(`The \\`${oldName}\\` client option has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`);\n    }\n    static renamedMethod(className, oldName, newName) {\n      _Logger.deprecationWarning(`\\`${className}\\`\\u2019s \\`${oldName}\\` method has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`);\n    }\n    static deprecationWarning(message) {\n      if (_Logger.shouldLog(1 /* Error */)) {\n        _Logger.logErrorHandler(`Ably: Deprecation warning - ${message}`);\n      }\n    }\n  };\n  _Logger.logLevel = 1 /* Error */;\n  // public constants\n  _Logger.LOG_NONE = 0 /* None */;\n  _Logger.LOG_ERROR = 1 /* Error */;\n  _Logger.LOG_MAJOR = 2 /* Major */;\n  _Logger.LOG_MINOR = 3 /* Minor */;\n  _Logger.LOG_MICRO = 4 /* Micro */;\n  // aliases\n  _Logger.LOG_DEFAULT = 1 /* Error */;\n  _Logger.LOG_DEBUG = 4 /* Micro */;\n  /* public static functions */\n  /**\n   * In the modular variant of the SDK, the `stripLogs` esbuild plugin strips out all calls to this method (when invoked as `Logger.logAction(...)`) except when called with level `Logger.LOG_ERROR`. If you wish for a log statement to never be stripped, use the {@link logActionNoStrip} method instead.\n   *\n   * The aforementioned plugin expects `level` to be an expression of the form `Logger.LOG_*`; that is, you canâ€™t dynamically specify the log level.\n   */\n  _Logger.logAction = (level, action, message) => {\n    _Logger.logActionNoStrip(level, action, message);\n  };\n  _Logger.deprecated = (description, msg) => {\n    _Logger.deprecationWarning(`${description} is deprecated and will be removed in a future version. ${msg}`);\n  };\n  /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\n    the object being serialised if the log level will not output the message */\n  _Logger.shouldLog = level => {\n    return level <= _Logger.logLevel;\n  };\n  _Logger.setLog = (level, handler) => {\n    if (level !== void 0) _Logger.logLevel = level;\n    if (handler !== void 0) _Logger.logHandler = _Logger.logErrorHandler = handler;\n  };\n  var Logger = _Logger;\n  var logger_default = Logger;\n\n  // src/common/lib/util/utils.ts\n  var utils_exports = {};\n  __export(utils_exports, {\n    Format: () => Format,\n    allSame: () => allSame,\n    allToLowerCase: () => allToLowerCase,\n    allToUpperCase: () => allToUpperCase,\n    arrChooseN: () => arrChooseN,\n    arrDeleteValue: () => arrDeleteValue,\n    arrEquals: () => arrEquals,\n    arrIntersect: () => arrIntersect,\n    arrIntersectOb: () => arrIntersectOb,\n    arrPopRandomElement: () => arrPopRandomElement,\n    arrSubtract: () => arrSubtract,\n    arrWithoutValue: () => arrWithoutValue,\n    cheapRandStr: () => cheapRandStr,\n    containsValue: () => containsValue,\n    copy: () => copy,\n    createMissingPluginError: () => createMissingPluginError,\n    dataSizeBytes: () => dataSizeBytes,\n    decodeBody: () => decodeBody,\n    encodeBody: () => encodeBody,\n    ensureArray: () => ensureArray,\n    forInOwnNonNullProperties: () => forInOwnNonNullProperties,\n    getBackoffCoefficient: () => getBackoffCoefficient,\n    getGlobalObject: () => getGlobalObject,\n    getJitterCoefficient: () => getJitterCoefficient,\n    getRetryTime: () => getRetryTime,\n    inherits: () => inherits,\n    inspectBody: () => inspectBody,\n    inspectError: () => inspectError,\n    intersect: () => intersect,\n    isEmpty: () => isEmpty,\n    isErrorInfoOrPartialErrorInfo: () => isErrorInfoOrPartialErrorInfo,\n    isNil: () => isNil,\n    isObject: () => isObject,\n    keysArray: () => keysArray,\n    matchDerivedChannel: () => matchDerivedChannel,\n    mixin: () => mixin,\n    parseQueryString: () => parseQueryString,\n    prototypicalClone: () => prototypicalClone,\n    randomString: () => randomString,\n    shallowClone: () => shallowClone,\n    shallowEquals: () => shallowEquals,\n    throwMissingPluginError: () => throwMissingPluginError,\n    toBase64: () => toBase64,\n    toQueryString: () => toQueryString,\n    valuesArray: () => valuesArray,\n    whenPromiseSettles: () => whenPromiseSettles\n  });\n\n  // src/common/lib/types/errorinfo.ts\n  function toString(err) {\n    let result = \"[\" + err.constructor.name;\n    if (err.message) result += \": \" + err.message;\n    if (err.statusCode) result += \"; statusCode=\" + err.statusCode;\n    if (err.code) result += \"; code=\" + err.code;\n    if (err.cause) result += \"; cause=\" + inspectError(err.cause);\n    if (err.href && !(err.message && err.message.indexOf(\"help.ably.io\") > -1)) result += \"; see \" + err.href + \" \";\n    result += \"]\";\n    return result;\n  }\n  var ErrorInfo = class _ErrorInfo extends Error {\n    constructor(message, code, statusCode, cause) {\n      super(message);\n      if (typeof Object.setPrototypeOf !== \"undefined\") {\n        Object.setPrototypeOf(this, _ErrorInfo.prototype);\n      }\n      this.code = code;\n      this.statusCode = statusCode;\n      this.cause = cause;\n    }\n    toString() {\n      return toString(this);\n    }\n    static fromValues(values) {\n      const {\n        message,\n        code,\n        statusCode\n      } = values;\n      if (typeof message !== \"string\" || typeof code !== \"number\" || typeof statusCode !== \"number\") {\n        throw new Error(\"ErrorInfo.fromValues(): invalid values: \" + Platform.Config.inspect(values));\n      }\n      const result = Object.assign(new _ErrorInfo(message, code, statusCode), values);\n      if (result.code && !result.href) {\n        result.href = \"https://help.ably.io/error/\" + result.code;\n      }\n      return result;\n    }\n  };\n  var PartialErrorInfo = class _PartialErrorInfo extends Error {\n    constructor(message, code, statusCode, cause) {\n      super(message);\n      if (typeof Object.setPrototypeOf !== \"undefined\") {\n        Object.setPrototypeOf(this, _PartialErrorInfo.prototype);\n      }\n      this.code = code;\n      this.statusCode = statusCode;\n      this.cause = cause;\n    }\n    toString() {\n      return toString(this);\n    }\n  };\n\n  // src/common/lib/util/utils.ts\n  function randomPosn(arrOrStr) {\n    return Math.floor(Math.random() * arrOrStr.length);\n  }\n  function mixin(target, ...args) {\n    for (let i = 0; i < args.length; i++) {\n      const source = args[i];\n      if (!source) {\n        break;\n      }\n      for (const key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  }\n  function copy(src) {\n    return mixin({}, src);\n  }\n  function ensureArray(obj) {\n    if (isNil(obj)) {\n      return [];\n    }\n    if (Array.isArray(obj)) {\n      return obj;\n    }\n    return [obj];\n  }\n  function isObject(ob) {\n    return Object.prototype.toString.call(ob) == \"[object Object]\";\n  }\n  function isEmpty(ob) {\n    for (const prop in ob) return false;\n    return true;\n  }\n  function isNil(arg) {\n    return arg == null;\n  }\n  function shallowClone(ob) {\n    const result = new Object();\n    for (const prop in ob) result[prop] = ob[prop];\n    return result;\n  }\n  function prototypicalClone(ob, ownProperties) {\n    class F {}\n    F.prototype = ob;\n    const result = new F();\n    if (ownProperties) mixin(result, ownProperties);\n    return result;\n  }\n  var inherits = function (ctor, superCtor) {\n    if (Platform.Config.inherits) {\n      Platform.Config.inherits(ctor, superCtor);\n      return;\n    }\n    ctor.super_ = superCtor;\n    ctor.prototype = prototypicalClone(superCtor.prototype, {\n      constructor: ctor\n    });\n  };\n  function containsValue(ob, val) {\n    for (const i in ob) {\n      if (ob[i] == val) return true;\n    }\n    return false;\n  }\n  function intersect(arr, ob) {\n    return Array.isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\n  }\n  function arrIntersect(arr1, arr2) {\n    const result = [];\n    for (let i = 0; i < arr1.length; i++) {\n      const member = arr1[i];\n      if (arr2.indexOf(member) != -1) result.push(member);\n    }\n    return result;\n  }\n  function arrIntersectOb(arr, ob) {\n    const result = [];\n    for (let i = 0; i < arr.length; i++) {\n      const member = arr[i];\n      if (member in ob) result.push(member);\n    }\n    return result;\n  }\n  function arrSubtract(arr1, arr2) {\n    const result = [];\n    for (let i = 0; i < arr1.length; i++) {\n      const element = arr1[i];\n      if (arr2.indexOf(element) == -1) result.push(element);\n    }\n    return result;\n  }\n  function arrDeleteValue(arr, val) {\n    const idx = arr.indexOf(val);\n    const res = idx != -1;\n    if (res) arr.splice(idx, 1);\n    return res;\n  }\n  function arrWithoutValue(arr, val) {\n    const newArr = arr.slice();\n    arrDeleteValue(newArr, val);\n    return newArr;\n  }\n  function keysArray(ob, ownOnly) {\n    const result = [];\n    for (const prop in ob) {\n      if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\n      result.push(prop);\n    }\n    return result;\n  }\n  function valuesArray(ob, ownOnly) {\n    const result = [];\n    for (const prop in ob) {\n      if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\n      result.push(ob[prop]);\n    }\n    return result;\n  }\n  function forInOwnNonNullProperties(ob, fn) {\n    for (const prop in ob) {\n      if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\n        fn(prop);\n      }\n    }\n  }\n  function allSame(arr, prop) {\n    if (arr.length === 0) {\n      return true;\n    }\n    const first = arr[0][prop];\n    return arr.every(function (item) {\n      return item[prop] === first;\n    });\n  }\n  var Format = /* @__PURE__ */(Format2 => {\n    Format2[\"msgpack\"] = \"msgpack\";\n    Format2[\"json\"] = \"json\";\n    return Format2;\n  })(Format || {});\n  function arrPopRandomElement(arr) {\n    return arr.splice(randomPosn(arr), 1)[0];\n  }\n  function toQueryString(params) {\n    const parts = [];\n    if (params) {\n      for (const key in params) parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n    }\n    return parts.length ? \"?\" + parts.join(\"&\") : \"\";\n  }\n  function parseQueryString(query) {\n    let match;\n    const search = /([^?&=]+)=?([^&]*)/g;\n    const result = {};\n    while (match = search.exec(query)) result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\n    return result;\n  }\n  function isErrorInfoOrPartialErrorInfo(err) {\n    return typeof err == \"object\" && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\n  }\n  function inspectError(err) {\n    var _a2, _b;\n    if (err instanceof Error || ((_a2 = err == null ? void 0 : err.constructor) == null ? void 0 : _a2.name) === \"ErrorInfo\" || ((_b = err == null ? void 0 : err.constructor) == null ? void 0 : _b.name) === \"PartialErrorInfo\") return err.toString();\n    return Platform.Config.inspect(err);\n  }\n  function inspectBody(body) {\n    if (Platform.BufferUtils.isBuffer(body)) {\n      return body.toString();\n    } else if (typeof body === \"string\") {\n      return body;\n    } else {\n      return Platform.Config.inspect(body);\n    }\n  }\n  function dataSizeBytes(data) {\n    if (Platform.BufferUtils.isBuffer(data)) {\n      return Platform.BufferUtils.byteLength(data);\n    }\n    if (typeof data === \"string\") {\n      return Platform.Config.stringByteSize(data);\n    }\n    throw new Error(\"Expected input of Utils.dataSizeBytes to be a buffer or string, but was: \" + typeof data);\n  }\n  function cheapRandStr() {\n    return String(Math.random()).substr(2);\n  }\n  var randomString = async numBytes => {\n    const buffer = await Platform.Config.getRandomArrayBuffer(numBytes);\n    return Platform.BufferUtils.base64Encode(buffer);\n  };\n  function arrChooseN(arr, n2) {\n    const numItems = Math.min(n2, arr.length),\n      mutableArr = arr.slice(),\n      result = [];\n    for (let i = 0; i < numItems; i++) {\n      result.push(arrPopRandomElement(mutableArr));\n    }\n    return result;\n  }\n  function whenPromiseSettles(promise, callback) {\n    promise.then(result => {\n      callback == null ? void 0 : callback(null, result);\n    }).catch(err => {\n      callback == null ? void 0 : callback(err);\n    });\n  }\n  function decodeBody(body, MsgPack, format) {\n    if (format == \"msgpack\") {\n      if (!MsgPack) {\n        throwMissingPluginError(\"MsgPack\");\n      }\n      return MsgPack.decode(body);\n    }\n    return JSON.parse(String(body));\n  }\n  function encodeBody(body, MsgPack, format) {\n    if (format == \"msgpack\") {\n      if (!MsgPack) {\n        throwMissingPluginError(\"MsgPack\");\n      }\n      return MsgPack.encode(body, true);\n    }\n    return JSON.stringify(body);\n  }\n  function allToLowerCase(arr) {\n    return arr.map(function (element) {\n      return element && element.toLowerCase();\n    });\n  }\n  function allToUpperCase(arr) {\n    return arr.map(function (element) {\n      return element && element.toUpperCase();\n    });\n  }\n  function getBackoffCoefficient(count) {\n    return Math.min((count + 2) / 3, 2);\n  }\n  function getJitterCoefficient() {\n    return 1 - Math.random() * 0.2;\n  }\n  function getRetryTime(initialTimeout, retryAttempt) {\n    return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\n  }\n  function getGlobalObject() {\n    if (typeof global !== \"undefined\") {\n      return global;\n    }\n    if (typeof window !== \"undefined\") {\n      return window;\n    }\n    return self;\n  }\n  function shallowEquals(source, target) {\n    return Object.keys(source).every(key => source[key] === target[key]) && Object.keys(target).every(key => target[key] === source[key]);\n  }\n  function matchDerivedChannel(name) {\n    const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/;\n    const match = name.match(regex);\n    if (!match || !match.length || match.length < 5) {\n      throw new ErrorInfo(\"regex match failed\", 400, 40010);\n    }\n    if (match[2]) {\n      throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\n    }\n    return {\n      qualifierParam: match[3] || \"\",\n      channelName: match[4]\n    };\n  }\n  function toBase64(str) {\n    const bufferUtils = Platform.BufferUtils;\n    const textBuffer = bufferUtils.utf8Encode(str);\n    return bufferUtils.base64Encode(textBuffer);\n  }\n  function arrEquals(a, b) {\n    return a.length === b.length && a.every(function (val, i) {\n      return val === b[i];\n    });\n  }\n  function createMissingPluginError(pluginName) {\n    return new ErrorInfo(`${pluginName} plugin not provided`, 40019, 400);\n  }\n  function throwMissingPluginError(pluginName) {\n    throw createMissingPluginError(pluginName);\n  }\n\n  // package.json\n  var version = \"2.0.2\";\n\n  // src/common/lib/util/defaults.ts\n  var agent = \"ably-js/\" + version;\n  var Defaults = {\n    ENVIRONMENT: \"\",\n    REST_HOST: \"rest.ably.io\",\n    REALTIME_HOST: \"realtime.ably.io\",\n    FALLBACK_HOSTS: [\"A.ably-realtime.com\", \"B.ably-realtime.com\", \"C.ably-realtime.com\", \"D.ably-realtime.com\", \"E.ably-realtime.com\"],\n    PORT: 80,\n    TLS_PORT: 443,\n    TIMEOUTS: {\n      /* Documented as options params: */\n      disconnectedRetryTimeout: 15e3,\n      suspendedRetryTimeout: 3e4,\n      /* Undocumented, but part of the api and can be used by customers: */\n      httpRequestTimeout: 15e3,\n      channelRetryTimeout: 15e3,\n      fallbackRetryTimeout: 6e5,\n      /* For internal / test use only: */\n      connectionStateTtl: 12e4,\n      realtimeRequestTimeout: 1e4,\n      recvTimeout: 9e4,\n      webSocketConnectTimeout: 1e4,\n      webSocketSlowTimeout: 4e3\n    },\n    httpMaxRetryCount: 3,\n    maxMessageSize: 65536,\n    version,\n    protocolVersion: 3,\n    agent,\n    getHost,\n    getPort,\n    getHttpScheme,\n    environmentFallbackHosts,\n    getFallbackHosts,\n    getHosts,\n    checkHost,\n    objectifyOptions,\n    normaliseOptions,\n    defaultGetHeaders,\n    defaultPostHeaders\n  };\n  function getHost(options, host, ws) {\n    if (ws) host = host == options.restHost && options.realtimeHost || host || options.realtimeHost;else host = host || options.restHost;\n    return host;\n  }\n  function getPort(options, tls) {\n    return tls || options.tls ? options.tlsPort : options.port;\n  }\n  function getHttpScheme(options) {\n    return options.tls ? \"https://\" : \"http://\";\n  }\n  function environmentFallbackHosts(environment) {\n    return [environment + \"-a-fallback.ably-realtime.com\", environment + \"-b-fallback.ably-realtime.com\", environment + \"-c-fallback.ably-realtime.com\", environment + \"-d-fallback.ably-realtime.com\", environment + \"-e-fallback.ably-realtime.com\"];\n  }\n  function getFallbackHosts(options) {\n    const fallbackHosts = options.fallbackHosts,\n      httpMaxRetryCount = typeof options.httpMaxRetryCount !== \"undefined\" ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\n    return fallbackHosts ? arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\n  }\n  function getHosts(options, ws) {\n    const hosts = [options.restHost].concat(getFallbackHosts(options));\n    return ws ? hosts.map(host => getHost(options, host, true)) : hosts;\n  }\n  function checkHost(host) {\n    if (typeof host !== \"string\") {\n      throw new ErrorInfo(\"host must be a string; was a \" + typeof host, 4e4, 400);\n    }\n    if (!host.length) {\n      throw new ErrorInfo(\"host must not be zero-length\", 4e4, 400);\n    }\n  }\n  function getRealtimeHost(options, production, environment) {\n    if (options.realtimeHost) return options.realtimeHost;\n    if (options.restHost) {\n      logger_default.logAction(logger_default.LOG_MINOR, \"Defaults.normaliseOptions\", 'restHost is set to \"' + options.restHost + '\" but realtimeHost is not set, so setting realtimeHost to \"' + options.restHost + '\" too. If this is not what you want, please set realtimeHost explicitly.');\n      return options.restHost;\n    }\n    return production ? Defaults.REALTIME_HOST : environment + \"-\" + Defaults.REALTIME_HOST;\n  }\n  function getTimeouts(options) {\n    const timeouts = {};\n    for (const prop in Defaults.TIMEOUTS) {\n      timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];\n    }\n    return timeouts;\n  }\n  function getAgentString(options) {\n    let agentStr = Defaults.agent;\n    if (options.agents) {\n      for (var agent2 in options.agents) {\n        agentStr += \" \" + agent2 + \"/\" + options.agents[agent2];\n      }\n    }\n    return agentStr;\n  }\n  function objectifyOptions(options, allowKeyOrToken, sourceForErrorMessage, modularPluginsToInclude) {\n    if (options === void 0) {\n      const msg = allowKeyOrToken ? `${sourceForErrorMessage} must be initialized with either a client options object, an Ably API key, or an Ably Token` : `${sourceForErrorMessage} must be initialized with a client options object`;\n      logger_default.logAction(logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n      throw new Error(msg);\n    }\n    let optionsObj;\n    if (typeof options === \"string\") {\n      if (options.indexOf(\":\") == -1) {\n        if (!allowKeyOrToken) {\n          const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably Token; you must provide a client options object with a \\`plugins\\` property. (Set this Ably Token as the object\\u2019s \\`token\\` property.)`;\n          logger_default.logAction(logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n          throw new Error(msg);\n        }\n        optionsObj = {\n          token: options\n        };\n      } else {\n        if (!allowKeyOrToken) {\n          const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably API key; you must provide a client options object with a \\`plugins\\` property. (Set this Ably API key as the object\\u2019s \\`key\\` property.)`;\n          logger_default.logAction(logger_default.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\n          throw new Error(msg);\n        }\n        optionsObj = {\n          key: options\n        };\n      }\n    } else {\n      optionsObj = options;\n    }\n    if (modularPluginsToInclude) {\n      optionsObj = __spreadProps(__spreadValues({}, optionsObj), {\n        plugins: __spreadValues(__spreadValues({}, modularPluginsToInclude), optionsObj.plugins)\n      });\n    }\n    return optionsObj;\n  }\n  function normaliseOptions(options, MsgPack) {\n    if (typeof options.recover === \"function\" && options.closeOnUnload === true) {\n      logger_default.logAction(logger_default.LOG_ERROR, \"Defaults.normaliseOptions\", \"closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter\");\n      options.recover = void 0;\n    }\n    if (!(\"closeOnUnload\" in options)) {\n      options.closeOnUnload = !options.recover;\n    }\n    if (!(\"queueMessages\" in options)) options.queueMessages = true;\n    const environment = options.environment && String(options.environment).toLowerCase() || Defaults.ENVIRONMENT;\n    const production = !environment || environment === \"production\";\n    if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\n      options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);\n    }\n    const restHost = options.restHost || (production ? Defaults.REST_HOST : environment + \"-\" + Defaults.REST_HOST);\n    const realtimeHost = getRealtimeHost(options, production, environment);\n    (options.fallbackHosts || []).concat(restHost, realtimeHost).forEach(checkHost);\n    options.port = options.port || Defaults.PORT;\n    options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\n    if (!(\"tls\" in options)) options.tls = true;\n    const timeouts = getTimeouts(options);\n    if (MsgPack) {\n      if (\"useBinaryProtocol\" in options) {\n        options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\n      } else {\n        options.useBinaryProtocol = Platform.Config.preferBinary;\n      }\n    } else {\n      options.useBinaryProtocol = false;\n    }\n    const headers = {};\n    if (options.clientId) {\n      headers[\"X-Ably-ClientId\"] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\n    }\n    if (!(\"idempotentRestPublishing\" in options)) {\n      options.idempotentRestPublishing = true;\n    }\n    let connectivityCheckParams = null;\n    let connectivityCheckUrl = options.connectivityCheckUrl;\n    if (options.connectivityCheckUrl) {\n      let [uri, qs] = options.connectivityCheckUrl.split(\"?\");\n      connectivityCheckParams = qs ? parseQueryString(qs) : {};\n      if (uri.indexOf(\"://\") === -1) {\n        uri = \"https://\" + uri;\n      }\n      connectivityCheckUrl = uri;\n    }\n    return __spreadProps(__spreadValues({}, options), {\n      realtimeHost,\n      restHost,\n      maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize,\n      timeouts,\n      connectivityCheckParams,\n      connectivityCheckUrl,\n      headers\n    });\n  }\n  function normaliseChannelOptions(Crypto2, options) {\n    const channelOptions = options || {};\n    if (channelOptions.cipher) {\n      if (!Crypto2) throwMissingPluginError(\"Crypto\");\n      const cipher = Crypto2.getCipher(channelOptions.cipher);\n      channelOptions.cipher = cipher.cipherParams;\n      channelOptions.channelCipher = cipher.cipher;\n    } else if (\"cipher\" in channelOptions) {\n      channelOptions.cipher = void 0;\n      channelOptions.channelCipher = null;\n    }\n    return channelOptions;\n  }\n  var contentTypes = {\n    json: \"application/json\",\n    xml: \"application/xml\",\n    html: \"text/html\",\n    msgpack: \"application/x-msgpack\"\n  };\n  var defaultHeadersOptions = {\n    format: \"json\" /* json */,\n    protocolVersion: Defaults.protocolVersion\n  };\n  function defaultGetHeaders(options, {\n    format = defaultHeadersOptions.format,\n    protocolVersion = defaultHeadersOptions.protocolVersion\n  } = {}) {\n    const accept = contentTypes[format];\n    return {\n      accept,\n      \"X-Ably-Version\": protocolVersion.toString(),\n      \"Ably-Agent\": getAgentString(options)\n    };\n  }\n  function defaultPostHeaders(options, {\n    format = defaultHeadersOptions.format,\n    protocolVersion = defaultHeadersOptions.protocolVersion\n  } = {}) {\n    let contentType;\n    const accept = contentType = contentTypes[format];\n    return {\n      accept,\n      \"content-type\": contentType,\n      \"X-Ably-Version\": protocolVersion.toString(),\n      \"Ably-Agent\": getAgentString(options)\n    };\n  }\n  var defaults_default = Defaults;\n  function getDefaults(platformDefaults) {\n    return Object.assign(Defaults, platformDefaults);\n  }\n\n  // src/common/lib/util/multicaster.ts\n  var Multicaster = class _Multicaster {\n    // Private constructor; use static Multicaster.create instead\n    constructor(members) {\n      this.members = members || [];\n    }\n    call(err, result) {\n      for (const member of this.members) {\n        if (member) {\n          try {\n            member(err, result);\n          } catch (e) {\n            logger_default.logAction(logger_default.LOG_ERROR, \"Multicaster multiple callback handler\", \"Unexpected exception: \" + e + \"; stack = \" + e.stack);\n          }\n        }\n      }\n    }\n    push(...args) {\n      this.members.push(...args);\n    }\n    createPromise() {\n      return new Promise((resolve, reject) => {\n        this.push((err, result) => {\n          err ? reject(err) : resolve(result);\n        });\n      });\n    }\n    resolveAll(result) {\n      this.call(null, result);\n    }\n    rejectAll(err) {\n      this.call(err);\n    }\n    static create(members) {\n      const instance = new _Multicaster(members);\n      return Object.assign((err, result) => instance.call(err, result), {\n        push: fn => instance.push(fn),\n        createPromise: () => instance.createPromise(),\n        resolveAll: result => instance.resolveAll(result),\n        rejectAll: err => instance.rejectAll(err)\n      });\n    }\n  };\n  var multicaster_default = Multicaster;\n\n  // src/common/constants/HttpMethods.ts\n  var HttpMethods = /* @__PURE__ */(HttpMethods2 => {\n    HttpMethods2[\"Get\"] = \"get\";\n    HttpMethods2[\"Delete\"] = \"delete\";\n    HttpMethods2[\"Post\"] = \"post\";\n    HttpMethods2[\"Put\"] = \"put\";\n    HttpMethods2[\"Patch\"] = \"patch\";\n    return HttpMethods2;\n  })(HttpMethods || {});\n  var HttpMethods_default = HttpMethods;\n\n  // src/common/constants/HttpStatusCodes.ts\n  var HttpStatusCodes = /* @__PURE__ */(HttpStatusCodes2 => {\n    HttpStatusCodes2[HttpStatusCodes2[\"Success\"] = 200] = \"Success\";\n    HttpStatusCodes2[HttpStatusCodes2[\"NoContent\"] = 204] = \"NoContent\";\n    HttpStatusCodes2[HttpStatusCodes2[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpStatusCodes2[HttpStatusCodes2[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpStatusCodes2[HttpStatusCodes2[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpStatusCodes2[HttpStatusCodes2[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpStatusCodes2[HttpStatusCodes2[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    return HttpStatusCodes2;\n  })(HttpStatusCodes || {});\n  function isSuccessCode(statusCode) {\n    return statusCode >= 200 /* Success */ && statusCode < 400 /* BadRequest */;\n  }\n  var HttpStatusCodes_default = HttpStatusCodes;\n\n  // src/common/lib/client/auth.ts\n  var MAX_TOKEN_LENGTH = Math.pow(2, 17);\n  function random() {\n    return (\"000000\" + Math.floor(Math.random() * 1e16)).slice(-16);\n  }\n  function isRealtime(client) {\n    return !!client.connection;\n  }\n  function normaliseAuthcallbackError(err) {\n    if (!isErrorInfoOrPartialErrorInfo(err)) {\n      return new ErrorInfo(inspectError(err), err.code || 40170, err.statusCode || 401);\n    }\n    if (!err.code) {\n      if (err.statusCode === 403) {\n        err.code = 40300;\n      } else {\n        err.code = 40170;\n        err.statusCode = 401;\n      }\n    }\n    return err;\n  }\n  var hmac = (text, key) => {\n    const bufferUtils = Platform.BufferUtils;\n    const textBuffer = bufferUtils.utf8Encode(text);\n    const keyBuffer = bufferUtils.utf8Encode(key);\n    const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\n    return bufferUtils.base64Encode(digest);\n  };\n  function c14n(capability) {\n    if (!capability) return \"\";\n    if (typeof capability == \"string\") capability = JSON.parse(capability);\n    const c14nCapability = /* @__PURE__ */Object.create(null);\n    const keys = keysArray(capability, true);\n    if (!keys) return \"\";\n    keys.sort();\n    for (let i = 0; i < keys.length; i++) {\n      c14nCapability[keys[i]] = capability[keys[i]].sort();\n    }\n    return JSON.stringify(c14nCapability);\n  }\n  function logAndValidateTokenAuthMethod(authOptions) {\n    if (authOptions.authCallback) {\n      logger_default.logAction(logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authCallback\");\n    } else if (authOptions.authUrl) {\n      logger_default.logAction(logger_default.LOG_MINOR, \"Auth()\", \"using token auth with authUrl\");\n    } else if (authOptions.key) {\n      logger_default.logAction(logger_default.LOG_MINOR, \"Auth()\", \"using token auth with client-side signing\");\n    } else if (authOptions.tokenDetails) {\n      logger_default.logAction(logger_default.LOG_MINOR, \"Auth()\", \"using token auth with supplied token only\");\n    } else {\n      const msg = \"authOptions must include valid authentication parameters\";\n      logger_default.logAction(logger_default.LOG_ERROR, \"Auth()\", msg);\n      throw new Error(msg);\n    }\n  }\n  function basicAuthForced(options) {\n    return \"useTokenAuth\" in options && !options.useTokenAuth;\n  }\n  function useTokenAuth(options) {\n    return options.useTokenAuth || !basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails);\n  }\n  function noWayToRenew(options) {\n    return !options.key && !options.authCallback && !options.authUrl;\n  }\n  var trId = 0;\n  function getTokenRequestId() {\n    return trId++;\n  }\n  var Auth = class {\n    constructor(client, options) {\n      // This initialization is always overwritten and only used to prevent a TypeScript compiler error\n      this.authOptions = {};\n      this.client = client;\n      this.tokenParams = options.defaultTokenParams || {};\n      this.currentTokenRequestId = null;\n      this.waitingForTokenRequest = null;\n      if (useTokenAuth(options)) {\n        if (noWayToRenew(options)) {\n          logger_default.logAction(logger_default.LOG_ERROR, \"Auth()\", \"Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\");\n        }\n        this._saveTokenOptions(options.defaultTokenParams, options);\n        logAndValidateTokenAuthMethod(this.authOptions);\n      } else {\n        if (!options.key) {\n          const msg = \"No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)\";\n          logger_default.logAction(logger_default.LOG_ERROR, \"Auth()\", msg);\n          throw new ErrorInfo(msg, 40160, 401);\n        }\n        logger_default.logAction(logger_default.LOG_MINOR, \"Auth()\", \"anonymous, using basic auth\");\n        this._saveBasicOptions(options);\n      }\n    }\n    async authorize(tokenParams, authOptions) {\n      if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {\n        throw new ErrorInfo(\"Unable to update auth options with incompatible key\", 40102, 401);\n      }\n      try {\n        let tokenDetails = await this._forceNewToken(tokenParams != null ? tokenParams : null, authOptions != null ? authOptions : null);\n        if (isRealtime(this.client)) {\n          return new Promise((resolve, reject) => {\n            this.client.connection.connectionManager.onAuthUpdated(tokenDetails, (err, tokenDetails2) => err ? reject(err) : resolve(tokenDetails2));\n          });\n        } else {\n          return tokenDetails;\n        }\n      } catch (err) {\n        if (this.client.connection && err.statusCode === HttpStatusCodes_default.Forbidden) {\n          this.client.connection.connectionManager.actOnErrorFromAuthorize(err);\n        }\n        throw err;\n      }\n    }\n    /* For internal use, eg by connectionManager - useful when want to call back\n     * as soon as we have the new token, rather than waiting for it to take\n     * effect on the connection as #authorize does */\n    async _forceNewToken(tokenParams, authOptions) {\n      this.tokenDetails = null;\n      this._saveTokenOptions(tokenParams, authOptions);\n      logAndValidateTokenAuthMethod(this.authOptions);\n      try {\n        return this._ensureValidAuthCredentials(true);\n      } finally {\n        delete this.tokenParams.timestamp;\n        delete this.authOptions.queryTime;\n      }\n    }\n    async requestToken(tokenParams, authOptions) {\n      const resolvedAuthOptions = authOptions || this.authOptions;\n      const resolvedTokenParams = tokenParams || copy(this.tokenParams);\n      let tokenRequestCallback,\n        client = this.client;\n      if (resolvedAuthOptions.authCallback) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authCallback\");\n        tokenRequestCallback = resolvedAuthOptions.authCallback;\n      } else if (resolvedAuthOptions.authUrl) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with authUrl\");\n        tokenRequestCallback = (params, cb) => {\n          const authHeaders = mixin({\n            accept: \"application/json, text/plain\"\n          }, resolvedAuthOptions.authHeaders);\n          const usePost = resolvedAuthOptions.authMethod && resolvedAuthOptions.authMethod.toLowerCase() === \"post\";\n          let providedQsParams;\n          const queryIdx = resolvedAuthOptions.authUrl.indexOf(\"?\");\n          if (queryIdx > -1) {\n            providedQsParams = parseQueryString(resolvedAuthOptions.authUrl.slice(queryIdx));\n            resolvedAuthOptions.authUrl = resolvedAuthOptions.authUrl.slice(0, queryIdx);\n            if (!usePost) {\n              resolvedAuthOptions.authParams = mixin(providedQsParams, resolvedAuthOptions.authParams);\n            }\n          }\n          const authParams = mixin({}, resolvedAuthOptions.authParams || {}, params);\n          const authUrlRequestCallback = function (result) {\n            var _a2, _b;\n            let body = (_a2 = result.body) != null ? _a2 : null;\n            let contentType = null;\n            if (result.error) {\n              logger_default.logAction(logger_default.LOG_MICRO, \"Auth.requestToken().tokenRequestCallback\", \"Received Error: \" + inspectError(result.error));\n            } else {\n              const contentTypeHeaderOrHeaders = (_b = result.headers[\"content-type\"]) != null ? _b : null;\n              if (Array.isArray(contentTypeHeaderOrHeaders)) {\n                contentType = contentTypeHeaderOrHeaders.join(\", \");\n              } else {\n                contentType = contentTypeHeaderOrHeaders;\n              }\n              logger_default.logAction(logger_default.LOG_MICRO, \"Auth.requestToken().tokenRequestCallback\", \"Received; content-type: \" + contentType + \"; body: \" + inspectBody(body));\n            }\n            if (result.error) {\n              cb(result.error, null);\n              return;\n            }\n            if (result.unpacked) {\n              cb(null, body);\n              return;\n            }\n            if (Platform.BufferUtils.isBuffer(body)) body = body.toString();\n            if (!contentType) {\n              cb(new ErrorInfo(\"authUrl response is missing a content-type header\", 40170, 401), null);\n              return;\n            }\n            const json = contentType.indexOf(\"application/json\") > -1,\n              text = contentType.indexOf(\"text/plain\") > -1 || contentType.indexOf(\"application/jwt\") > -1;\n            if (!json && !text) {\n              cb(new ErrorInfo(\"authUrl responded with unacceptable content-type \" + contentType + \", should be either text/plain, application/jwt or application/json\", 40170, 401), null);\n              return;\n            }\n            if (json) {\n              if (body.length > MAX_TOKEN_LENGTH) {\n                cb(new ErrorInfo(\"authUrl response exceeded max permitted length\", 40170, 401), null);\n                return;\n              }\n              try {\n                body = JSON.parse(body);\n              } catch (e) {\n                cb(new ErrorInfo(\"Unexpected error processing authURL response; err = \" + e.message, 40170, 401), null);\n                return;\n              }\n            }\n            cb(null, body, contentType);\n          };\n          logger_default.logAction(logger_default.LOG_MICRO, \"Auth.requestToken().tokenRequestCallback\", \"Requesting token from \" + resolvedAuthOptions.authUrl + \"; Params: \" + JSON.stringify(authParams) + \"; method: \" + (usePost ? \"POST\" : \"GET\"));\n          if (usePost) {\n            const headers = authHeaders || {};\n            headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n            const body = toQueryString(authParams).slice(1);\n            whenPromiseSettles(this.client.http.doUri(HttpMethods_default.Post, resolvedAuthOptions.authUrl, headers, body, providedQsParams), (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result));\n          } else {\n            whenPromiseSettles(this.client.http.doUri(HttpMethods_default.Get, resolvedAuthOptions.authUrl, authHeaders || {}, null, authParams), (err, result) => err ? authUrlRequestCallback(err) : authUrlRequestCallback(result));\n          }\n        };\n      } else if (resolvedAuthOptions.key) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"Auth.requestToken()\", \"using token auth with client-side signing\");\n        tokenRequestCallback = (params, cb) => {\n          whenPromiseSettles(this.createTokenRequest(params, resolvedAuthOptions), (err, result) => cb(err, result != null ? result : null));\n        };\n      } else {\n        const msg = \"Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)\";\n        logger_default.logAction(logger_default.LOG_ERROR, \"Auth()\", \"library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help\");\n        throw new ErrorInfo(msg, 40171, 403);\n      }\n      if (\"capability\" in resolvedTokenParams) resolvedTokenParams.capability = c14n(resolvedTokenParams.capability);\n      const tokenRequest = (signedTokenParams, tokenCb) => {\n        const keyName = signedTokenParams.keyName,\n          path = \"/keys/\" + keyName + \"/requestToken\",\n          tokenUri = function (host) {\n            return client.baseUri(host) + path;\n          };\n        const requestHeaders = defaults_default.defaultPostHeaders(this.client.options);\n        if (resolvedAuthOptions.requestHeaders) mixin(requestHeaders, resolvedAuthOptions.requestHeaders);\n        logger_default.logAction(logger_default.LOG_MICRO, \"Auth.requestToken().requestToken\", \"Sending POST to \" + path + \"; Token params: \" + JSON.stringify(signedTokenParams));\n        whenPromiseSettles(this.client.http.do(HttpMethods_default.Post, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null), (err, result) => err ? tokenCb(err) : tokenCb(result.error, result.body, result.unpacked));\n      };\n      return new Promise((resolve, reject) => {\n        let tokenRequestCallbackTimeoutExpired = false,\n          timeoutLength = this.client.options.timeouts.realtimeRequestTimeout,\n          tokenRequestCallbackTimeout = setTimeout(function () {\n            tokenRequestCallbackTimeoutExpired = true;\n            const msg = \"Token request callback timed out after \" + timeoutLength / 1e3 + \" seconds\";\n            logger_default.logAction(logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n            reject(new ErrorInfo(msg, 40170, 401));\n          }, timeoutLength);\n        tokenRequestCallback(resolvedTokenParams, function (err, tokenRequestOrDetails, contentType) {\n          if (tokenRequestCallbackTimeoutExpired) return;\n          clearTimeout(tokenRequestCallbackTimeout);\n          if (err) {\n            logger_default.logAction(logger_default.LOG_ERROR, \"Auth.requestToken()\", \"token request signing call returned error; err = \" + inspectError(err));\n            reject(normaliseAuthcallbackError(err));\n            return;\n          }\n          if (typeof tokenRequestOrDetails === \"string\") {\n            if (tokenRequestOrDetails.length === 0) {\n              reject(new ErrorInfo(\"Token string is empty\", 40170, 401));\n            } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\n              reject(new ErrorInfo(\"Token string exceeded max permitted length (was \" + tokenRequestOrDetails.length + \" bytes)\", 40170, 401));\n            } else if (tokenRequestOrDetails === \"undefined\" || tokenRequestOrDetails === \"null\") {\n              reject(new ErrorInfo(\"Token string was literal null/undefined\", 40170, 401));\n            } else if (tokenRequestOrDetails[0] === \"{\" && !(contentType && contentType.indexOf(\"application/jwt\") > -1)) {\n              reject(new ErrorInfo(\"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\", 40170, 401));\n            } else {\n              resolve({\n                token: tokenRequestOrDetails\n              });\n            }\n            return;\n          }\n          if (typeof tokenRequestOrDetails !== \"object\" || tokenRequestOrDetails === null) {\n            const msg = \"Expected token request callback to call back with a token string or token request/details object, but got a \" + typeof tokenRequestOrDetails;\n            logger_default.logAction(logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n            reject(new ErrorInfo(msg, 40170, 401));\n            return;\n          }\n          const objectSize = JSON.stringify(tokenRequestOrDetails).length;\n          if (objectSize > MAX_TOKEN_LENGTH && !resolvedAuthOptions.suppressMaxLengthCheck) {\n            reject(new ErrorInfo(\"Token request/details object exceeded max permitted stringified size (was \" + objectSize + \" bytes)\", 40170, 401));\n            return;\n          }\n          if (\"issued\" in tokenRequestOrDetails) {\n            resolve(tokenRequestOrDetails);\n            return;\n          }\n          if (!(\"keyName\" in tokenRequestOrDetails)) {\n            const msg = \"Expected token request callback to call back with a token string, token request object, or token details object\";\n            logger_default.logAction(logger_default.LOG_ERROR, \"Auth.requestToken()\", msg);\n            reject(new ErrorInfo(msg, 40170, 401));\n            return;\n          }\n          tokenRequest(tokenRequestOrDetails, function (err2, tokenResponse, unpacked) {\n            if (err2) {\n              logger_default.logAction(logger_default.LOG_ERROR, \"Auth.requestToken()\", \"token request API call returned error; err = \" + inspectError(err2));\n              reject(normaliseAuthcallbackError(err2));\n              return;\n            }\n            if (!unpacked) tokenResponse = JSON.parse(tokenResponse);\n            logger_default.logAction(logger_default.LOG_MINOR, \"Auth.getToken()\", \"token received\");\n            resolve(tokenResponse);\n          });\n        });\n      });\n    }\n    /**\n     * Create and sign a token request based on the given options.\n     * NOTE this can only be used when the key value is available locally.\n     * Otherwise, signed token requests must be obtained from the key\n     * owner (either using the token request callback or url).\n     *\n     * @param authOptions\n     * an object containing the request options:\n     * - key:           the key to use. If not specified, a key passed in constructing\n     *                  the Rest interface will be used\n     *\n     * - queryTime      (optional) boolean indicating that the ably system should be\n     *                  queried for the current time when none is specified explicitly\n     *\n     * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n     *                  requestToken request\n     *\n     * @param tokenParams\n     * an object containing the parameters for the requested token:\n     * - ttl:       (optional) the requested life of the token in ms. If none is specified\n     *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n     *                  exceeding that lifetime will be rejected with an error.\n     *\n     * - capability:    (optional) the capability to associate with the access token.\n     *                  If none is specified, a token will be requested with all of the\n     *                  capabilities of the specified key.\n     *\n     * - clientId:      (optional) a client ID to associate with the token; if not\n     *                  specified, a clientId passed in constructing the Rest interface will be used\n     *\n     * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n     *                  the system will be queried for a time value to use.\n     */\n    async createTokenRequest(tokenParams, authOptions) {\n      authOptions = authOptions || this.authOptions;\n      tokenParams = tokenParams || copy(this.tokenParams);\n      const key = authOptions.key;\n      if (!key) {\n        throw new ErrorInfo(\"No key specified\", 40101, 403);\n      }\n      const keyParts = key.split(\":\"),\n        keyName = keyParts[0],\n        keySecret = keyParts[1];\n      if (!keySecret) {\n        throw new ErrorInfo(\"Invalid key specified\", 40101, 403);\n      }\n      if (tokenParams.clientId === \"\") {\n        throw new ErrorInfo(\"clientId can\\u2019t be an empty string\", 40012, 400);\n      }\n      if (\"capability\" in tokenParams) {\n        tokenParams.capability = c14n(tokenParams.capability);\n      }\n      const request = mixin({\n          keyName\n        }, tokenParams),\n        clientId = tokenParams.clientId || \"\",\n        ttl = tokenParams.ttl || \"\",\n        capability = tokenParams.capability || \"\";\n      if (!request.timestamp) {\n        request.timestamp = await this.getTimestamp(authOptions && authOptions.queryTime);\n      }\n      const nonce = request.nonce || (request.nonce = random()),\n        timestamp = request.timestamp;\n      const signText = request.keyName + \"\\n\" + ttl + \"\\n\" + capability + \"\\n\" + clientId + \"\\n\" + timestamp + \"\\n\" + nonce + \"\\n\";\n      request.mac = request.mac || hmac(signText, keySecret);\n      logger_default.logAction(logger_default.LOG_MINOR, \"Auth.getTokenRequest()\", \"generated signed request\");\n      return request;\n    }\n    /**\n     * Get the auth query params to use for a websocket connection,\n     * based on the current auth parameters\n     */\n    async getAuthParams() {\n      if (this.method == \"basic\") return {\n        key: this.key\n      };else {\n        let tokenDetails = await this._ensureValidAuthCredentials(false);\n        if (!tokenDetails) {\n          throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n        }\n        return {\n          access_token: tokenDetails.token\n        };\n      }\n    }\n    /**\n     * Get the authorization header to use for a REST or comet request,\n     * based on the current auth parameters\n     */\n    async getAuthHeaders() {\n      if (this.method == \"basic\") {\n        return {\n          authorization: \"Basic \" + this.basicKey\n        };\n      } else {\n        const tokenDetails = await this._ensureValidAuthCredentials(false);\n        if (!tokenDetails) {\n          throw new Error(\"Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails\");\n        }\n        return {\n          authorization: \"Bearer \" + toBase64(tokenDetails.token)\n        };\n      }\n    }\n    /**\n     * Get the current time based on the local clock,\n     * or if the option queryTime is true, return the server time.\n     * The server time offset from the local time is stored so that\n     * only one request to the server to get the time is ever needed\n     */\n    async getTimestamp(queryTime) {\n      if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {\n        return this.client.time();\n      } else {\n        return this.getTimestampUsingOffset();\n      }\n    }\n    getTimestampUsingOffset() {\n      return Date.now() + (this.client.serverTimeOffset || 0);\n    }\n    isTimeOffsetSet() {\n      return this.client.serverTimeOffset !== null;\n    }\n    _saveBasicOptions(authOptions) {\n      this.method = \"basic\";\n      this.key = authOptions.key;\n      this.basicKey = toBase64(authOptions.key);\n      this.authOptions = authOptions || {};\n      if (\"clientId\" in authOptions) {\n        this._userSetClientId(authOptions.clientId);\n      }\n    }\n    _saveTokenOptions(tokenParams, authOptions) {\n      this.method = \"token\";\n      if (tokenParams) {\n        this.tokenParams = tokenParams;\n      }\n      if (authOptions) {\n        if (authOptions.token) {\n          authOptions.tokenDetails = typeof authOptions.token === \"string\" ? {\n            token: authOptions.token\n          } : authOptions.token;\n        }\n        if (authOptions.tokenDetails) {\n          this.tokenDetails = authOptions.tokenDetails;\n        }\n        if (\"clientId\" in authOptions) {\n          this._userSetClientId(authOptions.clientId);\n        }\n        this.authOptions = authOptions;\n      }\n    }\n    /* @param forceSupersede: force a new token request even if there's one in\n     * progress, making all pending callbacks wait for the new one */\n    async _ensureValidAuthCredentials(forceSupersede) {\n      const token = this.tokenDetails;\n      if (token) {\n        if (this._tokenClientIdMismatch(token.clientId)) {\n          throw new ErrorInfo(\"Mismatch between clientId in token (\" + token.clientId + \") and current clientId (\" + this.clientId + \")\", 40102, 403);\n        }\n        if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {\n          logger_default.logAction(logger_default.LOG_MINOR, \"Auth.getToken()\", \"using cached token; expires = \" + token.expires);\n          return token;\n        }\n        logger_default.logAction(logger_default.LOG_MINOR, \"Auth.getToken()\", \"deleting expired token\");\n        this.tokenDetails = null;\n      }\n      const promise = (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_default.create())).createPromise();\n      if (this.currentTokenRequestId !== null && !forceSupersede) {\n        return promise;\n      }\n      const tokenRequestId = this.currentTokenRequestId = getTokenRequestId();\n      let tokenResponse,\n        caughtError = null;\n      try {\n        tokenResponse = await this.requestToken(this.tokenParams, this.authOptions);\n      } catch (err) {\n        caughtError = err;\n      }\n      if (this.currentTokenRequestId > tokenRequestId) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"Auth._ensureValidAuthCredentials()\", \"Discarding token request response; overtaken by newer one\");\n        return promise;\n      }\n      this.currentTokenRequestId = null;\n      const multicaster = this.waitingForTokenRequest;\n      this.waitingForTokenRequest = null;\n      if (caughtError) {\n        multicaster == null ? void 0 : multicaster.rejectAll(caughtError);\n        return promise;\n      }\n      multicaster == null ? void 0 : multicaster.resolveAll(this.tokenDetails = tokenResponse);\n      return promise;\n    }\n    /* User-set: check types, '*' is disallowed, throw any errors */\n    _userSetClientId(clientId) {\n      if (!(typeof clientId === \"string\" || clientId === null)) {\n        throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);\n      } else if (clientId === \"*\") {\n        throw new ErrorInfo('Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)', 40012, 400);\n      } else {\n        const err = this._uncheckedSetClientId(clientId);\n        if (err) throw err;\n      }\n    }\n    /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\n    _uncheckedSetClientId(clientId) {\n      if (this._tokenClientIdMismatch(clientId)) {\n        const msg = \"Unexpected clientId mismatch: client has \" + this.clientId + \", requested \" + clientId;\n        const err = new ErrorInfo(msg, 40102, 401);\n        logger_default.logAction(logger_default.LOG_ERROR, \"Auth._uncheckedSetClientId()\", msg);\n        return err;\n      } else {\n        this.clientId = this.tokenParams.clientId = clientId;\n        return null;\n      }\n    }\n    _tokenClientIdMismatch(tokenClientId) {\n      return !!(this.clientId && this.clientId !== \"*\" && tokenClientId && tokenClientId !== \"*\" && this.clientId !== tokenClientId);\n    }\n    static isTokenErr(error) {\n      return error.code && error.code >= 40140 && error.code < 40150;\n    }\n    revokeTokens(specifiers, options) {\n      return this.client.rest.revokeTokens(specifiers, options);\n    }\n  };\n  var auth_default = Auth;\n\n  // src/common/types/http.ts\n  function paramString(params) {\n    const paramPairs = [];\n    if (params) {\n      for (const needle in params) {\n        paramPairs.push(needle + \"=\" + params[needle]);\n      }\n    }\n    return paramPairs.join(\"&\");\n  }\n  function appendingParams(uri, params) {\n    return uri + (params ? \"?\" : \"\") + paramString(params);\n  }\n  function logResult(result, method, uri, params) {\n    if (result.error) {\n      logger_default.logActionNoStrip(logger_default.LOG_MICRO, \"Http.\" + method + \"()\", \"Received Error; \" + appendingParams(uri, params) + \"; Error: \" + inspectError(result.error));\n    } else {\n      logger_default.logActionNoStrip(logger_default.LOG_MICRO, \"Http.\" + method + \"()\", \"Received; \" + appendingParams(uri, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body\" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + result.body));\n    }\n  }\n  function logRequest(method, uri, body, params) {\n    if (logger_default.shouldLog(logger_default.LOG_MICRO)) {\n      logger_default.logActionNoStrip(logger_default.LOG_MICRO, \"Http.\" + method + \"()\", \"Sending; \" + appendingParams(uri, params) + \"; Body\" + (Platform.BufferUtils.isBuffer(body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(body) : \": \" + body));\n    }\n  }\n  var Http = class {\n    constructor(client) {\n      this.client = client;\n      this.platformHttp = new Platform.Http(client);\n      this.checkConnectivity = this.platformHttp.checkConnectivity ? () => this.platformHttp.checkConnectivity() : void 0;\n    }\n    get supportsAuthHeaders() {\n      return this.platformHttp.supportsAuthHeaders;\n    }\n    get supportsLinkHeaders() {\n      return this.platformHttp.supportsLinkHeaders;\n    }\n    _getHosts(client) {\n      const connection = client.connection,\n        connectionHost = connection && connection.connectionManager.host;\n      if (connectionHost) {\n        return [connectionHost].concat(defaults_default.getFallbackHosts(client.options));\n      }\n      return defaults_default.getHosts(client.options);\n    }\n    /**\n     * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n     */\n    async do(method, path, headers, body, params) {\n      try {\n        const client = this.client;\n        if (!client) {\n          return {\n            error: new ErrorInfo(\"http.do called without client\", 5e4, 500)\n          };\n        }\n        const uriFromHost = typeof path === \"function\" ? path : function (host) {\n          return client.baseUri(host) + path;\n        };\n        const currentFallback = client._currentFallback;\n        if (currentFallback) {\n          if (currentFallback.validUntil > Date.now()) {\n            const result = await this.doUri(method, uriFromHost(currentFallback.host), headers, body, params);\n            if (result.error && this.platformHttp.shouldFallback(result.error)) {\n              client._currentFallback = null;\n              return this.do(method, path, headers, body, params);\n            }\n            return result;\n          } else {\n            client._currentFallback = null;\n          }\n        }\n        const hosts = this._getHosts(client);\n        if (hosts.length === 1) {\n          return this.doUri(method, uriFromHost(hosts[0]), headers, body, params);\n        }\n        const tryAHost = async (candidateHosts, persistOnSuccess) => {\n          const host = candidateHosts.shift();\n          const result = await this.doUri(method, uriFromHost(host), headers, body, params);\n          if (result.error && this.platformHttp.shouldFallback(result.error) && candidateHosts.length) {\n            return tryAHost(candidateHosts, true);\n          }\n          if (persistOnSuccess) {\n            client._currentFallback = {\n              host,\n              validUntil: Date.now() + client.options.timeouts.fallbackRetryTimeout\n            };\n          }\n          return result;\n        };\n        return tryAHost(hosts);\n      } catch (err) {\n        return {\n          error: new ErrorInfo(`Unexpected error in Http.do: ${inspectError(err)}`, 500, 5e4)\n        };\n      }\n    }\n    /**\n     * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\n     */\n    async doUri(method, uri, headers, body, params) {\n      try {\n        logRequest(method, uri, body, params);\n        const result = await this.platformHttp.doUri(method, uri, headers, body, params);\n        if (logger_default.shouldLog(logger_default.LOG_MICRO)) {\n          logResult(result, method, uri, params);\n        }\n        return result;\n      } catch (err) {\n        return {\n          error: new ErrorInfo(`Unexpected error in Http.doUri: ${inspectError(err)}`, 500, 5e4)\n        };\n      }\n    }\n  };\n\n  // src/common/lib/client/baseclient.ts\n  var BaseClient = class {\n    constructor(options) {\n      var _a2, _b, _c, _d, _e, _f, _g, _h;\n      this._additionalHTTPRequestImplementations = (_a2 = options.plugins) != null ? _a2 : null;\n      logger_default.setLog(options.logLevel, options.logHandler);\n      logger_default.logAction(logger_default.LOG_MICRO, \"BaseClient()\", \"initialized with clientOptions \" + Platform.Config.inspect(options));\n      this._MsgPack = (_c = (_b = options.plugins) == null ? void 0 : _b.MsgPack) != null ? _c : null;\n      const normalOptions = this.options = defaults_default.normaliseOptions(options, this._MsgPack);\n      if (normalOptions.key) {\n        const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\n        if (!keyMatch) {\n          const msg = \"invalid key parameter\";\n          logger_default.logAction(logger_default.LOG_ERROR, \"BaseClient()\", msg);\n          throw new ErrorInfo(msg, 40400, 404);\n        }\n        normalOptions.keyName = keyMatch[1];\n        normalOptions.keySecret = keyMatch[2];\n      }\n      if (\"clientId\" in normalOptions) {\n        if (!(typeof normalOptions.clientId === \"string\" || normalOptions.clientId === null)) throw new ErrorInfo(\"clientId must be either a string or null\", 40012, 400);else if (normalOptions.clientId === \"*\") throw new ErrorInfo('Can\\u2019t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})', 40012, 400);\n      }\n      logger_default.logAction(logger_default.LOG_MINOR, \"BaseClient()\", \"started; version = \" + defaults_default.version);\n      this._currentFallback = null;\n      this.serverTimeOffset = null;\n      this.http = new Http(this);\n      this.auth = new auth_default(this, normalOptions);\n      this._rest = ((_d = options.plugins) == null ? void 0 : _d.Rest) ? new options.plugins.Rest(this) : null;\n      this._Crypto = (_f = (_e = options.plugins) == null ? void 0 : _e.Crypto) != null ? _f : null;\n      this.__FilteredSubscriptions = (_h = (_g = options.plugins) == null ? void 0 : _g.MessageInteractions) != null ? _h : null;\n    }\n    get rest() {\n      if (!this._rest) {\n        throwMissingPluginError(\"Rest\");\n      }\n      return this._rest;\n    }\n    get _FilteredSubscriptions() {\n      if (!this.__FilteredSubscriptions) {\n        throwMissingPluginError(\"MessageInteractions\");\n      }\n      return this.__FilteredSubscriptions;\n    }\n    get channels() {\n      return this.rest.channels;\n    }\n    get push() {\n      return this.rest.push;\n    }\n    baseUri(host) {\n      return defaults_default.getHttpScheme(this.options) + host + \":\" + defaults_default.getPort(this.options, false);\n    }\n    async stats(params) {\n      return this.rest.stats(params);\n    }\n    async time(params) {\n      return this.rest.time(params);\n    }\n    async request(method, path, version2, params, body, customHeaders) {\n      return this.rest.request(method, path, version2, params, body, customHeaders);\n    }\n    batchPublish(specOrSpecs) {\n      return this.rest.batchPublish(specOrSpecs);\n    }\n    batchPresence(channels) {\n      return this.rest.batchPresence(channels);\n    }\n    setLog(logOptions) {\n      logger_default.setLog(logOptions.level, logOptions.handler);\n    }\n  };\n  BaseClient.Platform = Platform;\n  var baseclient_default = BaseClient;\n\n  // src/common/lib/types/devicedetails.ts\n  var DeviceDetails = class _DeviceDetails {\n    toJSON() {\n      var _a2, _b, _c;\n      return {\n        id: this.id,\n        deviceSecret: this.deviceSecret,\n        platform: this.platform,\n        formFactor: this.formFactor,\n        clientId: this.clientId,\n        metadata: this.metadata,\n        deviceIdentityToken: this.deviceIdentityToken,\n        push: {\n          recipient: (_a2 = this.push) == null ? void 0 : _a2.recipient,\n          state: (_b = this.push) == null ? void 0 : _b.state,\n          error: (_c = this.push) == null ? void 0 : _c.error\n        }\n      };\n    }\n    toString() {\n      var _a2, _b, _c, _d;\n      let result = \"[DeviceDetails\";\n      if (this.id) result += \"; id=\" + this.id;\n      if (this.platform) result += \"; platform=\" + this.platform;\n      if (this.formFactor) result += \"; formFactor=\" + this.formFactor;\n      if (this.clientId) result += \"; clientId=\" + this.clientId;\n      if (this.metadata) result += \"; metadata=\" + this.metadata;\n      if (this.deviceIdentityToken) result += \"; deviceIdentityToken=\" + JSON.stringify(this.deviceIdentityToken);\n      if ((_a2 = this.push) == null ? void 0 : _a2.recipient) result += \"; push.recipient=\" + JSON.stringify(this.push.recipient);\n      if ((_b = this.push) == null ? void 0 : _b.state) result += \"; push.state=\" + this.push.state;\n      if ((_c = this.push) == null ? void 0 : _c.error) result += \"; push.error=\" + JSON.stringify(this.push.error);\n      if ((_d = this.push) == null ? void 0 : _d.metadata) result += \"; push.metadata=\" + this.push.metadata;\n      result += \"]\";\n      return result;\n    }\n    static toRequestBody(body, MsgPack, format) {\n      return encodeBody(body, MsgPack, format);\n    }\n    static fromResponseBody(body, MsgPack, format) {\n      if (format) {\n        body = decodeBody(body, MsgPack, format);\n      }\n      if (Array.isArray(body)) {\n        return _DeviceDetails.fromValuesArray(body);\n      } else {\n        return _DeviceDetails.fromValues(body);\n      }\n    }\n    static fromValues(values) {\n      values.error = values.error && ErrorInfo.fromValues(values.error);\n      return Object.assign(new _DeviceDetails(), values);\n    }\n    static fromValuesArray(values) {\n      const count = values.length,\n        result = new Array(count);\n      for (let i = 0; i < count; i++) result[i] = _DeviceDetails.fromValues(values[i]);\n      return result;\n    }\n  };\n  var devicedetails_default = DeviceDetails;\n\n  // src/common/lib/client/resource.ts\n  async function withAuthDetails(client, headers, params, opCallback) {\n    if (client.http.supportsAuthHeaders) {\n      const authHeaders = await client.auth.getAuthHeaders();\n      return opCallback(mixin(authHeaders, headers), params);\n    } else {\n      const authParams = await client.auth.getAuthParams();\n      return opCallback(headers, mixin(authParams, params));\n    }\n  }\n  function unenvelope(result, MsgPack, format) {\n    if (result.err && !result.body) {\n      return {\n        err: result.err\n      };\n    }\n    if (result.statusCode === HttpStatusCodes_default.NoContent) {\n      return __spreadProps(__spreadValues({}, result), {\n        body: [],\n        unpacked: true\n      });\n    }\n    let body = result.body;\n    if (!result.unpacked) {\n      try {\n        body = decodeBody(body, MsgPack, format);\n      } catch (e) {\n        if (isErrorInfoOrPartialErrorInfo(e)) {\n          return {\n            err: e\n          };\n        } else {\n          return {\n            err: new PartialErrorInfo(inspectError(e), null)\n          };\n        }\n      }\n    }\n    if (!body) {\n      return {\n        err: new PartialErrorInfo(\"unenvelope(): Response body is missing\", null)\n      };\n    }\n    const {\n      statusCode: wrappedStatusCode,\n      response,\n      headers: wrappedHeaders\n    } = body;\n    if (wrappedStatusCode === void 0) {\n      return __spreadProps(__spreadValues({}, result), {\n        body,\n        unpacked: true\n      });\n    }\n    if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\n      let wrappedErr = response && response.error || result.err;\n      if (!wrappedErr) {\n        wrappedErr = new Error(\"Error in unenveloping \" + body);\n        wrappedErr.statusCode = wrappedStatusCode;\n      }\n      return {\n        err: wrappedErr,\n        body: response,\n        headers: wrappedHeaders,\n        unpacked: true,\n        statusCode: wrappedStatusCode\n      };\n    }\n    return {\n      err: result.err,\n      body: response,\n      headers: wrappedHeaders,\n      unpacked: true,\n      statusCode: wrappedStatusCode\n    };\n  }\n  function logResult2(result, method, path, params) {\n    if (result.err) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"Resource.\" + method + \"()\", \"Received Error; \" + appendingParams(path, params) + \"; Error: \" + inspectError(result.err));\n    } else {\n      logger_default.logAction(logger_default.LOG_MICRO, \"Resource.\" + method + \"()\", \"Received; \" + appendingParams(path, params) + \"; Headers: \" + paramString(result.headers) + \"; StatusCode: \" + result.statusCode + \"; Body: \" + (Platform.BufferUtils.isBuffer(result.body) ? \" (Base64): \" + Platform.BufferUtils.base64Encode(result.body) : \": \" + Platform.Config.inspect(result.body)));\n    }\n  }\n  var Resource = class _Resource {\n    static async get(client, path, headers, params, envelope, throwError) {\n      return _Resource.do(HttpMethods_default.Get, client, path, null, headers, params, envelope, throwError != null ? throwError : false);\n    }\n    static async delete(client, path, headers, params, envelope, throwError) {\n      return _Resource.do(HttpMethods_default.Delete, client, path, null, headers, params, envelope, throwError);\n    }\n    static async post(client, path, body, headers, params, envelope, throwError) {\n      return _Resource.do(HttpMethods_default.Post, client, path, body, headers, params, envelope, throwError);\n    }\n    static async patch(client, path, body, headers, params, envelope, throwError) {\n      return _Resource.do(HttpMethods_default.Patch, client, path, body, headers, params, envelope, throwError);\n    }\n    static async put(client, path, body, headers, params, envelope, throwError) {\n      return _Resource.do(HttpMethods_default.Put, client, path, body, headers, params, envelope, throwError);\n    }\n    static async do(method, client, path, body, headers, params, envelope, throwError) {\n      if (envelope) {\n        (params = params || {})[\"envelope\"] = envelope;\n      }\n      async function doRequest(headers2, params2) {\n        var _a2;\n        if (logger_default.shouldLog(logger_default.LOG_MICRO)) {\n          let decodedBody = body;\n          if (((_a2 = headers2[\"content-type\"]) == null ? void 0 : _a2.indexOf(\"msgpack\")) > 0) {\n            try {\n              if (!client._MsgPack) {\n                throwMissingPluginError(\"MsgPack\");\n              }\n              decodedBody = client._MsgPack.decode(body);\n            } catch (decodeErr) {\n              logger_default.logAction(logger_default.LOG_MICRO, \"Resource.\" + method + \"()\", \"Sending MsgPack Decoding Error: \" + inspectError(decodeErr));\n            }\n          }\n          logger_default.logAction(logger_default.LOG_MICRO, \"Resource.\" + method + \"()\", \"Sending; \" + appendingParams(path, params2) + \"; Body: \" + decodedBody);\n        }\n        const httpResult = await client.http.do(method, path, headers2, body, params2);\n        if (httpResult.error && auth_default.isTokenErr(httpResult.error)) {\n          await client.auth.authorize(null, null);\n          return withAuthDetails(client, headers2, params2, doRequest);\n        }\n        return {\n          err: httpResult.error,\n          body: httpResult.body,\n          headers: httpResult.headers,\n          unpacked: httpResult.unpacked,\n          statusCode: httpResult.statusCode\n        };\n      }\n      let result = await withAuthDetails(client, headers, params, doRequest);\n      if (envelope) {\n        result = unenvelope(result, client._MsgPack, envelope);\n      }\n      if (logger_default.shouldLog(logger_default.LOG_MICRO)) {\n        logResult2(result, method, path, params);\n      }\n      if (throwError) {\n        if (result.err) {\n          throw result.err;\n        } else {\n          const response = __spreadValues({}, result);\n          delete response.err;\n          return response;\n        }\n      }\n      return result;\n    }\n  };\n  var resource_default = Resource;\n\n  // src/common/lib/client/paginatedresource.ts\n  function getRelParams(linkUrl) {\n    const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\n    return urlMatch && urlMatch[2] && parseQueryString(urlMatch[2]);\n  }\n  function parseRelLinks(linkHeader) {\n    if (typeof linkHeader == \"string\") linkHeader = linkHeader.split(\",\");\n    const relParams = {};\n    for (let i = 0; i < linkHeader.length; i++) {\n      const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\n      if (linkMatch) {\n        const params = getRelParams(linkMatch[1]);\n        if (params) relParams[linkMatch[2]] = params;\n      }\n    }\n    return relParams;\n  }\n  function returnErrOnly(err, body, useHPR) {\n    return !(useHPR && (body || typeof err.code === \"number\"));\n  }\n  var PaginatedResource = class {\n    constructor(client, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {\n      this.client = client;\n      this.path = path;\n      this.headers = headers;\n      this.envelope = envelope != null ? envelope : null;\n      this.bodyHandler = bodyHandler;\n      this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\n    }\n    async get(params) {\n      const result = await resource_default.get(this.client, this.path, this.headers, params, this.envelope, false);\n      return this.handlePage(result);\n    }\n    async delete(params) {\n      const result = await resource_default.delete(this.client, this.path, this.headers, params, this.envelope, false);\n      return this.handlePage(result);\n    }\n    async post(params, body) {\n      const result = await resource_default.post(this.client, this.path, body, this.headers, params, this.envelope, false);\n      return this.handlePage(result);\n    }\n    async put(params, body) {\n      const result = await resource_default.put(this.client, this.path, body, this.headers, params, this.envelope, false);\n      return this.handlePage(result);\n    }\n    async patch(params, body) {\n      const result = await resource_default.patch(this.client, this.path, body, this.headers, params, this.envelope, false);\n      return this.handlePage(result);\n    }\n    async handlePage(result) {\n      if (result.err && returnErrOnly(result.err, result.body, this.useHttpPaginatedResponse)) {\n        logger_default.logAction(logger_default.LOG_ERROR, \"PaginatedResource.handlePage()\", \"Unexpected error getting resource: err = \" + inspectError(result.err));\n        throw result.err;\n      }\n      let items, linkHeader, relParams;\n      try {\n        items = result.statusCode == HttpStatusCodes_default.NoContent ? [] : await this.bodyHandler(result.body, result.headers || {}, result.unpacked);\n      } catch (e) {\n        throw result.err || e;\n      }\n      if (result.headers && (linkHeader = result.headers[\"Link\"] || result.headers[\"link\"])) {\n        relParams = parseRelLinks(linkHeader);\n      }\n      if (this.useHttpPaginatedResponse) {\n        return new HttpPaginatedResponse(this, items, result.headers || {}, result.statusCode, relParams, result.err);\n      } else {\n        return new PaginatedResult(this, items, relParams);\n      }\n    }\n  };\n  var PaginatedResult = class {\n    constructor(resource, items, relParams) {\n      this.resource = resource;\n      this.items = items;\n      const self2 = this;\n      if (relParams) {\n        if (\"first\" in relParams) {\n          this.first = async function () {\n            return self2.get(relParams.first);\n          };\n        }\n        if (\"current\" in relParams) {\n          this.current = async function () {\n            return self2.get(relParams.current);\n          };\n        }\n        this.next = async function () {\n          if (\"next\" in relParams) {\n            return self2.get(relParams.next);\n          } else {\n            return null;\n          }\n        };\n        this.hasNext = function () {\n          return \"next\" in relParams;\n        };\n        this.isLast = () => {\n          var _a2;\n          return !((_a2 = this.hasNext) == null ? void 0 : _a2.call(this));\n        };\n      }\n    }\n    /* We assume that only the initial request can be a POST, and that accessing\n     * the rest of a multipage set of results can always be done with GET */\n    async get(params) {\n      const res = this.resource;\n      const result = await resource_default.get(res.client, res.path, res.headers, params, res.envelope, false);\n      return res.handlePage(result);\n    }\n  };\n  var HttpPaginatedResponse = class extends PaginatedResult {\n    constructor(resource, items, headers, statusCode, relParams, err) {\n      super(resource, items, relParams);\n      this.statusCode = statusCode;\n      this.success = statusCode < 300 && statusCode >= 200;\n      this.headers = headers;\n      this.errorCode = err && err.code;\n      this.errorMessage = err && err.message;\n    }\n    toJSON() {\n      return {\n        items: this.items,\n        statusCode: this.statusCode,\n        success: this.success,\n        headers: this.headers,\n        errorCode: this.errorCode,\n        errorMessage: this.errorMessage\n      };\n    }\n  };\n  var paginatedresource_default = PaginatedResource;\n\n  // src/common/lib/types/pushchannelsubscription.ts\n  var _PushChannelSubscription = class _PushChannelSubscription {\n    /**\n     * Overload toJSON() to intercept JSON.stringify()\n     * @return {*}\n     */\n    toJSON() {\n      return {\n        channel: this.channel,\n        deviceId: this.deviceId,\n        clientId: this.clientId\n      };\n    }\n    toString() {\n      let result = \"[PushChannelSubscription\";\n      if (this.channel) result += \"; channel=\" + this.channel;\n      if (this.deviceId) result += \"; deviceId=\" + this.deviceId;\n      if (this.clientId) result += \"; clientId=\" + this.clientId;\n      result += \"]\";\n      return result;\n    }\n    static fromResponseBody(body, MsgPack, format) {\n      if (format) {\n        body = decodeBody(body, MsgPack, format);\n      }\n      if (Array.isArray(body)) {\n        return _PushChannelSubscription.fromValuesArray(body);\n      } else {\n        return _PushChannelSubscription.fromValues(body);\n      }\n    }\n    static fromValues(values) {\n      return Object.assign(new _PushChannelSubscription(), values);\n    }\n    static fromValuesArray(values) {\n      const count = values.length,\n        result = new Array(count);\n      for (let i = 0; i < count; i++) result[i] = _PushChannelSubscription.fromValues(values[i]);\n      return result;\n    }\n  };\n  _PushChannelSubscription.toRequestBody = encodeBody;\n  var PushChannelSubscription = _PushChannelSubscription;\n  var pushchannelsubscription_default = PushChannelSubscription;\n\n  // src/common/lib/client/push.ts\n  var Push = class {\n    constructor(client) {\n      this.client = client;\n      this.admin = new Admin(client);\n    }\n  };\n  var Admin = class {\n    constructor(client) {\n      this.client = client;\n      this.deviceRegistrations = new DeviceRegistrations(client);\n      this.channelSubscriptions = new ChannelSubscriptions(client);\n    }\n    async publish(recipient, payload) {\n      const client = this.client;\n      const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        headers = defaults_default.defaultPostHeaders(client.options, {\n          format\n        }),\n        params = {};\n      const body = mixin({\n        recipient\n      }, payload);\n      mixin(headers, client.options.headers);\n      if (client.options.pushFullWait) mixin(params, {\n        fullWait: \"true\"\n      });\n      const requestBody = encodeBody(body, client._MsgPack, format);\n      await resource_default.post(client, \"/push/publish\", requestBody, headers, params, null, true);\n    }\n  };\n  var DeviceRegistrations = class {\n    constructor(client) {\n      this.client = client;\n    }\n    async save(device) {\n      const client = this.client;\n      const body = devicedetails_default.fromValues(device);\n      const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        headers = defaults_default.defaultPostHeaders(client.options, {\n          format\n        }),\n        params = {};\n      mixin(headers, client.options.headers);\n      if (client.options.pushFullWait) mixin(params, {\n        fullWait: \"true\"\n      });\n      const requestBody = encodeBody(body, client._MsgPack, format);\n      const response = await resource_default.put(client, \"/push/deviceRegistrations/\" + encodeURIComponent(device.id), requestBody, headers, params, null, true);\n      return devicedetails_default.fromResponseBody(response.body, client._MsgPack, response.unpacked ? void 0 : format);\n    }\n    async get(deviceIdOrDetails) {\n      const client = this.client,\n        format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        headers = defaults_default.defaultGetHeaders(client.options, {\n          format\n        }),\n        deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n      if (typeof deviceId !== \"string\" || !deviceId.length) {\n        throw new ErrorInfo(\"First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails\", 4e4, 400);\n      }\n      mixin(headers, client.options.headers);\n      const response = await resource_default.get(client, \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId), headers, {}, null, true);\n      return devicedetails_default.fromResponseBody(response.body, client._MsgPack, response.unpacked ? void 0 : format);\n    }\n    async list(params) {\n      const client = this.client,\n        format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        envelope = this.client.http.supportsLinkHeaders ? void 0 : format,\n        headers = defaults_default.defaultGetHeaders(client.options, {\n          format\n        });\n      mixin(headers, client.options.headers);\n      return new paginatedresource_default(client, \"/push/deviceRegistrations\", headers, envelope, async function (body, headers2, unpacked) {\n        return devicedetails_default.fromResponseBody(body, client._MsgPack, unpacked ? void 0 : format);\n      }).get(params);\n    }\n    async remove(deviceIdOrDetails) {\n      const client = this.client,\n        format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        headers = defaults_default.defaultGetHeaders(client.options, {\n          format\n        }),\n        params = {},\n        deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n      if (typeof deviceId !== \"string\" || !deviceId.length) {\n        throw new ErrorInfo(\"First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails\", 4e4, 400);\n      }\n      mixin(headers, client.options.headers);\n      if (client.options.pushFullWait) mixin(params, {\n        fullWait: \"true\"\n      });\n      await resource_default[\"delete\"](client, \"/push/deviceRegistrations/\" + encodeURIComponent(deviceId), headers, params, null, true);\n    }\n    async removeWhere(params) {\n      const client = this.client,\n        format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        headers = defaults_default.defaultGetHeaders(client.options, {\n          format\n        });\n      mixin(headers, client.options.headers);\n      if (client.options.pushFullWait) mixin(params, {\n        fullWait: \"true\"\n      });\n      await resource_default[\"delete\"](client, \"/push/deviceRegistrations\", headers, params, null, true);\n    }\n  };\n  var ChannelSubscriptions = class _ChannelSubscriptions {\n    constructor(client) {\n      /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\n      this.remove = _ChannelSubscriptions.prototype.removeWhere;\n      this.client = client;\n    }\n    async save(subscription) {\n      const client = this.client;\n      const body = pushchannelsubscription_default.fromValues(subscription);\n      const format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        headers = defaults_default.defaultPostHeaders(client.options, {\n          format\n        }),\n        params = {};\n      mixin(headers, client.options.headers);\n      if (client.options.pushFullWait) mixin(params, {\n        fullWait: \"true\"\n      });\n      const requestBody = encodeBody(body, client._MsgPack, format);\n      const response = await resource_default.post(client, \"/push/channelSubscriptions\", requestBody, headers, params, null, true);\n      return pushchannelsubscription_default.fromResponseBody(response.body, client._MsgPack, response.unpacked ? void 0 : format);\n    }\n    async list(params) {\n      const client = this.client,\n        format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        envelope = this.client.http.supportsLinkHeaders ? void 0 : format,\n        headers = defaults_default.defaultGetHeaders(client.options, {\n          format\n        });\n      mixin(headers, client.options.headers);\n      return new paginatedresource_default(client, \"/push/channelSubscriptions\", headers, envelope, async function (body, headers2, unpacked) {\n        return pushchannelsubscription_default.fromResponseBody(body, client._MsgPack, unpacked ? void 0 : format);\n      }).get(params);\n    }\n    async removeWhere(params) {\n      const client = this.client,\n        format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        headers = defaults_default.defaultGetHeaders(client.options, {\n          format\n        });\n      mixin(headers, client.options.headers);\n      if (client.options.pushFullWait) mixin(params, {\n        fullWait: \"true\"\n      });\n      await resource_default[\"delete\"](client, \"/push/channelSubscriptions\", headers, params, null, true);\n    }\n    async listChannels(params) {\n      const client = this.client,\n        format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        envelope = this.client.http.supportsLinkHeaders ? void 0 : format,\n        headers = defaults_default.defaultGetHeaders(client.options, {\n          format\n        });\n      mixin(headers, client.options.headers);\n      if (client.options.pushFullWait) mixin(params, {\n        fullWait: \"true\"\n      });\n      return new paginatedresource_default(client, \"/push/channels\", headers, envelope, async function (body, headers2, unpacked) {\n        const parsedBody = !unpacked && format ? decodeBody(body, client._MsgPack, format) : body;\n        for (let i = 0; i < parsedBody.length; i++) {\n          parsedBody[i] = String(parsedBody[i]);\n        }\n        return parsedBody;\n      }).get(params);\n    }\n  };\n  var push_default = Push;\n\n  // src/common/lib/types/message.ts\n  function normaliseContext(context) {\n    if (!context || !context.channelOptions) {\n      return {\n        channelOptions: context,\n        plugins: {},\n        baseEncodedPreviousPayload: void 0\n      };\n    }\n    return context;\n  }\n  function normalizeCipherOptions(Crypto2, options) {\n    if (options && options.cipher) {\n      if (!Crypto2) throwMissingPluginError(\"Crypto\");\n      const cipher = Crypto2.getCipher(options.cipher);\n      return {\n        cipher: cipher.cipherParams,\n        channelCipher: cipher.cipher\n      };\n    }\n    return options != null ? options : {};\n  }\n  function getMessageSize(msg) {\n    let size = 0;\n    if (msg.name) {\n      size += msg.name.length;\n    }\n    if (msg.clientId) {\n      size += msg.clientId.length;\n    }\n    if (msg.extras) {\n      size += JSON.stringify(msg.extras).length;\n    }\n    if (msg.data) {\n      size += dataSizeBytes(msg.data);\n    }\n    return size;\n  }\n  async function fromEncoded(Crypto2, encoded, inputOptions) {\n    const msg = fromValues(encoded);\n    const options = normalizeCipherOptions(Crypto2, inputOptions != null ? inputOptions : null);\n    try {\n      await decode(msg, options);\n    } catch (e) {\n      logger_default.logAction(logger_default.LOG_ERROR, \"Message.fromEncoded()\", e.toString());\n    }\n    return msg;\n  }\n  async function fromEncodedArray(Crypto2, encodedArray, options) {\n    return Promise.all(encodedArray.map(function (encoded) {\n      return fromEncoded(Crypto2, encoded, options);\n    }));\n  }\n  async function encrypt(msg, options) {\n    let data = msg.data,\n      encoding = msg.encoding,\n      cipher = options.channelCipher;\n    encoding = encoding ? encoding + \"/\" : \"\";\n    if (!Platform.BufferUtils.isBuffer(data)) {\n      data = Platform.BufferUtils.utf8Encode(String(data));\n      encoding = encoding + \"utf-8/\";\n    }\n    const ciphertext = await cipher.encrypt(data);\n    msg.data = ciphertext;\n    msg.encoding = encoding + \"cipher+\" + cipher.algorithm;\n    return msg;\n  }\n  async function encode(msg, options) {\n    const data = msg.data;\n    const nativeDataType = typeof data == \"string\" || Platform.BufferUtils.isBuffer(data) || data === null || data === void 0;\n    if (!nativeDataType) {\n      if (isObject(data) || Array.isArray(data)) {\n        msg.data = JSON.stringify(data);\n        msg.encoding = msg.encoding ? msg.encoding + \"/json\" : \"json\";\n      } else {\n        throw new ErrorInfo(\"Data type is unsupported\", 40013, 400);\n      }\n    }\n    if (options != null && options.cipher) {\n      return encrypt(msg, options);\n    } else {\n      return msg;\n    }\n  }\n  async function encodeArray(messages, options) {\n    return Promise.all(messages.map(message => encode(message, options)));\n  }\n  var serialize = encodeBody;\n  async function decode(message, inputContext) {\n    const context = normaliseContext(inputContext);\n    let lastPayload = message.data;\n    const encoding = message.encoding;\n    if (encoding) {\n      const xforms = encoding.split(\"/\");\n      let lastProcessedEncodingIndex,\n        encodingsToProcess = xforms.length,\n        data = message.data;\n      let xform = \"\";\n      try {\n        while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\n          const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\n          if (!match) break;\n          xform = match[1];\n          switch (xform) {\n            case \"base64\":\n              data = Platform.BufferUtils.base64Decode(String(data));\n              if (lastProcessedEncodingIndex == xforms.length) {\n                lastPayload = data;\n              }\n              continue;\n            case \"utf-8\":\n              data = Platform.BufferUtils.utf8Decode(data);\n              continue;\n            case \"json\":\n              data = JSON.parse(data);\n              continue;\n            case \"cipher\":\n              if (context.channelOptions != null && context.channelOptions.cipher && context.channelOptions.channelCipher) {\n                const xformAlgorithm = match[3],\n                  cipher = context.channelOptions.channelCipher;\n                if (xformAlgorithm != cipher.algorithm) {\n                  throw new Error(\"Unable to decrypt message with given cipher; incompatible cipher params\");\n                }\n                data = await cipher.decrypt(data);\n                continue;\n              } else {\n                throw new Error(\"Unable to decrypt message; not an encrypted channel\");\n              }\n            case \"vcdiff\":\n              if (!context.plugins || !context.plugins.vcdiff) {\n                throw new ErrorInfo(\"Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)\", 40019, 400);\n              }\n              if (typeof Uint8Array === \"undefined\") {\n                throw new ErrorInfo(\"Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)\", 40020, 400);\n              }\n              try {\n                let deltaBase = context.baseEncodedPreviousPayload;\n                if (typeof deltaBase === \"string\") {\n                  deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\n                }\n                const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase);\n                data = Platform.BufferUtils.toBuffer(data);\n                data = Platform.BufferUtils.arrayBufferViewToBuffer(context.plugins.vcdiff.decode(data, deltaBaseBuffer));\n                lastPayload = data;\n              } catch (e) {\n                throw new ErrorInfo(\"Vcdiff delta decode failed with \" + e, 40018, 400);\n              }\n              continue;\n            default:\n              throw new Error(\"Unknown encoding\");\n          }\n        }\n      } catch (e) {\n        const err = e;\n        throw new ErrorInfo(\"Error processing the \" + xform + \" encoding, decoder returned \\u2018\" + err.message + \"\\u2019\", err.code || 40013, 400);\n      } finally {\n        message.encoding = lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join(\"/\");\n        message.data = data;\n      }\n    }\n    context.baseEncodedPreviousPayload = lastPayload;\n  }\n  async function fromResponseBody(body, options, MsgPack, format) {\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    for (let i = 0; i < body.length; i++) {\n      const msg = body[i] = fromValues(body[i]);\n      try {\n        await decode(msg, options);\n      } catch (e) {\n        logger_default.logAction(logger_default.LOG_ERROR, \"Message.fromResponseBody()\", e.toString());\n      }\n    }\n    return body;\n  }\n  function fromValues(values) {\n    return Object.assign(new Message(), values);\n  }\n  function fromValuesArray(values) {\n    const count = values.length,\n      result = new Array(count);\n    for (let i = 0; i < count; i++) result[i] = fromValues(values[i]);\n    return result;\n  }\n  function getMessagesSize(messages) {\n    let msg,\n      total = 0;\n    for (let i = 0; i < messages.length; i++) {\n      msg = messages[i];\n      total += msg.size || (msg.size = getMessageSize(msg));\n    }\n    return total;\n  }\n  var Message = class {\n    /**\n     * Overload toJSON() to intercept JSON.stringify()\n     * @return {*}\n     */\n    toJSON() {\n      let encoding = this.encoding;\n      let data = this.data;\n      if (data && Platform.BufferUtils.isBuffer(data)) {\n        if (arguments.length > 0) {\n          encoding = encoding ? encoding + \"/base64\" : \"base64\";\n          data = Platform.BufferUtils.base64Encode(data);\n        } else {\n          data = Platform.BufferUtils.toBuffer(data);\n        }\n      }\n      return {\n        name: this.name,\n        id: this.id,\n        clientId: this.clientId,\n        connectionId: this.connectionId,\n        connectionKey: this.connectionKey,\n        extras: this.extras,\n        encoding,\n        data\n      };\n    }\n    toString() {\n      let result = \"[Message\";\n      if (this.name) result += \"; name=\" + this.name;\n      if (this.id) result += \"; id=\" + this.id;\n      if (this.timestamp) result += \"; timestamp=\" + this.timestamp;\n      if (this.clientId) result += \"; clientId=\" + this.clientId;\n      if (this.connectionId) result += \"; connectionId=\" + this.connectionId;\n      if (this.encoding) result += \"; encoding=\" + this.encoding;\n      if (this.extras) result += \"; extras =\" + JSON.stringify(this.extras);\n      if (this.data) {\n        if (typeof this.data == \"string\") result += \"; data=\" + this.data;else if (Platform.BufferUtils.isBuffer(this.data)) result += \"; data (buffer)=\" + Platform.BufferUtils.base64Encode(this.data);else result += \"; data (json)=\" + JSON.stringify(this.data);\n      }\n      if (this.extras) result += \"; extras=\" + JSON.stringify(this.extras);\n      result += \"]\";\n      return result;\n    }\n  };\n  var message_default = Message;\n\n  // src/common/lib/types/presencemessage.ts\n  var actions = [\"absent\", \"present\", \"enter\", \"leave\", \"update\"];\n  function toActionValue(actionString) {\n    return actions.indexOf(actionString);\n  }\n  async function fromEncoded2(encoded, options) {\n    const msg = fromValues2(encoded, true);\n    try {\n      await decode2(msg, options != null ? options : {});\n    } catch (e) {\n      logger_default.logAction(logger_default.LOG_ERROR, \"PresenceMessage.fromEncoded()\", e.toString());\n    }\n    return msg;\n  }\n  async function fromEncodedArray2(encodedArray, options) {\n    return Promise.all(encodedArray.map(function (encoded) {\n      return fromEncoded2(encoded, options);\n    }));\n  }\n  function fromValues2(values, stringifyAction) {\n    if (stringifyAction) {\n      values.action = actions[values.action];\n    }\n    return Object.assign(new PresenceMessage(), values);\n  }\n  var decode2 = decode;\n  async function fromResponseBody2(body, options, MsgPack, format) {\n    const messages = [];\n    if (format) {\n      body = decodeBody(body, MsgPack, format);\n    }\n    for (let i = 0; i < body.length; i++) {\n      const msg = messages[i] = fromValues2(body[i], true);\n      try {\n        await decode2(msg, options);\n      } catch (e) {\n        logger_default.logAction(logger_default.LOG_ERROR, \"PresenceMessage.fromResponseBody()\", e.toString());\n      }\n    }\n    return messages;\n  }\n  function fromValuesArray2(values) {\n    const count = values.length,\n      result = new Array(count);\n    for (let i = 0; i < count; i++) result[i] = fromValues2(values[i]);\n    return result;\n  }\n  function fromData(data) {\n    if (data instanceof PresenceMessage) {\n      return data;\n    }\n    return fromValues2({\n      data\n    });\n  }\n  var PresenceMessage = class {\n    /* Returns whether this presenceMessage is synthesized, i.e. was not actually\n     * sent by the connection (usually means a leave event sent 15s after a\n     * disconnection). This is useful because synthesized messages cannot be\n     * compared for newness by id lexicographically - RTP2b1\n     */\n    isSynthesized() {\n      if (!this.id || !this.connectionId) {\n        return true;\n      }\n      return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\n    }\n    /* RTP2b2 */\n    parseId() {\n      if (!this.id) throw new Error(\"parseId(): Presence message does not contain an id\");\n      const parts = this.id.split(\":\");\n      return {\n        connectionId: parts[0],\n        msgSerial: parseInt(parts[1], 10),\n        index: parseInt(parts[2], 10)\n      };\n    }\n    /**\n     * Overload toJSON() to intercept JSON.stringify()\n     * @return {*}\n     */\n    toJSON() {\n      let data = this.data;\n      let encoding = this.encoding;\n      if (data && Platform.BufferUtils.isBuffer(data)) {\n        if (arguments.length > 0) {\n          encoding = encoding ? encoding + \"/base64\" : \"base64\";\n          data = Platform.BufferUtils.base64Encode(data);\n        } else {\n          data = Platform.BufferUtils.toBuffer(data);\n        }\n      }\n      return {\n        id: this.id,\n        clientId: this.clientId,\n        /* Convert presence action back to an int for sending to Ably */\n        action: toActionValue(this.action),\n        data,\n        encoding,\n        extras: this.extras\n      };\n    }\n    toString() {\n      let result = \"[PresenceMessage\";\n      result += \"; action=\" + this.action;\n      if (this.id) result += \"; id=\" + this.id;\n      if (this.timestamp) result += \"; timestamp=\" + this.timestamp;\n      if (this.clientId) result += \"; clientId=\" + this.clientId;\n      if (this.connectionId) result += \"; connectionId=\" + this.connectionId;\n      if (this.encoding) result += \"; encoding=\" + this.encoding;\n      if (this.data) {\n        if (typeof this.data == \"string\") result += \"; data=\" + this.data;else if (Platform.BufferUtils.isBuffer(this.data)) result += \"; data (buffer)=\" + Platform.BufferUtils.base64Encode(this.data);else result += \"; data (json)=\" + JSON.stringify(this.data);\n      }\n      if (this.extras) {\n        result += \"; extras=\" + JSON.stringify(this.extras);\n      }\n      result += \"]\";\n      return result;\n    }\n  };\n  var presencemessage_default = PresenceMessage;\n\n  // src/common/lib/client/restpresence.ts\n  var RestPresence = class {\n    constructor(channel) {\n      this.channel = channel;\n    }\n    async get(params) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"RestPresence.get()\", \"channel = \" + this.channel.name);\n      const client = this.channel.client,\n        format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        envelope = this.channel.client.http.supportsLinkHeaders ? void 0 : format,\n        headers = defaults_default.defaultGetHeaders(client.options, {\n          format\n        });\n      mixin(headers, client.options.headers);\n      const options = this.channel.channelOptions;\n      return new paginatedresource_default(client, this.channel.client.rest.presenceMixin.basePath(this), headers, envelope, async function (body, headers2, unpacked) {\n        return await fromResponseBody2(body, options, client._MsgPack, unpacked ? void 0 : format);\n      }).get(params);\n    }\n    async history(params) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"RestPresence.history()\", \"channel = \" + this.channel.name);\n      return this.channel.client.rest.presenceMixin.history(this, params);\n    }\n  };\n  var restpresence_default = RestPresence;\n\n  // src/common/lib/client/restchannel.ts\n  var MSG_ID_ENTROPY_BYTES = 9;\n  function allEmptyIds(messages) {\n    return messages.every(function (message) {\n      return !message.id;\n    });\n  }\n  var RestChannel = class {\n    constructor(client, name, channelOptions) {\n      var _a2;\n      logger_default.logAction(logger_default.LOG_MINOR, \"RestChannel()\", \"started; name = \" + name);\n      this.name = name;\n      this.client = client;\n      this.presence = new restpresence_default(this);\n      this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, channelOptions);\n    }\n    setOptions(options) {\n      var _a2;\n      this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, options);\n    }\n    async history(params) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"RestChannel.history()\", \"channel = \" + this.name);\n      return this.client.rest.channelMixin.history(this, params);\n    }\n    async publish(...args) {\n      const first = args[0],\n        second = args[1];\n      let messages;\n      let params;\n      if (typeof first === \"string\" || first === null) {\n        messages = [fromValues({\n          name: first,\n          data: second\n        })];\n        params = args[2];\n      } else if (isObject(first)) {\n        messages = [fromValues(first)];\n        params = args[1];\n      } else if (Array.isArray(first)) {\n        messages = fromValuesArray(first);\n        params = args[1];\n      } else {\n        throw new ErrorInfo(\"The single-argument form of publish() expects a message object or an array of message objects\", 40013, 400);\n      }\n      if (!params) {\n        params = {};\n      }\n      const client = this.client,\n        options = client.options,\n        format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        idempotentRestPublishing = client.options.idempotentRestPublishing,\n        headers = defaults_default.defaultPostHeaders(client.options, {\n          format\n        });\n      mixin(headers, options.headers);\n      if (idempotentRestPublishing && allEmptyIds(messages)) {\n        const msgIdBase = await randomString(MSG_ID_ENTROPY_BYTES);\n        messages.forEach(function (message, index) {\n          message.id = msgIdBase + \":\" + index.toString();\n        });\n      }\n      await encodeArray(messages, this.channelOptions);\n      const size = getMessagesSize(messages),\n        maxMessageSize = options.maxMessageSize;\n      if (size > maxMessageSize) {\n        throw new ErrorInfo(\"Maximum size of messages that can be published at once exceeded ( was \" + size + \" bytes; limit is \" + maxMessageSize + \" bytes)\", 40009, 400);\n      }\n      await this._publish(serialize(messages, client._MsgPack, format), headers, params);\n    }\n    async _publish(requestBody, headers, params) {\n      await resource_default.post(this.client, this.client.rest.channelMixin.basePath(this) + \"/messages\", requestBody, headers, params, null, true);\n    }\n    async status() {\n      return this.client.rest.channelMixin.status(this);\n    }\n  };\n  var restchannel_default = RestChannel;\n\n  // src/common/lib/types/stats.ts\n  var Stats = class _Stats {\n    constructor(values) {\n      this.entries = values && values.entries || void 0;\n      this.schema = values && values.schema || void 0;\n      this.appId = values && values.appId || void 0;\n      this.inProgress = values && values.inProgress || void 0;\n      this.unit = values && values.unit || void 0;\n      this.intervalId = values && values.intervalId || void 0;\n    }\n    static fromValues(values) {\n      return new _Stats(values);\n    }\n  };\n  var stats_default = Stats;\n\n  // src/common/lib/client/restchannelmixin.ts\n  var RestChannelMixin = class {\n    static basePath(channel) {\n      return \"/channels/\" + encodeURIComponent(channel.name);\n    }\n    static history(channel, params) {\n      const client = channel.client,\n        format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        envelope = channel.client.http.supportsLinkHeaders ? void 0 : format,\n        headers = defaults_default.defaultGetHeaders(client.options, {\n          format\n        });\n      mixin(headers, client.options.headers);\n      const options = channel.channelOptions;\n      return new paginatedresource_default(client, this.basePath(channel) + \"/messages\", headers, envelope, async function (body, headers2, unpacked) {\n        return await fromResponseBody(body, options, client._MsgPack, unpacked ? void 0 : format);\n      }).get(params);\n    }\n    static async status(channel) {\n      const format = channel.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n      const headers = defaults_default.defaultPostHeaders(channel.client.options, {\n        format\n      });\n      const response = await resource_default.get(channel.client, this.basePath(channel), headers, {}, format, true);\n      return response.body;\n    }\n  };\n\n  // src/common/lib/client/restpresencemixin.ts\n  var RestPresenceMixin = class {\n    static basePath(presence) {\n      return RestChannelMixin.basePath(presence.channel) + \"/presence\";\n    }\n    static async history(presence, params) {\n      const client = presence.channel.client,\n        format = client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        envelope = presence.channel.client.http.supportsLinkHeaders ? void 0 : format,\n        headers = defaults_default.defaultGetHeaders(client.options, {\n          format\n        });\n      mixin(headers, client.options.headers);\n      const options = presence.channel.channelOptions;\n      return new paginatedresource_default(client, this.basePath(presence) + \"/history\", headers, envelope, async function (body, headers2, unpacked) {\n        return await fromResponseBody2(body, options, client._MsgPack, unpacked ? void 0 : format);\n      }).get(params);\n    }\n  };\n\n  // src/common/lib/client/rest.ts\n  var Rest = class {\n    constructor(client) {\n      this.channelMixin = RestChannelMixin;\n      this.presenceMixin = RestPresenceMixin;\n      this.client = client;\n      this.channels = new Channels(this.client);\n      this.push = new push_default(this.client);\n    }\n    async stats(params) {\n      const headers = defaults_default.defaultGetHeaders(this.client.options),\n        format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n      mixin(headers, this.client.options.headers);\n      return new paginatedresource_default(this.client, \"/stats\", headers, envelope, function (body, headers2, unpacked) {\n        const statsValues = unpacked ? body : JSON.parse(body);\n        for (let i = 0; i < statsValues.length; i++) statsValues[i] = stats_default.fromValues(statsValues[i]);\n        return statsValues;\n      }).get(params);\n    }\n    async time(params) {\n      const headers = defaults_default.defaultGetHeaders(this.client.options);\n      if (this.client.options.headers) mixin(headers, this.client.options.headers);\n      const timeUri = host => {\n        return this.client.baseUri(host) + \"/time\";\n      };\n      let {\n        error,\n        body,\n        unpacked\n      } = await this.client.http.do(HttpMethods_default.Get, timeUri, headers, null, params);\n      if (error) {\n        throw error;\n      }\n      if (!unpacked) body = JSON.parse(body);\n      const time = body[0];\n      if (!time) {\n        throw new ErrorInfo(\"Internal error (unexpected result type from GET /time)\", 5e4, 500);\n      }\n      this.client.serverTimeOffset = time - Date.now();\n      return time;\n    }\n    async request(method, path, version2, params, body, customHeaders) {\n      var _a2;\n      const [encoder, decoder, format] = (() => {\n        if (this.client.options.useBinaryProtocol) {\n          if (!this.client._MsgPack) {\n            throwMissingPluginError(\"MsgPack\");\n          }\n          return [this.client._MsgPack.encode, this.client._MsgPack.decode, \"msgpack\" /* msgpack */];\n        } else {\n          return [JSON.stringify, JSON.parse, \"json\" /* json */];\n        }\n      })();\n      const envelope = this.client.http.supportsLinkHeaders ? void 0 : format;\n      params = params || {};\n      const _method = method.toLowerCase();\n      const headers = _method == \"get\" ? defaults_default.defaultGetHeaders(this.client.options, {\n        format,\n        protocolVersion: version2\n      }) : defaults_default.defaultPostHeaders(this.client.options, {\n        format,\n        protocolVersion: version2\n      });\n      if (typeof body !== \"string\") {\n        body = (_a2 = encoder(body)) != null ? _a2 : null;\n      }\n      mixin(headers, this.client.options.headers);\n      if (customHeaders) {\n        mixin(headers, customHeaders);\n      }\n      const paginatedResource = new paginatedresource_default(this.client, path, headers, envelope, async function (resbody, headers2, unpacked) {\n        return ensureArray(unpacked ? resbody : decoder(resbody));\n      }, /* useHttpPaginatedResponse: */\n      true);\n      if (!Platform.Http.methods.includes(_method)) {\n        throw new ErrorInfo(\"Unsupported method \" + _method, 40500, 405);\n      }\n      if (Platform.Http.methodsWithBody.includes(_method)) {\n        return paginatedResource[_method](params, body);\n      } else {\n        return paginatedResource[_method](params);\n      }\n    }\n    async batchPublish(specOrSpecs) {\n      let requestBodyDTO;\n      let singleSpecMode;\n      if (Array.isArray(specOrSpecs)) {\n        requestBodyDTO = specOrSpecs;\n        singleSpecMode = false;\n      } else {\n        requestBodyDTO = [specOrSpecs];\n        singleSpecMode = true;\n      }\n      const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        headers = defaults_default.defaultPostHeaders(this.client.options, {\n          format\n        });\n      if (this.client.options.headers) mixin(headers, this.client.options.headers);\n      const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n      const response = await resource_default.post(this.client, \"/messages\", requestBody, headers, {}, null, true);\n      const batchResults = response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n      if (singleSpecMode) {\n        return batchResults[0];\n      } else {\n        return batchResults;\n      }\n    }\n    async batchPresence(channels) {\n      const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        headers = defaults_default.defaultPostHeaders(this.client.options, {\n          format\n        });\n      if (this.client.options.headers) mixin(headers, this.client.options.headers);\n      const channelsParam = channels.join(\",\");\n      const response = await resource_default.get(this.client, \"/presence\", headers, {\n        channels: channelsParam\n      }, null, true);\n      return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n    }\n    async revokeTokens(specifiers, options) {\n      if (useTokenAuth(this.client.options)) {\n        throw new ErrorInfo(\"Cannot revoke tokens when using token auth\", 40162, 401);\n      }\n      const keyName = this.client.options.keyName;\n      let resolvedOptions = options != null ? options : {};\n      const requestBodyDTO = __spreadValues({\n        targets: specifiers.map(specifier => `${specifier.type}:${specifier.value}`)\n      }, resolvedOptions);\n      const format = this.client.options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */,\n        headers = defaults_default.defaultPostHeaders(this.client.options, {\n          format\n        });\n      if (this.client.options.headers) mixin(headers, this.client.options.headers);\n      const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);\n      const response = await resource_default.post(this.client, `/keys/${keyName}/revokeTokens`, requestBody, headers, {}, null, true);\n      return response.unpacked ? response.body : decodeBody(response.body, this.client._MsgPack, format);\n    }\n    setLog(logOptions) {\n      logger_default.setLog(logOptions.level, logOptions.handler);\n    }\n  };\n  var Channels = class {\n    constructor(client) {\n      this.client = client;\n      this.all = /* @__PURE__ */Object.create(null);\n    }\n    get(name, channelOptions) {\n      name = String(name);\n      let channel = this.all[name];\n      if (!channel) {\n        this.all[name] = channel = new restchannel_default(this.client, name, channelOptions);\n      } else if (channelOptions) {\n        channel.setOptions(channelOptions);\n      }\n      return channel;\n    }\n    /* Included to support certain niche use-cases; most users should ignore this.\n     * Please do not use this unless you know what you're doing */\n    release(name) {\n      delete this.all[String(name)];\n    }\n  };\n\n  // src/common/lib/client/baserest.ts\n  var BaseRest = class extends baseclient_default {\n    /*\n     * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n     *\n     * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\n     * 2. passes no argument at all\n     *\n     * tell the compiler that these cases are possible so that it forces us to handle them.\n     */\n    constructor(options) {\n      super(defaults_default.objectifyOptions(options, false, \"BaseRest\", {\n        Rest\n      }));\n    }\n  };\n\n  // src/common/lib/client/modularplugins.ts\n  var allCommonModularPlugins = {\n    Rest\n  };\n\n  // src/common/lib/types/defaultmessage.ts\n  var DefaultMessage = class extends message_default {\n    static async fromEncoded(encoded, inputOptions) {\n      return fromEncoded(Platform.Crypto, encoded, inputOptions);\n    }\n    static async fromEncodedArray(encodedArray, options) {\n      return fromEncodedArray(Platform.Crypto, encodedArray, options);\n    }\n    // Used by tests\n    static fromValues(values) {\n      return Object.assign(new message_default(), values);\n    }\n    // Used by tests\n    static async encode(msg, options) {\n      return encode(msg, options);\n    }\n    // Used by tests\n    static async decode(message, inputContext) {\n      return decode(message, inputContext);\n    }\n  };\n\n  // src/common/lib/types/defaultpresencemessage.ts\n  var DefaultPresenceMessage = class extends presencemessage_default {\n    static async fromEncoded(encoded, inputOptions) {\n      return fromEncoded2(encoded, inputOptions);\n    }\n    static async fromEncodedArray(encodedArray, options) {\n      return fromEncodedArray2(encodedArray, options);\n    }\n    static fromValues(values, stringifyAction) {\n      return fromValues2(values, stringifyAction);\n    }\n  };\n\n  // src/common/lib/client/defaultrest.ts\n  var _DefaultRest = class _DefaultRest extends BaseRest {\n    // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n    constructor(options) {\n      var _a2, _b;\n      const MsgPack = _DefaultRest._MsgPack;\n      if (!MsgPack) {\n        throw new Error(\"Expected DefaultRest._MsgPack to have been set\");\n      }\n      super(defaults_default.objectifyOptions(options, true, \"Rest\", __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRest.Crypto) != null ? _a2 : void 0,\n        MsgPack: (_b = _DefaultRest._MsgPack) != null ? _b : void 0\n      })));\n    }\n    static get Crypto() {\n      if (this._Crypto === null) {\n        throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n      }\n      return this._Crypto;\n    }\n    static set Crypto(newValue) {\n      this._Crypto = newValue;\n    }\n  };\n  _DefaultRest._Crypto = null;\n  _DefaultRest.Message = DefaultMessage;\n  _DefaultRest.PresenceMessage = DefaultPresenceMessage;\n  _DefaultRest._MsgPack = null;\n  // Used by tests\n  _DefaultRest._Http = Http;\n  var DefaultRest = _DefaultRest;\n\n  // src/common/lib/util/eventemitter.ts\n  function callListener(eventThis, listener, args) {\n    try {\n      listener.apply(eventThis, args);\n    } catch (e) {\n      logger_default.logAction(logger_default.LOG_ERROR, \"EventEmitter.emit()\", \"Unexpected listener exception: \" + e + \"; stack = \" + (e && e.stack));\n    }\n  }\n  function removeListener(targetListeners, listener, eventFilter) {\n    let listeners;\n    let index;\n    let eventName;\n    for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\n      listeners = targetListeners[targetListenersIndex];\n      if (eventFilter) {\n        listeners = listeners[eventFilter];\n      }\n      if (Array.isArray(listeners)) {\n        while ((index = listeners.indexOf(listener)) !== -1) {\n          listeners.splice(index, 1);\n        }\n        if (eventFilter && listeners.length === 0) {\n          delete targetListeners[targetListenersIndex][eventFilter];\n        }\n      } else if (isObject(listeners)) {\n        for (eventName in listeners) {\n          if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Array.isArray(listeners[eventName])) {\n            removeListener([listeners], listener, eventName);\n          }\n        }\n      }\n    }\n  }\n  var EventEmitter = class {\n    constructor() {\n      this.any = [];\n      this.events = /* @__PURE__ */Object.create(null);\n      this.anyOnce = [];\n      this.eventsOnce = /* @__PURE__ */Object.create(null);\n    }\n    on(...args) {\n      if (args.length === 1) {\n        const listener = args[0];\n        if (typeof listener === \"function\") {\n          this.any.push(listener);\n        } else {\n          throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n        }\n      }\n      if (args.length === 2) {\n        const [event, listener] = args;\n        if (typeof listener !== \"function\") {\n          throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n        }\n        if (isNil(event)) {\n          this.any.push(listener);\n        } else if (Array.isArray(event)) {\n          event.forEach(eventName => {\n            this.on(eventName, listener);\n          });\n        } else {\n          if (typeof event !== \"string\") {\n            throw new Error(\"EventListener.on(): Invalid arguments: \" + Platform.Config.inspect(args));\n          }\n          const listeners = this.events[event] || (this.events[event] = []);\n          listeners.push(listener);\n        }\n      }\n    }\n    off(...args) {\n      if (args.length == 0 || isNil(args[0]) && isNil(args[1])) {\n        this.any = [];\n        this.events = /* @__PURE__ */Object.create(null);\n        this.anyOnce = [];\n        this.eventsOnce = /* @__PURE__ */Object.create(null);\n        return;\n      }\n      const [firstArg, secondArg] = args;\n      let listener = null;\n      let event = null;\n      if (args.length === 1 || !secondArg) {\n        if (typeof firstArg === \"function\") {\n          listener = firstArg;\n        } else {\n          event = firstArg;\n        }\n      } else {\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        [event, listener] = [firstArg, secondArg];\n      }\n      if (listener && isNil(event)) {\n        removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\n        return;\n      }\n      if (Array.isArray(event)) {\n        event.forEach(eventName => {\n          this.off(eventName, listener);\n        });\n        return;\n      }\n      if (typeof event !== \"string\") {\n        throw new Error(\"EventEmitter.off(): invalid arguments:\" + Platform.Config.inspect(args));\n      }\n      if (listener) {\n        removeListener([this.events, this.eventsOnce], listener, event);\n      } else {\n        delete this.events[event];\n        delete this.eventsOnce[event];\n      }\n    }\n    /**\n     * Get the array of listeners for a given event; excludes once events\n     * @param event (optional) the name of the event, or none for 'any'\n     * @return array of events, or null if none\n     */\n    listeners(event) {\n      if (event) {\n        const listeners = this.events[event] || [];\n        if (this.eventsOnce[event]) Array.prototype.push.apply(listeners, this.eventsOnce[event]);\n        return listeners.length ? listeners : null;\n      }\n      return this.any.length ? this.any : null;\n    }\n    /**\n     * Emit an event\n     * @param event the event name\n     * @param args the arguments to pass to the listener\n     */\n    emit(event, ...args) {\n      const eventThis = {\n        event\n      };\n      const listeners = [];\n      if (this.anyOnce.length) {\n        Array.prototype.push.apply(listeners, this.anyOnce);\n        this.anyOnce = [];\n      }\n      if (this.any.length) {\n        Array.prototype.push.apply(listeners, this.any);\n      }\n      const eventsOnceListeners = this.eventsOnce[event];\n      if (eventsOnceListeners) {\n        Array.prototype.push.apply(listeners, eventsOnceListeners);\n        delete this.eventsOnce[event];\n      }\n      const eventsListeners = this.events[event];\n      if (eventsListeners) {\n        Array.prototype.push.apply(listeners, eventsListeners);\n      }\n      listeners.forEach(function (listener) {\n        callListener(eventThis, listener, args);\n      });\n    }\n    once(...args) {\n      const argCount = args.length;\n      if (argCount === 0 || argCount === 1 && typeof args[0] !== \"function\") {\n        const event = args[0];\n        return new Promise(resolve => {\n          this.once(event, resolve);\n        });\n      }\n      const [firstArg, secondArg] = args;\n      if (args.length === 1 && typeof firstArg === \"function\") {\n        this.anyOnce.push(firstArg);\n      } else if (isNil(firstArg)) {\n        if (typeof secondArg !== \"function\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        this.anyOnce.push(secondArg);\n      } else if (Array.isArray(firstArg)) {\n        const self2 = this;\n        const listenerWrapper = function () {\n          const innerArgs = Array.prototype.slice.call(arguments);\n          firstArg.forEach(function (eventName) {\n            self2.off(eventName, listenerWrapper);\n          });\n          if (typeof secondArg !== \"function\") {\n            throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n          }\n          secondArg.apply(this, innerArgs);\n        };\n        firstArg.forEach(function (eventName) {\n          self2.on(eventName, listenerWrapper);\n        });\n      } else {\n        if (typeof firstArg !== \"string\") {\n          throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n        }\n        const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\n        if (secondArg) {\n          if (typeof secondArg !== \"function\") {\n            throw new Error(\"EventEmitter.once(): Invalid arguments:\" + Platform.Config.inspect(args));\n          }\n          listeners.push(secondArg);\n        }\n      }\n    }\n    /**\n     * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\n     * @param targetState the name of the state event to listen to\n     * @param currentState the name of the current state of this object\n     */\n    async whenState(targetState, currentState) {\n      if (typeof targetState !== \"string\" || typeof currentState !== \"string\") {\n        throw new Error(\"whenState requires a valid state String argument\");\n      }\n      if (targetState === currentState) {\n        return null;\n      } else {\n        return this.once(targetState);\n      }\n    }\n  };\n  var eventemitter_default = EventEmitter;\n\n  // src/common/lib/types/protocolmessage.ts\n  var actions2 = {\n    HEARTBEAT: 0,\n    ACK: 1,\n    NACK: 2,\n    CONNECT: 3,\n    CONNECTED: 4,\n    DISCONNECT: 5,\n    DISCONNECTED: 6,\n    CLOSE: 7,\n    CLOSED: 8,\n    ERROR: 9,\n    ATTACH: 10,\n    ATTACHED: 11,\n    DETACH: 12,\n    DETACHED: 13,\n    PRESENCE: 14,\n    MESSAGE: 15,\n    SYNC: 16,\n    AUTH: 17,\n    ACTIVATE: 18\n  };\n  var ActionName = [];\n  Object.keys(actions2).forEach(function (name) {\n    ActionName[actions2[name]] = name;\n  });\n  var flags = {\n    /* Channel attach state flags */\n    HAS_PRESENCE: 1 << 0,\n    HAS_BACKLOG: 1 << 1,\n    RESUMED: 1 << 2,\n    TRANSIENT: 1 << 4,\n    ATTACH_RESUME: 1 << 5,\n    /* Channel mode flags */\n    PRESENCE: 1 << 16,\n    PUBLISH: 1 << 17,\n    SUBSCRIBE: 1 << 18,\n    PRESENCE_SUBSCRIBE: 1 << 19\n  };\n  var flagNames = Object.keys(flags);\n  flags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;\n  function toStringArray(array) {\n    const result = [];\n    if (array) {\n      for (let i = 0; i < array.length; i++) {\n        result.push(array[i].toString());\n      }\n    }\n    return \"[ \" + result.join(\", \") + \" ]\";\n  }\n  var channelModes = [\"PRESENCE\", \"PUBLISH\", \"SUBSCRIBE\", \"PRESENCE_SUBSCRIBE\"];\n  var serialize2 = encodeBody;\n  function deserialize(serialized, MsgPack, presenceMessagePlugin, format) {\n    const deserialized = decodeBody(serialized, MsgPack, format);\n    return fromDeserialized(deserialized, presenceMessagePlugin);\n  }\n  function fromDeserialized(deserialized, presenceMessagePlugin) {\n    const error = deserialized.error;\n    if (error) deserialized.error = ErrorInfo.fromValues(error);\n    const messages = deserialized.messages;\n    if (messages) for (let i = 0; i < messages.length; i++) messages[i] = fromValues(messages[i]);\n    const presence = presenceMessagePlugin ? deserialized.presence : void 0;\n    if (presenceMessagePlugin) {\n      if (presence && presenceMessagePlugin) for (let i = 0; i < presence.length; i++) presence[i] = presenceMessagePlugin.presenceMessageFromValues(presence[i], true);\n    }\n    return Object.assign(new ProtocolMessage(), __spreadProps(__spreadValues({}, deserialized), {\n      presence\n    }));\n  }\n  function fromDeserializedIncludingDependencies(deserialized) {\n    return fromDeserialized(deserialized, {\n      presenceMessageFromValues: fromValues2,\n      presenceMessagesFromValuesArray: fromValuesArray2\n    });\n  }\n  function fromValues3(values) {\n    return Object.assign(new ProtocolMessage(), values);\n  }\n  function stringify(msg, presenceMessagePlugin) {\n    let result = \"[ProtocolMessage\";\n    if (msg.action !== void 0) result += \"; action=\" + ActionName[msg.action] || msg.action;\n    const simpleAttributes = [\"id\", \"channel\", \"channelSerial\", \"connectionId\", \"count\", \"msgSerial\", \"timestamp\"];\n    let attribute;\n    for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\n      attribute = simpleAttributes[attribIndex];\n      if (msg[attribute] !== void 0) result += \"; \" + attribute + \"=\" + msg[attribute];\n    }\n    if (msg.messages) result += \"; messages=\" + toStringArray(fromValuesArray(msg.messages));\n    if (msg.presence && presenceMessagePlugin) result += \"; presence=\" + toStringArray(presenceMessagePlugin.presenceMessagesFromValuesArray(msg.presence));\n    if (msg.error) result += \"; error=\" + ErrorInfo.fromValues(msg.error).toString();\n    if (msg.auth && msg.auth.accessToken) result += \"; token=\" + msg.auth.accessToken;\n    if (msg.flags) result += \"; flags=\" + flagNames.filter(msg.hasFlag).join(\",\");\n    if (msg.params) {\n      let stringifiedParams = \"\";\n      forInOwnNonNullProperties(msg.params, function (prop) {\n        if (stringifiedParams.length > 0) {\n          stringifiedParams += \"; \";\n        }\n        stringifiedParams += prop + \"=\" + msg.params[prop];\n      });\n      if (stringifiedParams.length > 0) {\n        result += \"; params=[\" + stringifiedParams + \"]\";\n      }\n    }\n    result += \"]\";\n    return result;\n  }\n  var ProtocolMessage = class {\n    constructor() {\n      this.hasFlag = flag => {\n        return (this.flags & flags[flag]) > 0;\n      };\n    }\n    setFlag(flag) {\n      return this.flags = this.flags | flags[flag];\n    }\n    getMode() {\n      return this.flags && this.flags & flags.MODE_ALL;\n    }\n    encodeModesToFlags(modes) {\n      modes.forEach(mode => this.setFlag(mode));\n    }\n    decodeModesFromFlags() {\n      const modes = [];\n      channelModes.forEach(mode => {\n        if (this.hasFlag(mode)) {\n          modes.push(mode);\n        }\n      });\n      return modes.length > 0 ? modes : void 0;\n    }\n  };\n  var protocolmessage_default = ProtocolMessage;\n\n  // src/common/lib/transport/messagequeue.ts\n  var MessageQueue = class extends eventemitter_default {\n    constructor() {\n      super();\n      this.messages = [];\n    }\n    count() {\n      return this.messages.length;\n    }\n    push(message) {\n      this.messages.push(message);\n    }\n    shift() {\n      return this.messages.shift();\n    }\n    last() {\n      return this.messages[this.messages.length - 1];\n    }\n    copyAll() {\n      return this.messages.slice();\n    }\n    append(messages) {\n      this.messages.push.apply(this.messages, messages);\n    }\n    prepend(messages) {\n      this.messages.unshift.apply(this.messages, messages);\n    }\n    completeMessages(serial, count, err) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"MessageQueue.completeMessages()\", \"serial = \" + serial + \"; count = \" + count);\n      err = err || null;\n      const messages = this.messages;\n      if (messages.length === 0) {\n        throw new Error(\"MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue\");\n      }\n      const first = messages[0];\n      if (first) {\n        const startSerial = first.message.msgSerial;\n        const endSerial = serial + count;\n        if (endSerial > startSerial) {\n          const completeMessages = messages.splice(0, endSerial - startSerial);\n          for (const message of completeMessages) {\n            message.callback(err);\n          }\n        }\n        if (messages.length == 0) this.emit(\"idle\");\n      }\n    }\n    completeAllMessages(err) {\n      this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);\n    }\n    resetSendAttempted() {\n      for (let msg of this.messages) {\n        msg.sendAttempted = false;\n      }\n    }\n    clear() {\n      logger_default.logAction(logger_default.LOG_MICRO, \"MessageQueue.clear()\", \"clearing \" + this.messages.length + \" messages\");\n      this.messages = [];\n      this.emit(\"idle\");\n    }\n  };\n  var messagequeue_default = MessageQueue;\n\n  // src/common/lib/transport/protocol.ts\n  var PendingMessage = class {\n    constructor(message, callback) {\n      this.message = message;\n      this.callback = callback;\n      this.merged = false;\n      const action = message.action;\n      this.sendAttempted = false;\n      this.ackRequired = action == actions2.MESSAGE || action == actions2.PRESENCE;\n    }\n  };\n  var Protocol = class extends eventemitter_default {\n    constructor(transport) {\n      super();\n      this.transport = transport;\n      this.messageQueue = new messagequeue_default();\n      transport.on(\"ack\", (serial, count) => {\n        this.onAck(serial, count);\n      });\n      transport.on(\"nack\", (serial, count, err) => {\n        this.onNack(serial, count, err);\n      });\n    }\n    onAck(serial, count) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"Protocol.onAck()\", \"serial = \" + serial + \"; count = \" + count);\n      this.messageQueue.completeMessages(serial, count);\n    }\n    onNack(serial, count, err) {\n      logger_default.logAction(logger_default.LOG_ERROR, \"Protocol.onNack()\", \"serial = \" + serial + \"; count = \" + count + \"; err = \" + inspectError(err));\n      if (!err) {\n        err = new ErrorInfo(\"Unable to send message; channel not responding\", 50001, 500);\n      }\n      this.messageQueue.completeMessages(serial, count, err);\n    }\n    onceIdle(listener) {\n      const messageQueue = this.messageQueue;\n      if (messageQueue.count() === 0) {\n        listener();\n        return;\n      }\n      messageQueue.once(\"idle\", listener);\n    }\n    send(pendingMessage) {\n      if (pendingMessage.ackRequired) {\n        this.messageQueue.push(pendingMessage);\n      }\n      if (logger_default.shouldLog(logger_default.LOG_MICRO)) {\n        logger_default.logActionNoStrip(logger_default.LOG_MICRO, \"Protocol.send()\", \"sending msg; \" + stringify(pendingMessage.message, this.transport.connectionManager.realtime._RealtimePresence));\n      }\n      pendingMessage.sendAttempted = true;\n      this.transport.send(pendingMessage.message);\n    }\n    getTransport() {\n      return this.transport;\n    }\n    getPendingMessages() {\n      return this.messageQueue.copyAll();\n    }\n    clearPendingMessages() {\n      return this.messageQueue.clear();\n    }\n    finish() {\n      const transport = this.transport;\n      this.onceIdle(function () {\n        transport.disconnect();\n      });\n    }\n  };\n  var protocol_default = Protocol;\n\n  // src/common/lib/client/connectionstatechange.ts\n  var ConnectionStateChange = class {\n    constructor(previous, current, retryIn, reason) {\n      this.previous = previous;\n      this.current = current;\n      if (retryIn) this.retryIn = retryIn;\n      if (reason) this.reason = reason;\n    }\n  };\n  var connectionstatechange_default = ConnectionStateChange;\n\n  // src/common/lib/transport/connectionerrors.ts\n  var ConnectionErrorCodes = {\n    DISCONNECTED: 80003,\n    SUSPENDED: 80002,\n    FAILED: 8e4,\n    CLOSING: 80017,\n    CLOSED: 80017,\n    UNKNOWN_CONNECTION_ERR: 50002,\n    UNKNOWN_CHANNEL_ERR: 50001\n  };\n  var ConnectionErrors = {\n    disconnected: () => ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.DISCONNECTED,\n      message: \"Connection to server temporarily unavailable\"\n    }),\n    suspended: () => ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.SUSPENDED,\n      message: \"Connection to server unavailable\"\n    }),\n    failed: () => ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.FAILED,\n      message: \"Connection failed or disconnected by server\"\n    }),\n    closing: () => ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.CLOSING,\n      message: \"Connection closing\"\n    }),\n    closed: () => ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.CLOSED,\n      message: \"Connection closed\"\n    }),\n    unknownConnectionErr: () => ErrorInfo.fromValues({\n      statusCode: 500,\n      code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n      message: \"Internal connection error\"\n    }),\n    unknownChannelErr: () => ErrorInfo.fromValues({\n      statusCode: 500,\n      code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n      message: \"Internal channel error\"\n    })\n  };\n  function isRetriable(err) {\n    if (!err.statusCode || !err.code || err.statusCode >= 500) {\n      return true;\n    }\n    return Object.values(ConnectionErrorCodes).includes(err.code);\n  }\n  var connectionerrors_default = ConnectionErrors;\n\n  // src/common/lib/transport/transport.ts\n  var closeMessage = fromValues3({\n    action: actions2.CLOSE\n  });\n  var disconnectMessage = fromValues3({\n    action: actions2.DISCONNECT\n  });\n  var Transport = class extends eventemitter_default {\n    constructor(connectionManager, auth, params, forceJsonProtocol) {\n      super();\n      if (forceJsonProtocol) {\n        params.format = void 0;\n        params.heartbeats = true;\n      }\n      this.connectionManager = connectionManager;\n      this.auth = auth;\n      this.params = params;\n      this.timeouts = params.options.timeouts;\n      this.format = params.format;\n      this.isConnected = false;\n      this.isFinished = false;\n      this.isDisposed = false;\n      this.maxIdleInterval = null;\n      this.idleTimer = null;\n      this.lastActivity = null;\n    }\n    connect() {}\n    close() {\n      if (this.isConnected) {\n        this.requestClose();\n      }\n      this.finish(\"closed\", connectionerrors_default.closed());\n    }\n    disconnect(err) {\n      if (this.isConnected) {\n        this.requestDisconnect();\n      }\n      this.finish(\"disconnected\", err || connectionerrors_default.disconnected());\n    }\n    fail(err) {\n      if (this.isConnected) {\n        this.requestDisconnect();\n      }\n      this.finish(\"failed\", err || connectionerrors_default.failed());\n    }\n    finish(event, err) {\n      var _a2;\n      if (this.isFinished) {\n        return;\n      }\n      this.isFinished = true;\n      this.isConnected = false;\n      this.maxIdleInterval = null;\n      clearTimeout((_a2 = this.idleTimer) != null ? _a2 : void 0);\n      this.idleTimer = null;\n      this.emit(event, err);\n      this.dispose();\n    }\n    onProtocolMessage(message) {\n      if (logger_default.shouldLog(logger_default.LOG_MICRO)) {\n        logger_default.logActionNoStrip(logger_default.LOG_MICRO, \"Transport.onProtocolMessage()\", \"received on \" + this.shortName + \": \" + stringify(message, this.connectionManager.realtime._RealtimePresence) + \"; connectionId = \" + this.connectionManager.connectionId);\n      }\n      this.onActivity();\n      switch (message.action) {\n        case actions2.HEARTBEAT:\n          logger_default.logActionNoStrip(logger_default.LOG_MICRO, \"Transport.onProtocolMessage()\", this.shortName + \" heartbeat; connectionId = \" + this.connectionManager.connectionId);\n          this.emit(\"heartbeat\", message.id);\n          break;\n        case actions2.CONNECTED:\n          this.onConnect(message);\n          this.emit(\"connected\", message.error, message.connectionId, message.connectionDetails, message);\n          break;\n        case actions2.CLOSED:\n          this.onClose(message);\n          break;\n        case actions2.DISCONNECTED:\n          this.onDisconnect(message);\n          break;\n        case actions2.ACK:\n          this.emit(\"ack\", message.msgSerial, message.count);\n          break;\n        case actions2.NACK:\n          this.emit(\"nack\", message.msgSerial, message.count, message.error);\n          break;\n        case actions2.SYNC:\n          this.connectionManager.onChannelMessage(message, this);\n          break;\n        case actions2.ACTIVATE:\n          break;\n        case actions2.AUTH:\n          whenPromiseSettles(this.auth.authorize(), function (err) {\n            if (err) {\n              logger_default.logAction(logger_default.LOG_ERROR, \"Transport.onProtocolMessage()\", \"Ably requested re-authentication, but unable to obtain a new token: \" + inspectError(err));\n            }\n          });\n          break;\n        case actions2.ERROR:\n          logger_default.logAction(logger_default.LOG_MINOR, \"Transport.onProtocolMessage()\", \"received error action; connectionId = \" + this.connectionManager.connectionId + \"; err = \" + Platform.Config.inspect(message.error) + (message.channel ? \", channel: \" + message.channel : \"\"));\n          if (message.channel === void 0) {\n            this.onFatalError(message);\n            break;\n          }\n          this.connectionManager.onChannelMessage(message, this);\n          break;\n        default:\n          this.connectionManager.onChannelMessage(message, this);\n      }\n    }\n    onConnect(message) {\n      this.isConnected = true;\n      if (!message.connectionDetails) {\n        throw new Error(\"Transport.onConnect(): Connect message recieved without connectionDetails\");\n      }\n      const maxPromisedIdle = message.connectionDetails.maxIdleInterval;\n      if (maxPromisedIdle) {\n        this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\n        this.onActivity();\n      }\n    }\n    onDisconnect(message) {\n      const err = message && message.error;\n      logger_default.logAction(logger_default.LOG_MINOR, \"Transport.onDisconnect()\", \"err = \" + inspectError(err));\n      this.finish(\"disconnected\", err);\n    }\n    onFatalError(message) {\n      const err = message && message.error;\n      logger_default.logAction(logger_default.LOG_MINOR, \"Transport.onFatalError()\", \"err = \" + inspectError(err));\n      this.finish(\"failed\", err);\n    }\n    onClose(message) {\n      const err = message && message.error;\n      logger_default.logAction(logger_default.LOG_MINOR, \"Transport.onClose()\", \"err = \" + inspectError(err));\n      this.finish(\"closed\", err);\n    }\n    requestClose() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"Transport.requestClose()\", \"\");\n      this.send(closeMessage);\n    }\n    requestDisconnect() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"Transport.requestDisconnect()\", \"\");\n      this.send(disconnectMessage);\n    }\n    ping(id) {\n      const msg = {\n        action: actions2.HEARTBEAT\n      };\n      if (id) msg.id = id;\n      this.send(fromValues3(msg));\n    }\n    dispose() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"Transport.dispose()\", \"\");\n      this.isDisposed = true;\n      this.off();\n    }\n    onActivity() {\n      if (!this.maxIdleInterval) {\n        return;\n      }\n      this.lastActivity = this.connectionManager.lastActivity = Date.now();\n      this.setIdleTimer(this.maxIdleInterval + 100);\n    }\n    setIdleTimer(timeout) {\n      if (!this.idleTimer) {\n        this.idleTimer = setTimeout(() => {\n          this.onIdleTimerExpire();\n        }, timeout);\n      }\n    }\n    onIdleTimerExpire() {\n      if (!this.lastActivity || !this.maxIdleInterval) {\n        throw new Error(\"Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set\");\n      }\n      this.idleTimer = null;\n      const sinceLast = Date.now() - this.lastActivity;\n      const timeRemaining = this.maxIdleInterval - sinceLast;\n      if (timeRemaining <= 0) {\n        const msg = \"No activity seen from realtime in \" + sinceLast + \"ms; assuming connection has dropped\";\n        logger_default.logAction(logger_default.LOG_ERROR, \"Transport.onIdleTimerExpire()\", msg);\n        this.disconnect(new ErrorInfo(msg, 80003, 408));\n      } else {\n        this.setIdleTimer(timeRemaining + 100);\n      }\n    }\n    static tryConnect(transportCtor, connectionManager, auth, transportParams, callback) {\n      const transport = new transportCtor(connectionManager, auth, transportParams);\n      let transportAttemptTimer;\n      const errorCb = function (err) {\n        clearTimeout(transportAttemptTimer);\n        callback({\n          event: this.event,\n          error: err\n        });\n      };\n      const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\n      transportAttemptTimer = setTimeout(() => {\n        transport.off([\"preconnect\", \"disconnected\", \"failed\"]);\n        transport.dispose();\n        errorCb.call({\n          event: \"disconnected\"\n        }, new ErrorInfo(\"Timeout waiting for transport to indicate itself viable\", 5e4, 500));\n      }, realtimeRequestTimeout);\n      transport.on([\"failed\", \"disconnected\"], errorCb);\n      transport.on(\"preconnect\", function () {\n        logger_default.logAction(logger_default.LOG_MINOR, \"Transport.tryConnect()\", \"viable transport \" + transport);\n        clearTimeout(transportAttemptTimer);\n        transport.off([\"failed\", \"disconnected\"], errorCb);\n        callback(null, transport);\n      });\n      transport.connect();\n      return transport;\n    }\n    static isAvailable() {\n      throw new ErrorInfo(\"isAvailable not implemented for transport\", 5e4, 500);\n    }\n  };\n  var transport_default = Transport;\n\n  // src/common/constants/TransportName.ts\n  var TransportNames;\n  (TransportNames2 => {\n    TransportNames2.WebSocket = \"web_socket\";\n    TransportNames2.Comet = \"comet\";\n    TransportNames2.XhrPolling = \"xhr_polling\";\n  })(TransportNames || (TransportNames = {}));\n\n  // src/common/lib/transport/connectionmanager.ts\n  var globalObject2 = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : self;\n  var haveWebStorage = () => {\n    var _a2;\n    return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.localSupported);\n  };\n  var haveSessionStorage = () => {\n    var _a2;\n    return typeof Platform.WebStorage !== \"undefined\" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.sessionSupported);\n  };\n  var noop = function () {};\n  var transportPreferenceName = \"ably-transport-preference\";\n  var sessionRecoveryName = \"ably-connection-recovery\";\n  function getSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.getSession) == null ? void 0 : _b.call(_a2, sessionRecoveryName));\n  }\n  function setSessionRecoverData(value) {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.setSession) == null ? void 0 : _b.call(_a2, sessionRecoveryName, value));\n  }\n  function clearSessionRecoverData() {\n    var _a2, _b;\n    return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.removeSession) == null ? void 0 : _b.call(_a2, sessionRecoveryName));\n  }\n  function bundleWith(dest, src, maxSize) {\n    let action;\n    if (dest.channel !== src.channel) {\n      return false;\n    }\n    if ((action = dest.action) !== actions2.PRESENCE && action !== actions2.MESSAGE) {\n      return false;\n    }\n    if (action !== src.action) {\n      return false;\n    }\n    const kind = action === actions2.PRESENCE ? \"presence\" : \"messages\",\n      proposed = dest[kind].concat(src[kind]),\n      size = getMessagesSize(proposed);\n    if (size > maxSize) {\n      return false;\n    }\n    if (!allSame(proposed, \"clientId\")) {\n      return false;\n    }\n    if (!proposed.every(function (msg) {\n      return !msg.id;\n    })) {\n      return false;\n    }\n    dest[kind] = proposed;\n    return true;\n  }\n  function decodeRecoveryKey(recoveryKey) {\n    try {\n      return JSON.parse(recoveryKey);\n    } catch (e) {\n      return null;\n    }\n  }\n  var TransportParams = class {\n    constructor(options, host, mode, connectionKey) {\n      this.options = options;\n      this.host = host;\n      this.mode = mode;\n      this.connectionKey = connectionKey;\n      this.format = options.useBinaryProtocol ? \"msgpack\" /* msgpack */ : \"json\" /* json */;\n    }\n    getConnectParams(authParams) {\n      const params = authParams ? copy(authParams) : {};\n      const options = this.options;\n      switch (this.mode) {\n        case \"resume\":\n          params.resume = this.connectionKey;\n          break;\n        case \"recover\":\n          {\n            const recoveryContext = decodeRecoveryKey(options.recover);\n            if (recoveryContext) {\n              params.recover = recoveryContext.connectionKey;\n            }\n            break;\n          }\n        default:\n      }\n      if (options.clientId !== void 0) {\n        params.clientId = options.clientId;\n      }\n      if (options.echoMessages === false) {\n        params.echo = \"false\";\n      }\n      if (this.format !== void 0) {\n        params.format = this.format;\n      }\n      if (this.stream !== void 0) {\n        params.stream = this.stream;\n      }\n      if (this.heartbeats !== void 0) {\n        params.heartbeats = this.heartbeats;\n      }\n      params.v = defaults_default.protocolVersion;\n      params.agent = getAgentString(this.options);\n      if (options.transportParams !== void 0) {\n        mixin(params, options.transportParams);\n      }\n      return params;\n    }\n    toString() {\n      let result = \"[mode=\" + this.mode;\n      if (this.host) {\n        result += \",host=\" + this.host;\n      }\n      if (this.connectionKey) {\n        result += \",connectionKey=\" + this.connectionKey;\n      }\n      if (this.format) {\n        result += \",format=\" + this.format;\n      }\n      result += \"]\";\n      return result;\n    }\n  };\n  var ConnectionManager = class _ConnectionManager extends eventemitter_default {\n    constructor(realtime, options) {\n      super();\n      this.supportedTransports = {};\n      this.disconnectedRetryCount = 0;\n      this.pendingChannelMessagesState = {\n        isProcessing: false,\n        queue: []\n      };\n      this.realtime = realtime;\n      this.initTransports();\n      this.options = options;\n      const timeouts = options.timeouts;\n      const connectingTimeout = timeouts.webSocketConnectTimeout + timeouts.realtimeRequestTimeout;\n      this.states = {\n        initialized: {\n          state: \"initialized\",\n          terminal: false,\n          queueEvents: true,\n          sendEvents: false,\n          failState: \"disconnected\"\n        },\n        connecting: {\n          state: \"connecting\",\n          terminal: false,\n          queueEvents: true,\n          sendEvents: false,\n          retryDelay: connectingTimeout,\n          failState: \"disconnected\"\n        },\n        connected: {\n          state: \"connected\",\n          terminal: false,\n          queueEvents: false,\n          sendEvents: true,\n          failState: \"disconnected\"\n        },\n        disconnected: {\n          state: \"disconnected\",\n          terminal: false,\n          queueEvents: true,\n          sendEvents: false,\n          retryDelay: timeouts.disconnectedRetryTimeout,\n          failState: \"disconnected\"\n        },\n        suspended: {\n          state: \"suspended\",\n          terminal: false,\n          queueEvents: false,\n          sendEvents: false,\n          retryDelay: timeouts.suspendedRetryTimeout,\n          failState: \"suspended\"\n        },\n        closing: {\n          state: \"closing\",\n          terminal: false,\n          queueEvents: false,\n          sendEvents: false,\n          retryDelay: timeouts.realtimeRequestTimeout,\n          failState: \"closed\"\n        },\n        closed: {\n          state: \"closed\",\n          terminal: true,\n          queueEvents: false,\n          sendEvents: false,\n          failState: \"closed\"\n        },\n        failed: {\n          state: \"failed\",\n          terminal: true,\n          queueEvents: false,\n          sendEvents: false,\n          failState: \"failed\"\n        }\n      };\n      this.state = this.states.initialized;\n      this.errorReason = null;\n      this.queuedMessages = new messagequeue_default();\n      this.msgSerial = 0;\n      this.connectionDetails = void 0;\n      this.connectionId = void 0;\n      this.connectionKey = void 0;\n      this.connectionStateTtl = timeouts.connectionStateTtl;\n      this.maxIdleInterval = null;\n      this.transports = intersect(options.transports || defaults_default.defaultTransports, this.supportedTransports);\n      this.transportPreference = null;\n      if (this.transports.includes(TransportNames.WebSocket)) {\n        this.webSocketTransportAvailable = true;\n      }\n      if (this.transports.includes(TransportNames.XhrPolling)) {\n        this.baseTransport = TransportNames.XhrPolling;\n      } else if (this.transports.includes(TransportNames.Comet)) {\n        this.baseTransport = TransportNames.Comet;\n      }\n      this.httpHosts = defaults_default.getHosts(options);\n      this.wsHosts = defaults_default.getHosts(options, true);\n      this.activeProtocol = null;\n      this.host = null;\n      this.lastAutoReconnectAttempt = null;\n      this.lastActivity = null;\n      this.forceFallbackHost = false;\n      this.connectCounter = 0;\n      this.wsCheckResult = null;\n      this.webSocketSlowTimer = null;\n      this.webSocketGiveUpTimer = null;\n      this.abandonedWebSocket = false;\n      logger_default.logAction(logger_default.LOG_MINOR, \"Realtime.ConnectionManager()\", \"started\");\n      logger_default.logAction(logger_default.LOG_MICRO, \"Realtime.ConnectionManager()\", \"requested transports = [\" + (options.transports || defaults_default.defaultTransports) + \"]\");\n      logger_default.logAction(logger_default.LOG_MICRO, \"Realtime.ConnectionManager()\", \"available transports = [\" + this.transports + \"]\");\n      logger_default.logAction(logger_default.LOG_MICRO, \"Realtime.ConnectionManager()\", \"http hosts = [\" + this.httpHosts + \"]\");\n      if (!this.transports.length) {\n        const msg = \"no requested transports available\";\n        logger_default.logAction(logger_default.LOG_ERROR, \"realtime.ConnectionManager()\", msg);\n        throw new Error(msg);\n      }\n      const addEventListener = Platform.Config.addEventListener;\n      if (addEventListener) {\n        if (haveSessionStorage() && typeof options.recover === \"function\") {\n          addEventListener(\"beforeunload\", this.persistConnection.bind(this));\n        }\n        if (options.closeOnUnload === true) {\n          addEventListener(\"beforeunload\", () => {\n            logger_default.logAction(logger_default.LOG_MAJOR, \"Realtime.ConnectionManager()\", \"beforeunload event has triggered the connection to close as closeOnUnload is true\");\n            this.requestState({\n              state: \"closing\"\n            });\n          });\n        }\n        addEventListener(\"online\", () => {\n          var _a2;\n          if (this.state == this.states.disconnected || this.state == this.states.suspended) {\n            logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager caught browser \\u2018online\\u2019 event\", \"reattempting connection\");\n            this.requestState({\n              state: \"connecting\"\n            });\n          } else if (this.state == this.states.connecting) {\n            (_a2 = this.pendingTransport) == null ? void 0 : _a2.off();\n            this.disconnectAllTransports();\n            this.startConnect();\n          }\n        });\n        addEventListener(\"offline\", () => {\n          if (this.state == this.states.connected) {\n            logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager caught browser \\u2018offline\\u2019 event\", \"disconnecting active transport\");\n            this.disconnectAllTransports();\n          }\n        });\n      }\n    }\n    /*********************\n     * transport management\n     *********************/\n    // Used by tests\n    static supportedTransports(additionalImplementations) {\n      const storage = {\n        supportedTransports: {}\n      };\n      this.initTransports(additionalImplementations, storage);\n      return storage.supportedTransports;\n    }\n    static initTransports(additionalImplementations, storage) {\n      const implementations = __spreadValues(__spreadValues({}, Platform.Transports.bundledImplementations), additionalImplementations);\n      [TransportNames.WebSocket, ...Platform.Transports.order].forEach(transportName => {\n        const transport = implementations[transportName];\n        if (transport && transport.isAvailable()) {\n          storage.supportedTransports[transportName] = transport;\n        }\n      });\n    }\n    initTransports() {\n      _ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);\n    }\n    createTransportParams(host, mode) {\n      return new TransportParams(this.options, host, mode, this.connectionKey);\n    }\n    getTransportParams(callback) {\n      const decideMode = modeCb => {\n        if (this.connectionKey) {\n          modeCb(\"resume\");\n          return;\n        }\n        if (typeof this.options.recover === \"string\") {\n          modeCb(\"recover\");\n          return;\n        }\n        const recoverFn = this.options.recover,\n          lastSessionData = getSessionRecoverData();\n        if (lastSessionData && typeof recoverFn === \"function\") {\n          logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.getTransportParams()\", \"Calling clientOptions-provided recover function with last session data\");\n          recoverFn(lastSessionData, shouldRecover => {\n            if (shouldRecover) {\n              this.options.recover = lastSessionData.recoveryKey;\n              modeCb(\"recover\");\n            } else {\n              modeCb(\"clean\");\n            }\n          });\n          return;\n        }\n        modeCb(\"clean\");\n      };\n      decideMode(mode => {\n        const transportParams = this.createTransportParams(null, mode);\n        if (mode === \"recover\") {\n          logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.getTransportParams()\", \"Transport recovery mode = recover; recoveryKey = \" + this.options.recover);\n          const recoveryContext = decodeRecoveryKey(this.options.recover);\n          if (recoveryContext) {\n            this.msgSerial = recoveryContext.msgSerial;\n          }\n        } else {\n          logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.getTransportParams()\", \"Transport params = \" + transportParams.toString());\n        }\n        callback(transportParams);\n      });\n    }\n    /**\n     * Attempt to connect using a given transport\n     * @param transportParams\n     * @param candidate, the transport to try\n     * @param callback\n     */\n    tryATransport(transportParams, candidate, callback) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.tryATransport()\", \"trying \" + candidate);\n      this.proposedTransport = transport_default.tryConnect(this.supportedTransports[candidate], this, this.realtime.auth, transportParams, (wrappedErr, transport) => {\n        const state = this.state;\n        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {\n          if (transport) {\n            logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.tryATransport()\", \"connection \" + state.state + \" while we were attempting the transport; closing \" + transport);\n            transport.close();\n          }\n          callback(true);\n          return;\n        }\n        if (wrappedErr) {\n          logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.tryATransport()\", \"transport \" + candidate + \" \" + wrappedErr.event + \", err: \" + wrappedErr.error.toString());\n          if (auth_default.isTokenErr(wrappedErr.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason))) {\n            this.errorReason = wrappedErr.error;\n            whenPromiseSettles(this.realtime.auth._forceNewToken(null, null), err => {\n              if (err) {\n                this.actOnErrorFromAuthorize(err);\n                return;\n              }\n              this.tryATransport(transportParams, candidate, callback);\n            });\n          } else if (wrappedErr.event === \"failed\") {\n            this.notifyState({\n              state: \"failed\",\n              error: wrappedErr.error\n            });\n            callback(true);\n          } else if (wrappedErr.event === \"disconnected\") {\n            if (!isRetriable(wrappedErr.error)) {\n              this.notifyState({\n                state: this.states.connecting.failState,\n                error: wrappedErr.error\n              });\n              callback(true);\n            } else {\n              callback(false);\n            }\n          }\n          return;\n        }\n        logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.tryATransport()\", \"viable transport \" + candidate + \"; setting pending\");\n        this.setTransportPending(transport, transportParams);\n        callback(null, transport);\n      });\n    }\n    /**\n     * Called when a transport is indicated to be viable, and the ConnectionManager\n     * expects to activate this transport as soon as it is connected.\n     * @param transport\n     * @param transportParams\n     */\n    setTransportPending(transport, transportParams) {\n      const mode = transportParams.mode;\n      logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.setTransportPending()\", \"transport = \" + transport + \"; mode = \" + mode);\n      this.pendingTransport = transport;\n      this.cancelWebSocketSlowTimer();\n      this.cancelWebSocketGiveUpTimer();\n      transport.once(\"connected\", (error, connectionId, connectionDetails) => {\n        this.activateTransport(error, transport, connectionId, connectionDetails);\n        if (mode === \"recover\" && this.options.recover) {\n          delete this.options.recover;\n          this.unpersistConnection();\n        }\n      });\n      const self2 = this;\n      transport.on([\"disconnected\", \"closed\", \"failed\"], function (error) {\n        self2.deactivateTransport(transport, this.event, error);\n      });\n      this.emit(\"transport.pending\", transport);\n    }\n    /**\n     * Called when a transport is connected, and the connectionmanager decides that\n     * it will now be the active transport. Returns whether or not it activated\n     * the transport (if the connection is closing/closed it will choose not to).\n     * @param transport the transport instance\n     * @param connectionId the id of the new active connection\n     * @param connectionDetails the details of the new active connection\n     */\n    activateTransport(error, transport, connectionId, connectionDetails) {\n      logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.activateTransport()\", \"transport = \" + transport);\n      if (error) {\n        logger_default.logAction(logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", \"error = \" + error);\n      }\n      if (connectionId) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.activateTransport()\", \"connectionId =  \" + connectionId);\n      }\n      if (connectionDetails) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.activateTransport()\", \"connectionDetails =  \" + JSON.stringify(connectionDetails));\n      }\n      this.persistTransportPreference(transport);\n      const existingState = this.state,\n        connectedState = this.states.connected.state;\n      logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.activateTransport()\", \"current state = \" + existingState.state);\n      if (existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.activateTransport()\", \"Disconnecting transport and abandoning\");\n        transport.disconnect();\n        return false;\n      }\n      delete this.pendingTransport;\n      if (!transport.isConnected) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.activateTransport()\", \"Declining to activate transport \" + transport + \" since it appears to no longer be connected\");\n        return false;\n      }\n      const existingActiveProtocol = this.activeProtocol;\n      this.activeProtocol = new protocol_default(transport);\n      this.host = transport.params.host;\n      const connectionKey = connectionDetails.connectionKey;\n      if (connectionKey && this.connectionKey != connectionKey) {\n        this.setConnection(connectionId, connectionDetails, !!error);\n      }\n      this.onConnectionDetailsUpdate(connectionDetails, transport);\n      Platform.Config.nextTick(() => {\n        transport.on(\"connected\", (connectedErr, _connectionId, connectionDetails2) => {\n          this.onConnectionDetailsUpdate(connectionDetails2, transport);\n          this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, connectedErr));\n        });\n      });\n      if (existingState.state === this.states.connected.state) {\n        if (error) {\n          this.errorReason = this.realtime.connection.errorReason = error;\n          this.emit(\"update\", new connectionstatechange_default(connectedState, connectedState, null, error));\n        }\n      } else {\n        this.notifyState({\n          state: \"connected\",\n          error\n        });\n        this.errorReason = this.realtime.connection.errorReason = error || null;\n      }\n      this.emit(\"transport.active\", transport);\n      if (existingActiveProtocol) {\n        if (existingActiveProtocol.messageQueue.count() > 0) {\n          logger_default.logAction(logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", \"Previous active protocol (for transport \" + existingActiveProtocol.transport.shortName + \", new one is \" + transport.shortName + \") finishing with \" + existingActiveProtocol.messageQueue.count() + \" messages still pending\");\n        }\n        if (existingActiveProtocol.transport === transport) {\n          const msg = \"Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = \" + transport.shortName + \"; stack = \" + new Error().stack;\n          logger_default.logAction(logger_default.LOG_ERROR, \"ConnectionManager.activateTransport()\", msg);\n        } else {\n          existingActiveProtocol.finish();\n        }\n      }\n      return true;\n    }\n    /**\n     * Called when a transport is no longer the active transport. This can occur\n     * in any transport connection state.\n     * @param transport\n     */\n    deactivateTransport(transport, state, error) {\n      const currentProtocol = this.activeProtocol,\n        wasActive = currentProtocol && currentProtocol.getTransport() === transport,\n        wasPending = transport === this.pendingTransport,\n        noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\n      logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.deactivateTransport()\", \"transport = \" + transport);\n      logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.deactivateTransport()\", \"state = \" + state + (wasActive ? \"; was active\" : wasPending ? \"; was pending\" : \"\") + (noTransportsScheduledForActivation ? \"\" : \"; another transport is scheduled for activation\"));\n      if (error && error.message) logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.deactivateTransport()\", \"reason =  \" + error.message);\n      if (wasActive) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.deactivateTransport()\", \"Getting, clearing, and requeuing \" + this.activeProtocol.messageQueue.count() + \" pending messages\");\n        this.queuePendingMessages(currentProtocol.getPendingMessages());\n        currentProtocol.clearPendingMessages();\n        this.activeProtocol = this.host = null;\n      }\n      this.emit(\"transport.inactive\", transport);\n      if (wasActive && noTransportsScheduledForActivation || wasActive && state === \"failed\" || state === \"closed\" || currentProtocol === null && wasPending) {\n        if (state === \"disconnected\" && error && error.statusCode > 500 && this.httpHosts.length > 1) {\n          this.unpersistTransportPreference();\n          this.forceFallbackHost = true;\n          this.notifyState({\n            state,\n            error,\n            retryImmediately: true\n          });\n          return;\n        }\n        const newConnectionState = state === \"failed\" && auth_default.isTokenErr(error) ? \"disconnected\" : state;\n        this.notifyState({\n          state: newConnectionState,\n          error\n        });\n        return;\n      }\n    }\n    /* Helper that returns true if there are no transports which are pending,\n     * have been connected, and are just waiting for onceNoPending to fire before\n     * being activated */\n    noTransportsScheduledForActivation() {\n      return !this.pendingTransport || !this.pendingTransport.isConnected;\n    }\n    setConnection(connectionId, connectionDetails, hasConnectionError) {\n      const prevConnId = this.connectionId,\n        connIdChanged = prevConnId && prevConnId !== connectionId,\n        recoverFailure = !prevConnId && hasConnectionError;\n      if (connIdChanged || recoverFailure) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.setConnection()\", \"Resetting msgSerial\");\n        this.msgSerial = 0;\n        this.queuedMessages.resetSendAttempted();\n      }\n      if (this.connectionId !== connectionId) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.setConnection()\", \"New connectionId; reattaching any attached channels\");\n      }\n      this.realtime.connection.id = this.connectionId = connectionId;\n      this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\n    }\n    clearConnection() {\n      this.realtime.connection.id = this.connectionId = void 0;\n      this.realtime.connection.key = this.connectionKey = void 0;\n      this.msgSerial = 0;\n      this.unpersistConnection();\n    }\n    createRecoveryKey() {\n      if (!this.connectionKey) {\n        return null;\n      }\n      return JSON.stringify({\n        connectionKey: this.connectionKey,\n        msgSerial: this.msgSerial,\n        channelSerials: this.realtime.channels.channelSerials()\n      });\n    }\n    checkConnectionStateFreshness() {\n      if (!this.lastActivity || !this.connectionId) {\n        return;\n      }\n      const sinceLast = Date.now() - this.lastActivity;\n      if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.checkConnectionStateFreshness()\", \"Last known activity from realtime was \" + sinceLast + \"ms ago; discarding connection state\");\n        this.clearConnection();\n        this.states.connecting.failState = \"suspended\";\n      }\n    }\n    /**\n     * Called when the connectionmanager wants to persist transport\n     * state for later recovery. Only applicable in the browser context.\n     */\n    persistConnection() {\n      if (haveSessionStorage()) {\n        const recoveryKey = this.createRecoveryKey();\n        if (recoveryKey) {\n          setSessionRecoverData({\n            recoveryKey,\n            disconnectedAt: Date.now(),\n            location: globalObject2.location,\n            clientId: this.realtime.auth.clientId\n          });\n        }\n      }\n    }\n    /**\n     * Called when the connectionmanager wants to persist transport\n     * state for later recovery. Only applicable in the browser context.\n     */\n    unpersistConnection() {\n      clearSessionRecoverData();\n    }\n    /*********************\n     * state management\n     *********************/\n    getError() {\n      return this.errorReason || this.getStateError();\n    }\n    getStateError() {\n      var _a2, _b;\n      return (_b = (_a2 = connectionerrors_default)[this.state.state]) == null ? void 0 : _b.call(_a2);\n    }\n    activeState() {\n      return this.state.queueEvents || this.state.sendEvents;\n    }\n    enactStateChange(stateChange) {\n      const action = \"Connection state\";\n      const message = stateChange.current + (stateChange.reason ? \"; reason: \" + stateChange.reason : \"\");\n      if (stateChange.current === \"failed\") {\n        logger_default.logAction(logger_default.LOG_ERROR, action, message);\n      } else {\n        logger_default.logAction(logger_default.LOG_MAJOR, action, message);\n      }\n      logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.enactStateChange\", \"setting new state: \" + stateChange.current + \"; reason = \" + (stateChange.reason && stateChange.reason.message));\n      const newState = this.state = this.states[stateChange.current];\n      if (stateChange.reason) {\n        this.errorReason = stateChange.reason;\n        this.realtime.connection.errorReason = stateChange.reason;\n      }\n      if (newState.terminal || newState.state === \"suspended\") {\n        this.clearConnection();\n      }\n      this.emit(\"connectionstate\", stateChange);\n    }\n    /****************************************\n     * ConnectionManager connection lifecycle\n     ****************************************/\n    startTransitionTimer(transitionState) {\n      logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.startTransitionTimer()\", \"transitionState: \" + transitionState.state);\n      if (this.transitionTimer) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.startTransitionTimer()\", \"clearing already-running timer\");\n        clearTimeout(this.transitionTimer);\n      }\n      this.transitionTimer = setTimeout(() => {\n        if (this.transitionTimer) {\n          this.transitionTimer = null;\n          logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager \" + transitionState.state + \" timer expired\", \"requesting new state: \" + transitionState.failState);\n          this.notifyState({\n            state: transitionState.failState\n          });\n        }\n      }, transitionState.retryDelay);\n    }\n    cancelTransitionTimer() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.cancelTransitionTimer()\", \"\");\n      if (this.transitionTimer) {\n        clearTimeout(this.transitionTimer);\n        this.transitionTimer = null;\n      }\n    }\n    startSuspendTimer() {\n      if (this.suspendTimer) return;\n      this.suspendTimer = setTimeout(() => {\n        if (this.suspendTimer) {\n          this.suspendTimer = null;\n          logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager suspend timer expired\", \"requesting new state: suspended\");\n          this.states.connecting.failState = \"suspended\";\n          this.notifyState({\n            state: \"suspended\"\n          });\n        }\n      }, this.connectionStateTtl);\n    }\n    checkSuspendTimer(state) {\n      if (state !== \"disconnected\" && state !== \"suspended\" && state !== \"connecting\") this.cancelSuspendTimer();\n    }\n    cancelSuspendTimer() {\n      this.states.connecting.failState = \"disconnected\";\n      if (this.suspendTimer) {\n        clearTimeout(this.suspendTimer);\n        this.suspendTimer = null;\n      }\n    }\n    startRetryTimer(interval) {\n      this.retryTimer = setTimeout(() => {\n        logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager retry timer expired\", \"retrying\");\n        this.retryTimer = null;\n        this.requestState({\n          state: \"connecting\"\n        });\n      }, interval);\n    }\n    cancelRetryTimer() {\n      if (this.retryTimer) {\n        clearTimeout(this.retryTimer);\n        this.retryTimer = null;\n      }\n    }\n    startWebSocketSlowTimer() {\n      this.webSocketSlowTimer = setTimeout(() => {\n        logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager WebSocket slow timer\", \"checking connectivity\");\n        if (this.wsCheckResult === null) {\n          this.checkWsConnectivity().then(() => {\n            logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager WebSocket slow timer\", \"ws connectivity check succeeded\");\n            this.wsCheckResult = true;\n          }).catch(() => {\n            logger_default.logAction(logger_default.LOG_MAJOR, \"ConnectionManager WebSocket slow timer\", \"ws connectivity check failed\");\n            this.wsCheckResult = false;\n          });\n        }\n        if (this.realtime.http.checkConnectivity) {\n          whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\n            if (err || !connectivity) {\n              logger_default.logAction(logger_default.LOG_MAJOR, \"ConnectionManager WebSocket slow timer\", \"http connectivity check failed\");\n              this.cancelWebSocketGiveUpTimer();\n              this.notifyState({\n                state: \"disconnected\",\n                error: new ErrorInfo(\"new ErrorInfo('Unable to connect (network unreachable)'\", 80003, 404)\n              });\n            } else {\n              logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager WebSocket slow timer\", \"http connectivity check succeeded\");\n            }\n          });\n        }\n      }, this.options.timeouts.webSocketSlowTimeout);\n    }\n    cancelWebSocketSlowTimer() {\n      if (this.webSocketSlowTimer) {\n        clearTimeout(this.webSocketSlowTimer);\n        this.webSocketSlowTimer = null;\n      }\n    }\n    startWebSocketGiveUpTimer(transportParams) {\n      this.webSocketGiveUpTimer = setTimeout(() => {\n        var _a2, _b;\n        if (!this.wsCheckResult) {\n          logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager WebSocket give up timer\", \"websocket connection took more than 10s; \" + (this.baseTransport ? \"trying base transport\" : \"\"));\n          if (this.baseTransport) {\n            this.abandonedWebSocket = true;\n            (_a2 = this.proposedTransport) == null ? void 0 : _a2.dispose();\n            (_b = this.pendingTransport) == null ? void 0 : _b.dispose();\n            this.connectBase(transportParams, ++this.connectCounter);\n          } else {\n            logger_default.logAction(logger_default.LOG_MAJOR, \"ConnectionManager WebSocket give up timer\", \"websocket connectivity appears to be unavailable but no other transports to try\");\n          }\n        }\n      }, this.options.timeouts.webSocketConnectTimeout);\n    }\n    cancelWebSocketGiveUpTimer() {\n      if (this.webSocketGiveUpTimer) {\n        clearTimeout(this.webSocketGiveUpTimer);\n        this.webSocketGiveUpTimer = null;\n      }\n    }\n    notifyState(indicated) {\n      var _a2, _b;\n      const state = indicated.state;\n      const retryImmediately = state === \"disconnected\" && (this.state === this.states.connected || indicated.retryImmediately || this.state === this.states.connecting && indicated.error && auth_default.isTokenErr(indicated.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason)));\n      logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.notifyState()\", \"new state: \" + state + (retryImmediately ? \"; will retry connection immediately\" : \"\"));\n      if (state == this.state.state) return;\n      this.cancelTransitionTimer();\n      this.cancelRetryTimer();\n      this.cancelWebSocketSlowTimer();\n      this.cancelWebSocketGiveUpTimer();\n      this.checkSuspendTimer(indicated.state);\n      if (state === \"suspended\" || state === \"connected\") {\n        this.disconnectedRetryCount = 0;\n      }\n      if (this.state.terminal) return;\n      const newState = this.states[indicated.state];\n      let retryDelay = newState.retryDelay;\n      if (newState.state === \"disconnected\") {\n        this.disconnectedRetryCount++;\n        retryDelay = getRetryTime(newState.retryDelay, this.disconnectedRetryCount);\n      }\n      const change = new connectionstatechange_default(this.state.state, newState.state, retryDelay, indicated.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2)));\n      if (retryImmediately) {\n        const autoReconnect = () => {\n          if (this.state === this.states.disconnected) {\n            this.lastAutoReconnectAttempt = Date.now();\n            this.requestState({\n              state: \"connecting\"\n            });\n          }\n        };\n        const sinceLast = this.lastAutoReconnectAttempt && Date.now() - this.lastAutoReconnectAttempt + 1;\n        if (sinceLast && sinceLast < 1e3) {\n          logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.notifyState()\", \"Last reconnect attempt was only \" + sinceLast + \"ms ago, waiting another \" + (1e3 - sinceLast) + \"ms before trying again\");\n          setTimeout(autoReconnect, 1e3 - sinceLast);\n        } else {\n          Platform.Config.nextTick(autoReconnect);\n        }\n      } else if (state === \"disconnected\" || state === \"suspended\") {\n        this.startRetryTimer(retryDelay);\n      }\n      if (state === \"disconnected\" && !retryImmediately || state === \"suspended\" || newState.terminal) {\n        Platform.Config.nextTick(() => {\n          this.disconnectAllTransports();\n        });\n      }\n      if (state == \"connected\" && !this.activeProtocol) {\n        logger_default.logAction(logger_default.LOG_ERROR, \"ConnectionManager.notifyState()\", \"Broken invariant: attempted to go into connected state, but there is no active protocol\");\n      }\n      this.enactStateChange(change);\n      if (this.state.sendEvents) {\n        this.sendQueuedMessages();\n      } else if (!this.state.queueEvents) {\n        this.realtime.channels.propogateConnectionInterruption(state, change.reason);\n        this.failQueuedMessages(change.reason);\n      }\n    }\n    requestState(request) {\n      var _a2, _b;\n      const state = request.state;\n      logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.requestState()\", \"requested state: \" + state + \"; current state: \" + this.state.state);\n      if (state == this.state.state) return;\n      this.cancelWebSocketSlowTimer();\n      this.cancelWebSocketGiveUpTimer();\n      this.cancelTransitionTimer();\n      this.cancelRetryTimer();\n      this.checkSuspendTimer(state);\n      if (state == \"connecting\" && this.state.state == \"connected\") return;\n      if (state == \"closing\" && this.state.state == \"closed\") return;\n      const newState = this.states[state],\n        change = new connectionstatechange_default(this.state.state, newState.state, null, request.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2)));\n      this.enactStateChange(change);\n      if (state == \"connecting\") {\n        Platform.Config.nextTick(() => {\n          this.startConnect();\n        });\n      }\n      if (state == \"closing\") {\n        this.closeImpl();\n      }\n    }\n    startConnect() {\n      if (this.state !== this.states.connecting) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.startConnect()\", \"Must be in connecting state to connect, but was \" + this.state.state);\n        return;\n      }\n      const auth = this.realtime.auth;\n      const connectCount = ++this.connectCounter;\n      const connect = () => {\n        this.checkConnectionStateFreshness();\n        this.getTransportParams(transportParams => {\n          if (transportParams.mode === \"recover\" && transportParams.options.recover) {\n            const recoveryContext = decodeRecoveryKey(transportParams.options.recover);\n            if (recoveryContext) {\n              this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\n            }\n          }\n          if (connectCount !== this.connectCounter) {\n            return;\n          }\n          this.connectImpl(transportParams, connectCount);\n        });\n      };\n      logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.startConnect()\", \"starting connection\");\n      this.startSuspendTimer();\n      this.startTransitionTimer(this.states.connecting);\n      if (auth.method === \"basic\") {\n        connect();\n      } else {\n        const authCb = err => {\n          if (connectCount !== this.connectCounter) {\n            return;\n          }\n          if (err) {\n            this.actOnErrorFromAuthorize(err);\n          } else {\n            connect();\n          }\n        };\n        if (this.errorReason && auth_default.isTokenErr(this.errorReason)) {\n          whenPromiseSettles(auth._forceNewToken(null, null), authCb);\n        } else {\n          whenPromiseSettles(auth._ensureValidAuthCredentials(false), authCb);\n        }\n      }\n    }\n    /*\n     * there are, at most, two transports available with which a connection may\n     * be attempted: web_socket and/or a base transport (xhr_polling in browsers,\n     * comet in nodejs). web_socket is always preferred, and the base transport is\n     * only used in case web_socket connectivity appears to be unavailable.\n     *\n     * connectImpl begins the transport selection process by checking which transports\n     * are available, and if there is a cached preference. It then defers to the\n     * transport-specific connect methods: connectWs and connectBase.\n     *\n     * It is also responsible for invalidating the cache in the case that a base\n     * transport preference is stored but web socket connectivity is now available.\n     *\n     * handling of the case where we need to failover from web_socket to the base\n     * transport is implemented in the connectWs method.\n     */\n    connectImpl(transportParams, connectCount) {\n      const state = this.state.state;\n      if (state !== this.states.connecting.state) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.connectImpl()\", \"Must be in connecting state to connect, but was \" + state);\n        return;\n      }\n      const transportPreference = this.getTransportPreference();\n      if (transportPreference && transportPreference === this.baseTransport && this.webSocketTransportAvailable) {\n        this.checkWsConnectivity().then(() => {\n          this.wsCheckResult = true;\n          this.abandonedWebSocket = false;\n          this.unpersistTransportPreference();\n          if (this.state === this.states.connecting) {\n            logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.connectImpl():\", \"web socket connectivity available, cancelling connection attempt with \" + this.baseTransport);\n            this.disconnectAllTransports();\n            this.connectWs(transportParams, ++this.connectCounter);\n          }\n        }).catch(noop);\n      }\n      if (transportPreference && transportPreference === this.baseTransport || this.baseTransport && !this.webSocketTransportAvailable) {\n        this.connectBase(transportParams, connectCount);\n      } else {\n        this.connectWs(transportParams, connectCount);\n      }\n    }\n    /*\n     * connectWs starts two timers to monitor the success of a web_socket connection attempt:\n     * - webSocketSlowTimer: if this timer fires before the connection succeeds,\n     *   cm will simultaneously check websocket and http/xhr connectivity. if the http\n     *   connectivity check fails, we give up the connection sequence entirely and\n     *   transition to disconnected. if the websocket connectivity check fails then\n     *   we assume no ws connectivity and failover to base transport. in the case that\n     *   the checks succeed, we continue with websocket and wait for it to try fallback hosts\n     *   and, if unsuccessful, ultimately transition to disconnected.\n     * - webSocketGiveUpTimer: if this timer fires, and the preceding websocket\n     *   connectivity check is still pending then we assume that there is an issue\n     *   with the transport and fallback to base transport.\n     */\n    connectWs(transportParams, connectCount) {\n      logger_default.logAction(logger_default.LOG_DEBUG, \"ConnectionManager.connectWs()\");\n      this.startWebSocketSlowTimer();\n      this.startWebSocketGiveUpTimer(transportParams);\n      this.tryTransportWithFallbacks(\"web_socket\", transportParams, true, connectCount, () => {\n        return this.wsCheckResult !== false && !this.abandonedWebSocket;\n      });\n    }\n    connectBase(transportParams, connectCount) {\n      logger_default.logAction(logger_default.LOG_DEBUG, \"ConnectionManager.connectBase()\");\n      if (this.baseTransport) {\n        this.tryTransportWithFallbacks(this.baseTransport, transportParams, false, connectCount, () => true);\n      } else {\n        this.notifyState({\n          state: \"disconnected\",\n          error: new ErrorInfo(\"No transports left to try\", 8e4, 404)\n        });\n      }\n    }\n    tryTransportWithFallbacks(transportName, transportParams, ws, connectCount, shouldContinue) {\n      logger_default.logAction(logger_default.LOG_DEBUG, \"ConnectionManager.tryTransportWithFallbacks()\", transportName);\n      const giveUp = err => {\n        this.notifyState({\n          state: this.states.connecting.failState,\n          error: err\n        });\n      };\n      const candidateHosts = ws ? this.wsHosts.slice() : this.httpHosts.slice();\n      const hostAttemptCb = (fatal, transport) => {\n        if (connectCount !== this.connectCounter) {\n          return;\n        }\n        if (!shouldContinue()) {\n          if (transport) {\n            transport.dispose();\n          }\n          return;\n        }\n        if (!transport && !fatal) {\n          tryFallbackHosts();\n        }\n      };\n      const host = candidateHosts.shift();\n      if (!host) {\n        giveUp(new ErrorInfo(\"Unable to connect (no available host)\", 80003, 404));\n        return;\n      }\n      transportParams.host = host;\n      const tryFallbackHosts = () => {\n        if (!candidateHosts.length) {\n          giveUp(new ErrorInfo(\"Unable to connect (and no more fallback hosts to try)\", 80003, 404));\n          return;\n        }\n        if (!this.realtime.http.checkConnectivity) {\n          giveUp(new PartialErrorInfo(\"Internal error: Http.checkConnectivity not set\", null, 500));\n          return;\n        }\n        whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\n          if (connectCount !== this.connectCounter) {\n            return;\n          }\n          if (!shouldContinue()) {\n            return;\n          }\n          if (err) {\n            giveUp(err);\n            return;\n          }\n          if (!connectivity) {\n            giveUp(new ErrorInfo(\"Unable to connect (network unreachable)\", 80003, 404));\n            return;\n          }\n          transportParams.host = arrPopRandomElement(candidateHosts);\n          this.tryATransport(transportParams, transportName, hostAttemptCb);\n        });\n      };\n      if (this.forceFallbackHost && candidateHosts.length) {\n        this.forceFallbackHost = false;\n        tryFallbackHosts();\n        return;\n      }\n      this.tryATransport(transportParams, transportName, hostAttemptCb);\n    }\n    closeImpl() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.closeImpl()\", \"closing connection\");\n      this.cancelSuspendTimer();\n      this.startTransitionTimer(this.states.closing);\n      if (this.pendingTransport) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.closeImpl()\", \"Closing pending transport: \" + this.pendingTransport);\n        this.pendingTransport.close();\n      }\n      if (this.activeProtocol) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.closeImpl()\", \"Closing active transport: \" + this.activeProtocol.getTransport());\n        this.activeProtocol.getTransport().close();\n      }\n      this.notifyState({\n        state: \"closed\"\n      });\n    }\n    onAuthUpdated(tokenDetails, callback) {\n      var _a2;\n      switch (this.state.state) {\n        case \"connected\":\n          {\n            logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.onAuthUpdated()\", \"Sending AUTH message on active transport\");\n            const activeTransport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();\n            if (activeTransport && activeTransport.onAuthUpdated) {\n              activeTransport.onAuthUpdated(tokenDetails);\n            }\n            const authMsg = fromValues3({\n              action: actions2.AUTH,\n              auth: {\n                accessToken: tokenDetails.token\n              }\n            });\n            this.send(authMsg);\n            const successListener = () => {\n              this.off(failureListener);\n              callback(null, tokenDetails);\n            };\n            const failureListener = stateChange => {\n              if (stateChange.current === \"failed\") {\n                this.off(successListener);\n                this.off(failureListener);\n                callback(stateChange.reason || this.getStateError());\n              }\n            };\n            this.once(\"connectiondetails\", successListener);\n            this.on(\"connectionstate\", failureListener);\n            break;\n          }\n        case \"connecting\":\n          logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.onAuthUpdated()\", \"Aborting current connection attempts in order to start again with the new auth details\");\n          this.disconnectAllTransports();\n        default:\n          {\n            logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.onAuthUpdated()\", \"Connection state is \" + this.state.state + \"; waiting until either connected or failed\");\n            const listener = stateChange => {\n              switch (stateChange.current) {\n                case \"connected\":\n                  this.off(listener);\n                  callback(null, tokenDetails);\n                  break;\n                case \"failed\":\n                case \"closed\":\n                case \"suspended\":\n                  this.off(listener);\n                  callback(stateChange.reason || this.getStateError());\n                  break;\n                default:\n                  break;\n              }\n            };\n            this.on(\"connectionstate\", listener);\n            if (this.state.state === \"connecting\") {\n              this.startConnect();\n            } else {\n              this.requestState({\n                state: \"connecting\"\n              });\n            }\n          }\n      }\n    }\n    disconnectAllTransports() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.disconnectAllTransports()\", \"Disconnecting all transports\");\n      this.connectCounter++;\n      if (this.pendingTransport) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.disconnectAllTransports()\", \"Disconnecting pending transport: \" + this.pendingTransport);\n        this.pendingTransport.disconnect();\n      }\n      delete this.pendingTransport;\n      if (this.proposedTransport) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.disconnectAllTransports()\", \"Disconnecting proposed transport: \" + this.pendingTransport);\n        this.proposedTransport.disconnect();\n      }\n      delete this.pendingTransport;\n      if (this.activeProtocol) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.disconnectAllTransports()\", \"Disconnecting active transport: \" + this.activeProtocol.getTransport());\n        this.activeProtocol.getTransport().disconnect();\n      }\n    }\n    /******************\n     * event queueing\n     ******************/\n    send(msg, queueEvent, callback) {\n      callback = callback || noop;\n      const state = this.state;\n      if (state.sendEvents) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.send()\", \"sending event\");\n        this.sendImpl(new PendingMessage(msg, callback));\n        return;\n      }\n      const shouldQueue = queueEvent && state.queueEvents;\n      if (!shouldQueue) {\n        const err = \"rejecting event, queueEvent was \" + queueEvent + \", state was \" + state.state;\n        logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.send()\", err);\n        callback(this.errorReason || new ErrorInfo(err, 9e4, 400));\n        return;\n      }\n      if (logger_default.shouldLog(logger_default.LOG_MICRO)) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.send()\", \"queueing msg; \" + stringify(msg, this.realtime._RealtimePresence));\n      }\n      this.queue(msg, callback);\n    }\n    sendImpl(pendingMessage) {\n      const msg = pendingMessage.message;\n      if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\n        msg.msgSerial = this.msgSerial++;\n      }\n      try {\n        this.activeProtocol.send(pendingMessage);\n      } catch (e) {\n        logger_default.logAction(logger_default.LOG_ERROR, \"ConnectionManager.sendImpl()\", \"Unexpected exception in transport.send(): \" + e.stack);\n      }\n    }\n    queue(msg, callback) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.queue()\", \"queueing event\");\n      const lastQueued = this.queuedMessages.last();\n      const maxSize = this.options.maxMessageSize;\n      if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {\n        if (!lastQueued.merged) {\n          lastQueued.callback = multicaster_default.create([lastQueued.callback]);\n          lastQueued.merged = true;\n        }\n        lastQueued.callback.push(callback);\n      } else {\n        this.queuedMessages.push(new PendingMessage(msg, callback));\n      }\n    }\n    sendQueuedMessages() {\n      logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.sendQueuedMessages()\", \"sending \" + this.queuedMessages.count() + \" queued messages\");\n      let pendingMessage;\n      while (pendingMessage = this.queuedMessages.shift()) this.sendImpl(pendingMessage);\n    }\n    queuePendingMessages(pendingMessages) {\n      if (pendingMessages && pendingMessages.length) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"ConnectionManager.queuePendingMessages()\", \"queueing \" + pendingMessages.length + \" pending messages\");\n        this.queuedMessages.prepend(pendingMessages);\n      }\n    }\n    failQueuedMessages(err) {\n      const numQueued = this.queuedMessages.count();\n      if (numQueued > 0) {\n        logger_default.logAction(logger_default.LOG_ERROR, \"ConnectionManager.failQueuedMessages()\", \"failing \" + numQueued + \" queued messages, err = \" + inspectError(err));\n        this.queuedMessages.completeAllMessages(err);\n      }\n    }\n    onChannelMessage(message, transport) {\n      this.pendingChannelMessagesState.queue.push({\n        message,\n        transport\n      });\n      if (!this.pendingChannelMessagesState.isProcessing) {\n        this.processNextPendingChannelMessage();\n      }\n    }\n    processNextPendingChannelMessage() {\n      if (this.pendingChannelMessagesState.queue.length > 0) {\n        this.pendingChannelMessagesState.isProcessing = true;\n        const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift();\n        this.processChannelMessage(pendingChannelMessage.message).catch(err => {\n          logger_default.logAction(logger_default.LOG_ERROR, \"ConnectionManager.processNextPendingChannelMessage() received error \", err);\n        }).finally(() => {\n          this.pendingChannelMessagesState.isProcessing = false;\n          this.processNextPendingChannelMessage();\n        });\n      }\n    }\n    async processChannelMessage(message) {\n      await this.realtime.channels.processChannelMessage(message);\n    }\n    ping(transport, callback) {\n      if (transport) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.ping()\", \"transport = \" + transport);\n        const onTimeout = function () {\n          transport.off(\"heartbeat\", onHeartbeat);\n          callback(new ErrorInfo(\"Timeout waiting for heartbeat response\", 5e4, 500));\n        };\n        const pingStart = Date.now(),\n          id = cheapRandStr();\n        const onHeartbeat = function (responseId) {\n          if (responseId === id) {\n            transport.off(\"heartbeat\", onHeartbeat);\n            clearTimeout(timer);\n            const responseTime = Date.now() - pingStart;\n            callback(null, responseTime);\n          }\n        };\n        const timer = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);\n        transport.on(\"heartbeat\", onHeartbeat);\n        transport.ping(id);\n        return;\n      }\n      if (this.state.state !== \"connected\") {\n        callback(new ErrorInfo(\"Unable to ping service; not connected\", 4e4, 400));\n        return;\n      }\n      let completed = false;\n      const onPingComplete = (err, responseTime) => {\n        this.off(\"transport.active\", onTransportActive);\n        if (!completed) {\n          completed = true;\n          callback(err, responseTime);\n        }\n      };\n      const onTransportActive = () => {\n        if (!completed) {\n          completed = true;\n          Platform.Config.nextTick(() => {\n            this.ping(null, callback);\n          });\n        }\n      };\n      this.on(\"transport.active\", onTransportActive);\n      this.ping(this.activeProtocol.getTransport(), onPingComplete);\n    }\n    abort(error) {\n      this.activeProtocol.getTransport().fail(error);\n    }\n    getTransportPreference() {\n      var _a2, _b;\n      return this.transportPreference || haveWebStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.get) == null ? void 0 : _b.call(_a2, transportPreferenceName));\n    }\n    persistTransportPreference(transport) {\n      var _a2, _b;\n      this.transportPreference = transport.shortName;\n      if (haveWebStorage()) {\n        (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.set) == null ? void 0 : _b.call(_a2, transportPreferenceName, transport.shortName);\n      }\n    }\n    unpersistTransportPreference() {\n      var _a2, _b;\n      this.transportPreference = null;\n      if (haveWebStorage()) {\n        (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.remove) == null ? void 0 : _b.call(_a2, transportPreferenceName);\n      }\n    }\n    /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\n     * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\n     * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\n     * server returns 403. */\n    actOnErrorFromAuthorize(err) {\n      if (err.code === 40171) {\n        this.notifyState({\n          state: \"failed\",\n          error: err\n        });\n      } else if (err.code === 40102) {\n        this.notifyState({\n          state: \"failed\",\n          error: err\n        });\n      } else if (err.statusCode === HttpStatusCodes_default.Forbidden) {\n        const msg = \"Client configured authentication provider returned 403; failing the connection\";\n        logger_default.logAction(logger_default.LOG_ERROR, \"ConnectionManager.actOnErrorFromAuthorize()\", msg);\n        this.notifyState({\n          state: \"failed\",\n          error: new ErrorInfo(msg, 80019, 403, err)\n        });\n      } else {\n        const msg = \"Client configured authentication provider request failed\";\n        logger_default.logAction(logger_default.LOG_MINOR, \"ConnectionManager.actOnErrorFromAuthorize\", msg);\n        this.notifyState({\n          state: this.state.failState,\n          error: new ErrorInfo(msg, 80019, 401, err)\n        });\n      }\n    }\n    onConnectionDetailsUpdate(connectionDetails, transport) {\n      if (!connectionDetails) {\n        return;\n      }\n      this.connectionDetails = connectionDetails;\n      if (connectionDetails.maxMessageSize) {\n        this.options.maxMessageSize = connectionDetails.maxMessageSize;\n      }\n      const clientId = connectionDetails.clientId;\n      if (clientId) {\n        const err = this.realtime.auth._uncheckedSetClientId(clientId);\n        if (err) {\n          logger_default.logAction(logger_default.LOG_ERROR, \"ConnectionManager.onConnectionDetailsUpdate()\", err.message);\n          transport.fail(err);\n          return;\n        }\n      }\n      const connectionStateTtl = connectionDetails.connectionStateTtl;\n      if (connectionStateTtl) {\n        this.connectionStateTtl = connectionStateTtl;\n      }\n      this.maxIdleInterval = connectionDetails.maxIdleInterval;\n      this.emit(\"connectiondetails\", connectionDetails);\n    }\n    checkWsConnectivity() {\n      const ws = new Platform.Config.WebSocket(defaults_default.wsConnectivityUrl);\n      return new Promise((resolve, reject) => {\n        let finished = false;\n        ws.onopen = () => {\n          if (!finished) {\n            finished = true;\n            resolve();\n            ws.close();\n          }\n        };\n        ws.onclose = ws.onerror = () => {\n          if (!finished) {\n            finished = true;\n            reject();\n          }\n        };\n      });\n    }\n  };\n  var connectionmanager_default = ConnectionManager;\n\n  // src/common/lib/client/connection.ts\n  var Connection = class extends eventemitter_default {\n    constructor(ably, options) {\n      super();\n      this.whenState = state => {\n        return eventemitter_default.prototype.whenState.call(this, state, this.state);\n      };\n      this.ably = ably;\n      this.connectionManager = new connectionmanager_default(ably, options);\n      this.state = this.connectionManager.state.state;\n      this.key = void 0;\n      this.id = void 0;\n      this.errorReason = null;\n      this.connectionManager.on(\"connectionstate\", stateChange => {\n        const state = this.state = stateChange.current;\n        Platform.Config.nextTick(() => {\n          this.emit(state, stateChange);\n        });\n      });\n      this.connectionManager.on(\"update\", stateChange => {\n        Platform.Config.nextTick(() => {\n          this.emit(\"update\", stateChange);\n        });\n      });\n    }\n    connect() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"Connection.connect()\", \"\");\n      this.connectionManager.requestState({\n        state: \"connecting\"\n      });\n    }\n    async ping() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"Connection.ping()\", \"\");\n      return new Promise((resolve, reject) => {\n        this.connectionManager.ping(null, (err, result) => err ? reject(err) : resolve(result));\n      });\n    }\n    close() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"Connection.close()\", \"connectionKey = \" + this.key);\n      this.connectionManager.requestState({\n        state: \"closing\"\n      });\n    }\n    get recoveryKey() {\n      logger_default.deprecationWarning(\"The `Connection.recoveryKey` attribute has been replaced by the `Connection.createRecoveryKey()` method. Replace your usage of `recoveryKey` with the return value of `createRecoveryKey()`. `recoveryKey` will be removed in a future version.\");\n      return this.createRecoveryKey();\n    }\n    createRecoveryKey() {\n      return this.connectionManager.createRecoveryKey();\n    }\n  };\n  var connection_default = Connection;\n\n  // src/common/lib/client/channelstatechange.ts\n  var ChannelStateChange = class {\n    constructor(previous, current, resumed, hasBacklog, reason) {\n      this.previous = previous;\n      this.current = current;\n      if (current === \"attached\") {\n        this.resumed = resumed;\n        this.hasBacklog = hasBacklog;\n      }\n      if (reason) this.reason = reason;\n    }\n  };\n  var channelstatechange_default = ChannelStateChange;\n\n  // src/common/lib/client/realtimechannel.ts\n  var noop2 = function () {};\n  function validateChannelOptions(options) {\n    if (options && \"params\" in options && !isObject(options.params)) {\n      return new ErrorInfo(\"options.params must be an object\", 4e4, 400);\n    }\n    if (options && \"modes\" in options) {\n      if (!Array.isArray(options.modes)) {\n        return new ErrorInfo(\"options.modes must be an array\", 4e4, 400);\n      }\n      for (let i = 0; i < options.modes.length; i++) {\n        const currentMode = options.modes[i];\n        if (!currentMode || typeof currentMode !== \"string\" || !channelModes.includes(String.prototype.toUpperCase.call(currentMode))) {\n          return new ErrorInfo(\"Invalid channel mode: \" + currentMode, 4e4, 400);\n        }\n      }\n    }\n  }\n  var RealtimeChannel = class _RealtimeChannel extends eventemitter_default {\n    constructor(client, name, options) {\n      var _a2;\n      super();\n      this.retryCount = 0;\n      this.history = async function (params) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"RealtimeChannel.history()\", \"channel = \" + this.name);\n        const restMixin = this.client.rest.channelMixin;\n        if (params && params.untilAttach) {\n          if (this.state !== \"attached\") {\n            throw new ErrorInfo(\"option untilAttach requires the channel to be attached\", 4e4, 400);\n          }\n          if (!this.properties.attachSerial) {\n            throw new ErrorInfo(\"untilAttach was specified and channel is attached, but attachSerial is not defined\", 4e4, 400);\n          }\n          delete params.untilAttach;\n          params.from_serial = this.properties.attachSerial;\n        }\n        return restMixin.history(this, params);\n      };\n      this.whenState = state => {\n        return eventemitter_default.prototype.whenState.call(this, state, this.state);\n      };\n      logger_default.logAction(logger_default.LOG_MINOR, \"RealtimeChannel()\", \"started; name = \" + name);\n      this.name = name;\n      this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, options);\n      this.client = client;\n      this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;\n      this.connectionManager = client.connection.connectionManager;\n      this.state = \"initialized\";\n      this.subscriptions = new eventemitter_default();\n      this.syncChannelSerial = void 0;\n      this.properties = {\n        attachSerial: void 0,\n        channelSerial: void 0\n      };\n      this.setOptions(options);\n      this.errorReason = null;\n      this._requestedFlags = null;\n      this._mode = null;\n      this._attachResume = false;\n      this._decodingContext = {\n        channelOptions: this.channelOptions,\n        plugins: client.options.plugins || {},\n        baseEncodedPreviousPayload: void 0\n      };\n      this._lastPayload = {\n        messageId: null,\n        protocolMessageChannelSerial: null,\n        decodeFailureRecoveryInProgress: null\n      };\n      this._allChannelChanges = new eventemitter_default();\n    }\n    get presence() {\n      if (!this._presence) {\n        throwMissingPluginError(\"RealtimePresence\");\n      }\n      return this._presence;\n    }\n    invalidStateError() {\n      return new ErrorInfo(\"Channel operation failed as channel state is \" + this.state, 90001, 400, this.errorReason || void 0);\n    }\n    static processListenerArgs(args) {\n      args = Array.prototype.slice.call(args);\n      if (typeof args[0] === \"function\") {\n        args.unshift(null);\n      }\n      return args;\n    }\n    async setOptions(options) {\n      var _a2;\n      const previousChannelOptions = this.channelOptions;\n      const err = validateChannelOptions(options);\n      if (err) {\n        throw err;\n      }\n      this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, options);\n      if (this._decodingContext) this._decodingContext.channelOptions = this.channelOptions;\n      if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\n        this.attachImpl();\n        return new Promise((resolve, reject) => {\n          this._allChannelChanges.once([\"attached\", \"update\", \"detached\", \"failed\"], function (stateChange) {\n            switch (this.event) {\n              case \"update\":\n              case \"attached\":\n                resolve();\n                break;\n              default:\n                reject(stateChange.reason);\n            }\n          });\n        });\n      }\n    }\n    _shouldReattachToSetOptions(options, prevOptions) {\n      if (!(this.state === \"attached\" || this.state === \"attaching\")) {\n        return false;\n      }\n      if (options == null ? void 0 : options.params) {\n        const requestedParams = omitAgent(options.params);\n        const existingParams = omitAgent(prevOptions.params);\n        if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\n          return true;\n        }\n        if (!shallowEquals(existingParams, requestedParams)) {\n          return true;\n        }\n      }\n      if (options == null ? void 0 : options.modes) {\n        if (!prevOptions.modes || !arrEquals(options.modes, prevOptions.modes)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    async publish(...args) {\n      let messages = args[0];\n      let argCount = args.length;\n      if (!this.connectionManager.activeState()) {\n        throw this.connectionManager.getError();\n      }\n      if (argCount == 1) {\n        if (isObject(messages)) messages = [fromValues(messages)];else if (Array.isArray(messages)) messages = fromValuesArray(messages);else throw new ErrorInfo(\"The single-argument form of publish() expects a message object or an array of message objects\", 40013, 400);\n      } else {\n        messages = [fromValues({\n          name: args[0],\n          data: args[1]\n        })];\n      }\n      const maxMessageSize = this.client.options.maxMessageSize;\n      await encodeArray(messages, this.channelOptions);\n      const size = getMessagesSize(messages);\n      if (size > maxMessageSize) {\n        throw new ErrorInfo(\"Maximum size of messages that can be published at once exceeded ( was \" + size + \" bytes; limit is \" + maxMessageSize + \" bytes)\", 40009, 400);\n      }\n      return new Promise((resolve, reject) => {\n        this._publish(messages, err => err ? reject(err) : resolve());\n      });\n    }\n    _publish(messages, callback) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"RealtimeChannel.publish()\", \"message count = \" + messages.length);\n      const state = this.state;\n      switch (state) {\n        case \"failed\":\n        case \"suspended\":\n          callback(ErrorInfo.fromValues(this.invalidStateError()));\n          break;\n        default:\n          {\n            logger_default.logAction(logger_default.LOG_MICRO, \"RealtimeChannel.publish()\", \"sending message; channel state is \" + state);\n            const msg = new protocolmessage_default();\n            msg.action = actions2.MESSAGE;\n            msg.channel = this.name;\n            msg.messages = messages;\n            this.sendMessage(msg, callback);\n            break;\n          }\n      }\n    }\n    onEvent(messages) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"RealtimeChannel.onEvent()\", \"received message\");\n      const subscriptions = this.subscriptions;\n      for (let i = 0; i < messages.length; i++) {\n        const message = messages[i];\n        subscriptions.emit(message.name, message);\n      }\n    }\n    async attach() {\n      if (this.state === \"attached\") {\n        return null;\n      }\n      return new Promise((resolve, reject) => {\n        this._attach(false, null, (err, result) => err ? reject(err) : resolve(result));\n      });\n    }\n    _attach(forceReattach, attachReason, callback) {\n      if (!callback) {\n        callback = function (err) {\n          if (err) {\n            logger_default.logAction(logger_default.LOG_ERROR, \"RealtimeChannel._attach()\", \"Channel attach failed: \" + err.toString());\n          }\n        };\n      }\n      const connectionManager = this.connectionManager;\n      if (!connectionManager.activeState()) {\n        callback(connectionManager.getError());\n        return;\n      }\n      if (this.state !== \"attaching\" || forceReattach) {\n        this.requestState(\"attaching\", attachReason);\n      }\n      this.once(function (stateChange) {\n        switch (this.event) {\n          case \"attached\":\n            callback == null ? void 0 : callback(null, stateChange);\n            break;\n          case \"detached\":\n          case \"suspended\":\n          case \"failed\":\n            callback == null ? void 0 : callback(stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to attach; reason unknown; state = \" + this.event, 9e4, 500));\n            break;\n          case \"detaching\":\n            callback == null ? void 0 : callback(new ErrorInfo(\"Attach request superseded by a subsequent detach request\", 9e4, 409));\n            break;\n        }\n      });\n    }\n    attachImpl() {\n      logger_default.logAction(logger_default.LOG_MICRO, \"RealtimeChannel.attachImpl()\", \"sending ATTACH message\");\n      const attachMsg = fromValues3({\n        action: actions2.ATTACH,\n        channel: this.name,\n        params: this.channelOptions.params,\n        // RTL4c1: Includes the channel serial to resume from a previous message\n        // or attachment.\n        channelSerial: this.properties.channelSerial\n      });\n      if (this._requestedFlags) {\n        attachMsg.encodeModesToFlags(this._requestedFlags);\n      } else if (this.channelOptions.modes) {\n        attachMsg.encodeModesToFlags(allToUpperCase(this.channelOptions.modes));\n      }\n      if (this._attachResume) {\n        attachMsg.setFlag(\"ATTACH_RESUME\");\n      }\n      if (this._lastPayload.decodeFailureRecoveryInProgress) {\n        attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\n      }\n      this.sendMessage(attachMsg, noop2);\n    }\n    async detach() {\n      const connectionManager = this.connectionManager;\n      if (!connectionManager.activeState()) {\n        throw connectionManager.getError();\n      }\n      switch (this.state) {\n        case \"suspended\":\n          this.notifyState(\"detached\");\n          return;\n        case \"detached\":\n          return;\n        case \"failed\":\n          throw new ErrorInfo(\"Unable to detach; channel state = failed\", 90001, 400);\n        default:\n          this.requestState(\"detaching\");\n        case \"detaching\":\n          return new Promise((resolve, reject) => {\n            this.once(function (stateChange) {\n              switch (this.event) {\n                case \"detached\":\n                  resolve();\n                  break;\n                case \"attached\":\n                case \"suspended\":\n                case \"failed\":\n                  reject(stateChange.reason || connectionManager.getError() || new ErrorInfo(\"Unable to detach; reason unknown; state = \" + this.event, 9e4, 500));\n                  break;\n                case \"attaching\":\n                  reject(new ErrorInfo(\"Detach request superseded by a subsequent attach request\", 9e4, 409));\n                  break;\n              }\n            });\n          });\n      }\n    }\n    detachImpl(callback) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"RealtimeChannel.detach()\", \"sending DETACH message\");\n      const msg = fromValues3({\n        action: actions2.DETACH,\n        channel: this.name\n      });\n      this.sendMessage(msg, callback || noop2);\n    }\n    async subscribe(...args) {\n      const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n      if (this.state === \"failed\") {\n        throw ErrorInfo.fromValues(this.invalidStateError());\n      }\n      if (event && typeof event === \"object\" && !Array.isArray(event)) {\n        this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);\n      } else {\n        this.subscriptions.on(event, listener);\n      }\n      return this.attach();\n    }\n    unsubscribe(...args) {\n      var _a2;\n      const [event, listener] = _RealtimeChannel.processListenerArgs(args);\n      if (typeof event === \"object\" && !listener || ((_a2 = this.filteredSubscriptions) == null ? void 0 : _a2.has(listener))) {\n        this.client._FilteredSubscriptions.getAndDeleteFilteredSubscriptions(this, event, listener).forEach(l => this.subscriptions.off(l));\n        return;\n      }\n      this.subscriptions.off(event, listener);\n    }\n    sync() {\n      switch (this.state) {\n        case \"initialized\":\n        case \"detaching\":\n        case \"detached\":\n          throw new PartialErrorInfo(\"Unable to sync to channel; not attached\", 4e4);\n        default:\n      }\n      const connectionManager = this.connectionManager;\n      if (!connectionManager.activeState()) {\n        throw connectionManager.getError();\n      }\n      const syncMessage = fromValues3({\n        action: actions2.SYNC,\n        channel: this.name\n      });\n      if (this.syncChannelSerial) {\n        syncMessage.channelSerial = this.syncChannelSerial;\n      }\n      connectionManager.send(syncMessage);\n    }\n    sendMessage(msg, callback) {\n      this.connectionManager.send(msg, this.client.options.queueMessages, callback);\n    }\n    sendPresence(presence, callback) {\n      const msg = fromValues3({\n        action: actions2.PRESENCE,\n        channel: this.name,\n        presence: Array.isArray(presence) ? this.client._RealtimePresence.presenceMessagesFromValuesArray(presence) : [this.client._RealtimePresence.presenceMessageFromValues(presence)]\n      });\n      this.sendMessage(msg, callback);\n    }\n    // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.\n    async processMessage(message) {\n      if (message.action === actions2.ATTACHED || message.action === actions2.MESSAGE || message.action === actions2.PRESENCE) {\n        this.setChannelSerial(message.channelSerial);\n      }\n      let syncChannelSerial,\n        isSync = false;\n      switch (message.action) {\n        case actions2.ATTACHED:\n          {\n            this.properties.attachSerial = message.channelSerial;\n            this._mode = message.getMode();\n            this.params = message.params || {};\n            const modesFromFlags = message.decodeModesFromFlags();\n            this.modes = modesFromFlags && allToLowerCase(modesFromFlags) || void 0;\n            const resumed = message.hasFlag(\"RESUMED\");\n            const hasPresence = message.hasFlag(\"HAS_PRESENCE\");\n            const hasBacklog = message.hasFlag(\"HAS_BACKLOG\");\n            if (this.state === \"attached\") {\n              if (!resumed) {\n                if (this._presence) {\n                  this._presence.onAttached(hasPresence);\n                }\n              }\n              const change = new channelstatechange_default(this.state, this.state, resumed, hasBacklog, message.error);\n              this._allChannelChanges.emit(\"update\", change);\n              if (!resumed || this.channelOptions.updateOnAttached) {\n                this.emit(\"update\", change);\n              }\n            } else if (this.state === \"detaching\") {\n              this.checkPendingState();\n            } else {\n              this.notifyState(\"attached\", message.error, resumed, hasPresence, hasBacklog);\n            }\n            break;\n          }\n        case actions2.DETACHED:\n          {\n            const detachErr = message.error ? ErrorInfo.fromValues(message.error) : new ErrorInfo(\"Channel detached\", 90001, 404);\n            if (this.state === \"detaching\") {\n              this.notifyState(\"detached\", detachErr);\n            } else if (this.state === \"attaching\") {\n              this.notifyState(\"suspended\", detachErr);\n            } else {\n              this.requestState(\"attaching\", detachErr);\n            }\n            break;\n          }\n        case actions2.SYNC:\n          isSync = true;\n          syncChannelSerial = this.syncChannelSerial = message.channelSerial;\n          if (!message.presence) break;\n        case actions2.PRESENCE:\n          {\n            const presence = message.presence;\n            if (!presence) {\n              break;\n            }\n            const {\n              id,\n              connectionId,\n              timestamp\n            } = message;\n            const options = this.channelOptions;\n            let presenceMsg;\n            for (let i = 0; i < presence.length; i++) {\n              try {\n                presenceMsg = presence[i];\n                await decode2(presenceMsg, options);\n                if (!presenceMsg.connectionId) presenceMsg.connectionId = connectionId;\n                if (!presenceMsg.timestamp) presenceMsg.timestamp = timestamp;\n                if (!presenceMsg.id) presenceMsg.id = id + \":\" + i;\n              } catch (e) {\n                logger_default.logAction(logger_default.LOG_ERROR, \"RealtimeChannel.processMessage()\", e.toString());\n              }\n            }\n            if (this._presence) {\n              this._presence.setPresence(presence, isSync, syncChannelSerial);\n            }\n            break;\n          }\n        case actions2.MESSAGE:\n          {\n            if (this.state !== \"attached\") {\n              logger_default.logAction(logger_default.LOG_MAJOR, \"RealtimeChannel.processMessage()\", 'Message \"' + message.id + '\" skipped as this channel \"' + this.name + '\" state is not \"attached\" (state is \"' + this.state + '\").');\n              return;\n            }\n            const messages = message.messages,\n              firstMessage = messages[0],\n              lastMessage = messages[messages.length - 1],\n              id = message.id,\n              connectionId = message.connectionId,\n              timestamp = message.timestamp;\n            if (firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {\n              const msg = 'Delta message decode failure - previous message not available for message \"' + message.id + '\" on this channel \"' + this.name + '\".';\n              logger_default.logAction(logger_default.LOG_ERROR, \"RealtimeChannel.processMessage()\", msg);\n              this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));\n              break;\n            }\n            for (let i = 0; i < messages.length; i++) {\n              const msg = messages[i];\n              try {\n                await decode(msg, this._decodingContext);\n              } catch (e) {\n                logger_default.logAction(logger_default.LOG_ERROR, \"RealtimeChannel.processMessage()\", e.toString());\n                switch (e.code) {\n                  case 40018:\n                    this._startDecodeFailureRecovery(e);\n                    return;\n                  case 40019:\n                  case 40021:\n                    this.notifyState(\"failed\", e);\n                    return;\n                }\n              }\n              if (!msg.connectionId) msg.connectionId = connectionId;\n              if (!msg.timestamp) msg.timestamp = timestamp;\n              if (!msg.id) msg.id = id + \":\" + i;\n            }\n            this._lastPayload.messageId = lastMessage.id;\n            this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\n            this.onEvent(messages);\n            break;\n          }\n        case actions2.ERROR:\n          {\n            const err = message.error;\n            if (err && err.code == 80016) {\n              this.checkPendingState();\n            } else {\n              this.notifyState(\"failed\", ErrorInfo.fromValues(err));\n            }\n            break;\n          }\n        default:\n          logger_default.logAction(logger_default.LOG_ERROR, \"RealtimeChannel.processMessage()\", \"Fatal protocol error: unrecognised action (\" + message.action + \")\");\n          this.connectionManager.abort(connectionerrors_default.unknownChannelErr());\n      }\n    }\n    _startDecodeFailureRecovery(reason) {\n      if (!this._lastPayload.decodeFailureRecoveryInProgress) {\n        logger_default.logAction(logger_default.LOG_MAJOR, \"RealtimeChannel.processMessage()\", \"Starting decode failure recovery process.\");\n        this._lastPayload.decodeFailureRecoveryInProgress = true;\n        this._attach(true, reason, () => {\n          this._lastPayload.decodeFailureRecoveryInProgress = false;\n        });\n      }\n    }\n    onAttached() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"RealtimeChannel.onAttached\", \"activating channel; name = \" + this.name);\n    }\n    notifyState(state, reason, resumed, hasPresence, hasBacklog) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"RealtimeChannel.notifyState\", \"name = \" + this.name + \", current state = \" + this.state + \", notifying state \" + state);\n      this.clearStateTimer();\n      if ([\"detached\", \"suspended\", \"failed\"].includes(state)) {\n        this.properties.channelSerial = null;\n      }\n      if (state === this.state) {\n        return;\n      }\n      if (this._presence) {\n        this._presence.actOnChannelState(state, hasPresence, reason);\n      }\n      if (state === \"suspended\" && this.connectionManager.state.sendEvents) {\n        this.startRetryTimer();\n      } else {\n        this.cancelRetryTimer();\n      }\n      if (reason) {\n        this.errorReason = reason;\n      }\n      const change = new channelstatechange_default(this.state, state, resumed, hasBacklog, reason);\n      const action = 'Channel state for channel \"' + this.name + '\"';\n      const message = state + (reason ? \"; reason: \" + reason : \"\");\n      if (state === \"failed\") {\n        logger_default.logAction(logger_default.LOG_ERROR, action, message);\n      } else {\n        logger_default.logAction(logger_default.LOG_MAJOR, action, message);\n      }\n      if (state !== \"attaching\" && state !== \"suspended\") {\n        this.retryCount = 0;\n      }\n      if (state === \"attached\") {\n        this.onAttached();\n      }\n      if (state === \"attached\") {\n        this._attachResume = true;\n      } else if (state === \"detaching\" || state === \"failed\") {\n        this._attachResume = false;\n      }\n      this.state = state;\n      this._allChannelChanges.emit(state, change);\n      this.emit(state, change);\n    }\n    requestState(state, reason) {\n      logger_default.logAction(logger_default.LOG_MINOR, \"RealtimeChannel.requestState\", \"name = \" + this.name + \", state = \" + state);\n      this.notifyState(state, reason);\n      this.checkPendingState();\n    }\n    checkPendingState() {\n      const cmState = this.connectionManager.state;\n      if (!cmState.sendEvents) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"RealtimeChannel.checkPendingState\", \"sendEvents is false; state is \" + this.connectionManager.state.state);\n        return;\n      }\n      logger_default.logAction(logger_default.LOG_MINOR, \"RealtimeChannel.checkPendingState\", \"name = \" + this.name + \", state = \" + this.state);\n      switch (this.state) {\n        case \"attaching\":\n          this.startStateTimerIfNotRunning();\n          this.attachImpl();\n          break;\n        case \"detaching\":\n          this.startStateTimerIfNotRunning();\n          this.detachImpl();\n          break;\n        case \"attached\":\n          this.sync();\n          break;\n        default:\n          break;\n      }\n    }\n    timeoutPendingState() {\n      switch (this.state) {\n        case \"attaching\":\n          {\n            const err = new ErrorInfo(\"Channel attach timed out\", 90007, 408);\n            this.notifyState(\"suspended\", err);\n            break;\n          }\n        case \"detaching\":\n          {\n            const err = new ErrorInfo(\"Channel detach timed out\", 90007, 408);\n            this.notifyState(\"attached\", err);\n            break;\n          }\n        default:\n          this.checkPendingState();\n          break;\n      }\n    }\n    startStateTimerIfNotRunning() {\n      if (!this.stateTimer) {\n        this.stateTimer = setTimeout(() => {\n          logger_default.logAction(logger_default.LOG_MINOR, \"RealtimeChannel.startStateTimerIfNotRunning\", \"timer expired\");\n          this.stateTimer = null;\n          this.timeoutPendingState();\n        }, this.client.options.timeouts.realtimeRequestTimeout);\n      }\n    }\n    clearStateTimer() {\n      const stateTimer = this.stateTimer;\n      if (stateTimer) {\n        clearTimeout(stateTimer);\n        this.stateTimer = null;\n      }\n    }\n    startRetryTimer() {\n      if (this.retryTimer) return;\n      this.retryCount++;\n      const retryDelay = getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);\n      this.retryTimer = setTimeout(() => {\n        if (this.state === \"suspended\" && this.connectionManager.state.sendEvents) {\n          this.retryTimer = null;\n          logger_default.logAction(logger_default.LOG_MINOR, \"RealtimeChannel retry timer expired\", \"attempting a new attach\");\n          this.requestState(\"attaching\");\n        }\n      }, retryDelay);\n    }\n    cancelRetryTimer() {\n      if (this.retryTimer) {\n        clearTimeout(this.retryTimer);\n        this.retryTimer = null;\n      }\n    }\n    /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\n    getReleaseErr() {\n      const s = this.state;\n      if (s === \"initialized\" || s === \"detached\" || s === \"failed\") {\n        return null;\n      }\n      return new ErrorInfo(\"Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was \" + s, 90001, 400);\n    }\n    setChannelSerial(channelSerial) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"RealtimeChannel.setChannelSerial()\", \"Updating channel serial; serial = \" + channelSerial + \"; previous = \" + this.properties.channelSerial);\n      if (channelSerial) {\n        this.properties.channelSerial = channelSerial;\n      }\n    }\n    async status() {\n      return this.client.rest.channelMixin.status(this);\n    }\n  };\n  function omitAgent(channelParams) {\n    const _a2 = channelParams || {},\n      {\n        agent: _\n      } = _a2,\n      paramsWithoutAgent = __objRest(_a2, [\"agent\"]);\n    return paramsWithoutAgent;\n  }\n  var realtimechannel_default = RealtimeChannel;\n\n  // src/common/lib/client/baserealtime.ts\n  var BaseRealtime = class _BaseRealtime extends baseclient_default {\n    /*\n     * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\n     *\n     * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\n     * 2. passes no argument at all\n     *\n     * tell the compiler that these cases are possible so that it forces us to handle them.\n     */\n    constructor(options) {\n      var _a2, _b;\n      super(defaults_default.objectifyOptions(options, false, \"BaseRealtime\"));\n      logger_default.logAction(logger_default.LOG_MINOR, \"Realtime()\", \"\");\n      this._additionalTransportImplementations = _BaseRealtime.transportImplementationsFromPlugins(this.options.plugins);\n      this._RealtimePresence = (_b = (_a2 = this.options.plugins) == null ? void 0 : _a2.RealtimePresence) != null ? _b : null;\n      this.connection = new connection_default(this, this.options);\n      this._channels = new Channels2(this);\n      if (this.options.autoConnect !== false) this.connect();\n    }\n    static transportImplementationsFromPlugins(plugins) {\n      const transports = {};\n      if (plugins == null ? void 0 : plugins.WebSocketTransport) {\n        transports[TransportNames.WebSocket] = plugins.WebSocketTransport;\n      }\n      if (plugins == null ? void 0 : plugins.XHRPolling) {\n        transports[TransportNames.XhrPolling] = plugins.XHRPolling;\n      }\n      return transports;\n    }\n    get channels() {\n      return this._channels;\n    }\n    connect() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"Realtime.connect()\", \"\");\n      this.connection.connect();\n    }\n    close() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"Realtime.close()\", \"\");\n      this.connection.close();\n    }\n  };\n  var Channels2 = class extends eventemitter_default {\n    constructor(realtime) {\n      super();\n      this.realtime = realtime;\n      this.all = /* @__PURE__ */Object.create(null);\n      realtime.connection.connectionManager.on(\"transport.active\", () => {\n        this.onTransportActive();\n      });\n    }\n    channelSerials() {\n      let serials = {};\n      for (const name of keysArray(this.all, true)) {\n        const channel = this.all[name];\n        if (channel.properties.channelSerial) {\n          serials[name] = channel.properties.channelSerial;\n        }\n      }\n      return serials;\n    }\n    // recoverChannels gets the given channels and sets their channel serials.\n    recoverChannels(channelSerials) {\n      for (const name of keysArray(channelSerials, true)) {\n        const channel = this.get(name);\n        channel.properties.channelSerial = channelSerials[name];\n      }\n    }\n    // Access to this method is synchronised by ConnectionManager#processChannelMessage.\n    async processChannelMessage(msg) {\n      const channelName = msg.channel;\n      if (channelName === void 0) {\n        logger_default.logAction(logger_default.LOG_ERROR, \"Channels.processChannelMessage()\", \"received event unspecified channel, action = \" + msg.action);\n        return;\n      }\n      const channel = this.all[channelName];\n      if (!channel) {\n        logger_default.logAction(logger_default.LOG_ERROR, \"Channels.processChannelMessage()\", \"received event for non-existent channel: \" + channelName);\n        return;\n      }\n      await channel.processMessage(msg);\n    }\n    /* called when a transport becomes connected; reattempt attach/detach\n     * for channels that are attaching or detaching. */\n    onTransportActive() {\n      for (const channelName in this.all) {\n        const channel = this.all[channelName];\n        if (channel.state === \"attaching\" || channel.state === \"detaching\") {\n          channel.checkPendingState();\n        } else if (channel.state === \"suspended\") {\n          channel._attach(false, null);\n        } else if (channel.state === \"attached\") {\n          channel.requestState(\"attaching\");\n        }\n      }\n    }\n    /* Connection interruptions (ie when the connection will no longer queue\n     * events) imply connection state changes for any channel which is either\n     * attached, pending, or will attempt to become attached in the future */\n    propogateConnectionInterruption(connectionState, reason) {\n      const connectionStateToChannelState = {\n        closing: \"detached\",\n        closed: \"detached\",\n        failed: \"failed\",\n        suspended: \"suspended\"\n      };\n      const fromChannelStates = [\"attaching\", \"attached\", \"detaching\", \"suspended\"];\n      const toChannelState = connectionStateToChannelState[connectionState];\n      for (const channelId in this.all) {\n        const channel = this.all[channelId];\n        if (fromChannelStates.includes(channel.state)) {\n          channel.notifyState(toChannelState, reason);\n        }\n      }\n    }\n    get(name, channelOptions) {\n      name = String(name);\n      let channel = this.all[name];\n      if (!channel) {\n        channel = this.all[name] = new realtimechannel_default(this.realtime, name, channelOptions);\n      } else if (channelOptions) {\n        if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\n          throw new ErrorInfo(\"Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.\", 4e4, 400);\n        }\n        channel.setOptions(channelOptions);\n      }\n      return channel;\n    }\n    getDerived(name, deriveOptions, channelOptions) {\n      if (deriveOptions.filter) {\n        const filter = toBase64(deriveOptions.filter);\n        const match = matchDerivedChannel(name);\n        name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;\n      }\n      return this.get(name, channelOptions);\n    }\n    /* Included to support certain niche use-cases; most users should ignore this.\n     * Please do not use this unless you know what you're doing */\n    release(name) {\n      name = String(name);\n      const channel = this.all[name];\n      if (!channel) {\n        return;\n      }\n      const releaseErr = channel.getReleaseErr();\n      if (releaseErr) {\n        throw releaseErr;\n      }\n      delete this.all[name];\n    }\n  };\n  var baserealtime_default = BaseRealtime;\n\n  // src/common/lib/client/realtimepresence.ts\n  function getClientId(realtimePresence) {\n    return realtimePresence.channel.client.auth.clientId;\n  }\n  function isAnonymousOrWildcard(realtimePresence) {\n    const realtime = realtimePresence.channel.client;\n    const clientId = realtime.auth.clientId;\n    return (!clientId || clientId === \"*\") && realtime.connection.state === \"connected\";\n  }\n  function waitAttached(channel, callback, action) {\n    switch (channel.state) {\n      case \"attached\":\n      case \"suspended\":\n        action();\n        break;\n      case \"initialized\":\n      case \"detached\":\n      case \"detaching\":\n      case \"attaching\":\n        whenPromiseSettles(channel.attach(), function (err) {\n          if (err) callback(err);else action();\n        });\n        break;\n      default:\n        callback(ErrorInfo.fromValues(channel.invalidStateError()));\n    }\n  }\n  function newerThan(item, existing) {\n    if (item.isSynthesized() || existing.isSynthesized()) {\n      return item.timestamp >= existing.timestamp;\n    }\n    const itemOrderings = item.parseId(),\n      existingOrderings = existing.parseId();\n    if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\n      return itemOrderings.index > existingOrderings.index;\n    } else {\n      return itemOrderings.msgSerial > existingOrderings.msgSerial;\n    }\n  }\n  var RealtimePresence = class extends eventemitter_default {\n    constructor(channel) {\n      super();\n      this.channel = channel;\n      this.syncComplete = false;\n      this.members = new PresenceMap(this, item => item.clientId + \":\" + item.connectionId);\n      this._myMembers = new PresenceMap(this, item => item.clientId);\n      this.subscriptions = new eventemitter_default();\n      this.pendingPresence = [];\n    }\n    async enter(data) {\n      if (isAnonymousOrWildcard(this)) {\n        throw new ErrorInfo(\"clientId must be specified to enter a presence channel\", 40012, 400);\n      }\n      return this._enterOrUpdateClient(void 0, void 0, data, \"enter\");\n    }\n    async update(data) {\n      if (isAnonymousOrWildcard(this)) {\n        throw new ErrorInfo(\"clientId must be specified to update presence data\", 40012, 400);\n      }\n      return this._enterOrUpdateClient(void 0, void 0, data, \"update\");\n    }\n    async enterClient(clientId, data) {\n      return this._enterOrUpdateClient(void 0, clientId, data, \"enter\");\n    }\n    async updateClient(clientId, data) {\n      return this._enterOrUpdateClient(void 0, clientId, data, \"update\");\n    }\n    async _enterOrUpdateClient(id, clientId, data, action) {\n      const channel = this.channel;\n      if (!channel.connectionManager.activeState()) {\n        throw channel.connectionManager.getError();\n      }\n      logger_default.logAction(logger_default.LOG_MICRO, \"RealtimePresence.\" + action + \"Client()\", \"channel = \" + channel.name + \", id = \" + id + \", client = \" + (clientId || \"(implicit) \" + getClientId(this)));\n      const presence = fromData(data);\n      presence.action = action;\n      if (id) {\n        presence.id = id;\n      }\n      if (clientId) {\n        presence.clientId = clientId;\n      }\n      await encode(presence, channel.channelOptions);\n      switch (channel.state) {\n        case \"attached\":\n          return new Promise((resolve, reject) => {\n            channel.sendPresence(presence, err => err ? reject(err) : resolve());\n          });\n        case \"initialized\":\n        case \"detached\":\n          channel.attach();\n        case \"attaching\":\n          return new Promise((resolve, reject) => {\n            this.pendingPresence.push({\n              presence,\n              callback: err => err ? reject(err) : resolve()\n            });\n          });\n        default:\n          {\n            const err = new PartialErrorInfo(\"Unable to \" + action + \" presence channel while in \" + channel.state + \" state\", 90001);\n            err.code = 90001;\n            throw err;\n          }\n      }\n    }\n    async leave(data) {\n      if (isAnonymousOrWildcard(this)) {\n        throw new ErrorInfo(\"clientId must have been specified to enter or leave a presence channel\", 40012, 400);\n      }\n      return this.leaveClient(void 0, data);\n    }\n    async leaveClient(clientId, data) {\n      const channel = this.channel;\n      if (!channel.connectionManager.activeState()) {\n        throw channel.connectionManager.getError();\n      }\n      logger_default.logAction(logger_default.LOG_MICRO, \"RealtimePresence.leaveClient()\", \"leaving; channel = \" + this.channel.name + \", client = \" + clientId);\n      const presence = fromData(data);\n      presence.action = \"leave\";\n      if (clientId) {\n        presence.clientId = clientId;\n      }\n      return new Promise((resolve, reject) => {\n        switch (channel.state) {\n          case \"attached\":\n            channel.sendPresence(presence, err => err ? reject(err) : resolve());\n            break;\n          case \"attaching\":\n            this.pendingPresence.push({\n              presence,\n              callback: err => err ? reject(err) : resolve()\n            });\n            break;\n          case \"initialized\":\n          case \"failed\":\n            {\n              const err = new PartialErrorInfo(\"Unable to leave presence channel (incompatible state)\", 90001);\n              reject(err);\n              break;\n            }\n          default:\n            reject(channel.invalidStateError());\n        }\n      });\n    }\n    async get(params) {\n      const waitForSync = !params || (\"waitForSync\" in params ? params.waitForSync : true);\n      return new Promise((resolve, reject) => {\n        function returnMembers(members) {\n          resolve(params ? members.list(params) : members.values());\n        }\n        if (this.channel.state === \"suspended\") {\n          if (waitForSync) {\n            reject(ErrorInfo.fromValues({\n              statusCode: 400,\n              code: 91005,\n              message: \"Presence state is out of sync due to channel being in the SUSPENDED state\"\n            }));\n          } else {\n            returnMembers(this.members);\n          }\n          return;\n        }\n        waitAttached(this.channel, err => reject(err), () => {\n          const members = this.members;\n          if (waitForSync) {\n            members.waitSync(function () {\n              returnMembers(members);\n            });\n          } else {\n            returnMembers(members);\n          }\n        });\n      });\n    }\n    async history(params) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"RealtimePresence.history()\", \"channel = \" + this.name);\n      const restMixin = this.channel.client.rest.presenceMixin;\n      if (params && params.untilAttach) {\n        if (this.channel.state === \"attached\") {\n          delete params.untilAttach;\n          params.from_serial = this.channel.properties.attachSerial;\n        } else {\n          throw new ErrorInfo(\"option untilAttach requires the channel to be attached, was: \" + this.channel.state, 4e4, 400);\n        }\n      }\n      return restMixin.history(this, params);\n    }\n    setPresence(presenceSet, isSync, syncChannelSerial) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"RealtimePresence.setPresence()\", \"received presence for \" + presenceSet.length + \" participants; syncChannelSerial = \" + syncChannelSerial);\n      let syncCursor, match;\n      const members = this.members,\n        myMembers = this._myMembers,\n        broadcastMessages = [],\n        connId = this.channel.connectionManager.connectionId;\n      if (isSync) {\n        this.members.startSync();\n        if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\n          syncCursor = match[1];\n        }\n      }\n      for (let i = 0; i < presenceSet.length; i++) {\n        const presence = fromValues2(presenceSet[i]);\n        switch (presence.action) {\n          case \"leave\":\n            if (members.remove(presence)) {\n              broadcastMessages.push(presence);\n            }\n            if (presence.connectionId === connId && !presence.isSynthesized()) {\n              myMembers.remove(presence);\n            }\n            break;\n          case \"enter\":\n          case \"present\":\n          case \"update\":\n            if (members.put(presence)) {\n              broadcastMessages.push(presence);\n            }\n            if (presence.connectionId === connId) {\n              myMembers.put(presence);\n            }\n            break;\n        }\n      }\n      if (isSync && !syncCursor) {\n        members.endSync();\n        this.channel.syncChannelSerial = null;\n      }\n      for (let i = 0; i < broadcastMessages.length; i++) {\n        const presence = broadcastMessages[i];\n        this.subscriptions.emit(presence.action, presence);\n      }\n    }\n    onAttached(hasPresence) {\n      logger_default.logAction(logger_default.LOG_MINOR, \"RealtimePresence.onAttached()\", \"channel = \" + this.channel.name + \", hasPresence = \" + hasPresence);\n      if (hasPresence) {\n        this.members.startSync();\n      } else {\n        this._synthesizeLeaves(this.members.values());\n        this.members.clear();\n      }\n      this._ensureMyMembersPresent();\n      const pendingPresence = this.pendingPresence,\n        pendingPresCount = pendingPresence.length;\n      if (pendingPresCount) {\n        this.pendingPresence = [];\n        const presenceArray = [];\n        const multicaster = multicaster_default.create();\n        logger_default.logAction(logger_default.LOG_MICRO, \"RealtimePresence.onAttached\", \"sending \" + pendingPresCount + \" queued presence messages\");\n        for (let i = 0; i < pendingPresCount; i++) {\n          const event = pendingPresence[i];\n          presenceArray.push(event.presence);\n          multicaster.push(event.callback);\n        }\n        this.channel.sendPresence(presenceArray, multicaster);\n      }\n    }\n    actOnChannelState(state, hasPresence, err) {\n      switch (state) {\n        case \"attached\":\n          this.onAttached(hasPresence);\n          break;\n        case \"detached\":\n        case \"failed\":\n          this._clearMyMembers();\n          this.members.clear();\n        case \"suspended\":\n          this.failPendingPresence(err);\n          break;\n      }\n    }\n    failPendingPresence(err) {\n      if (this.pendingPresence.length) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"RealtimeChannel.failPendingPresence\", \"channel; name = \" + this.channel.name + \", err = \" + inspectError(err));\n        for (let i = 0; i < this.pendingPresence.length; i++) try {\n          this.pendingPresence[i].callback(err);\n        } catch (e) {}\n        this.pendingPresence = [];\n      }\n    }\n    _clearMyMembers() {\n      this._myMembers.clear();\n    }\n    _ensureMyMembersPresent() {\n      const myMembers = this._myMembers,\n        reenterCb = err => {\n          if (err) {\n            const msg = \"Presence auto-re-enter failed: \" + err.toString();\n            const wrappedErr = new ErrorInfo(msg, 91004, 400);\n            logger_default.logAction(logger_default.LOG_ERROR, \"RealtimePresence._ensureMyMembersPresent()\", msg);\n            const change = new channelstatechange_default(this.channel.state, this.channel.state, true, false, wrappedErr);\n            this.channel.emit(\"update\", change);\n          }\n        };\n      for (const memberKey in myMembers.map) {\n        const entry = myMembers.map[memberKey];\n        logger_default.logAction(logger_default.LOG_MICRO, \"RealtimePresence._ensureMyMembersPresent()\", 'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set');\n        whenPromiseSettles(this._enterOrUpdateClient(entry.id, entry.clientId, entry.data, \"enter\"), reenterCb);\n      }\n    }\n    _synthesizeLeaves(items) {\n      const subscriptions = this.subscriptions;\n      items.forEach(function (item) {\n        const presence = fromValues2({\n          action: \"leave\",\n          connectionId: item.connectionId,\n          clientId: item.clientId,\n          data: item.data,\n          encoding: item.encoding,\n          timestamp: Date.now()\n        });\n        subscriptions.emit(\"leave\", presence);\n      });\n    }\n    async subscribe(..._args) {\n      const args = realtimechannel_default.processListenerArgs(_args);\n      const event = args[0];\n      const listener = args[1];\n      const channel = this.channel;\n      if (channel.state === \"failed\") {\n        throw ErrorInfo.fromValues(channel.invalidStateError());\n      }\n      this.subscriptions.on(event, listener);\n      await channel.attach();\n    }\n    unsubscribe(..._args) {\n      const args = realtimechannel_default.processListenerArgs(_args);\n      const event = args[0];\n      const listener = args[1];\n      this.subscriptions.off(event, listener);\n    }\n  };\n  var PresenceMap = class extends eventemitter_default {\n    constructor(presence, memberKey) {\n      super();\n      this.presence = presence;\n      this.map = /* @__PURE__ */Object.create(null);\n      this.syncInProgress = false;\n      this.residualMembers = null;\n      this.memberKey = memberKey;\n    }\n    get(key) {\n      return this.map[key];\n    }\n    getClient(clientId) {\n      const map = this.map,\n        result = [];\n      for (const key in map) {\n        const item = map[key];\n        if (item.clientId == clientId && item.action != \"absent\") result.push(item);\n      }\n      return result;\n    }\n    list(params) {\n      const map = this.map,\n        clientId = params && params.clientId,\n        connectionId = params && params.connectionId,\n        result = [];\n      for (const key in map) {\n        const item = map[key];\n        if (item.action === \"absent\") continue;\n        if (clientId && clientId != item.clientId) continue;\n        if (connectionId && connectionId != item.connectionId) continue;\n        result.push(item);\n      }\n      return result;\n    }\n    put(item) {\n      if (item.action === \"enter\" || item.action === \"update\") {\n        item = fromValues2(item);\n        item.action = \"present\";\n      }\n      const map = this.map,\n        key = this.memberKey(item);\n      if (this.residualMembers) delete this.residualMembers[key];\n      const existingItem = map[key];\n      if (existingItem && !newerThan(item, existingItem)) {\n        return false;\n      }\n      map[key] = item;\n      return true;\n    }\n    values() {\n      const map = this.map,\n        result = [];\n      for (const key in map) {\n        const item = map[key];\n        if (item.action != \"absent\") result.push(item);\n      }\n      return result;\n    }\n    remove(item) {\n      const map = this.map,\n        key = this.memberKey(item);\n      const existingItem = map[key];\n      if (existingItem && !newerThan(item, existingItem)) {\n        return false;\n      }\n      if (this.syncInProgress) {\n        item = fromValues2(item);\n        item.action = \"absent\";\n        map[key] = item;\n      } else {\n        delete map[key];\n      }\n      return true;\n    }\n    startSync() {\n      const map = this.map,\n        syncInProgress = this.syncInProgress;\n      logger_default.logAction(logger_default.LOG_MINOR, \"PresenceMap.startSync()\", \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress);\n      if (!this.syncInProgress) {\n        this.residualMembers = copy(map);\n        this.setInProgress(true);\n      }\n    }\n    endSync() {\n      const map = this.map,\n        syncInProgress = this.syncInProgress;\n      logger_default.logAction(logger_default.LOG_MINOR, \"PresenceMap.endSync()\", \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress);\n      if (syncInProgress) {\n        for (const memberKey in map) {\n          const entry = map[memberKey];\n          if (entry.action === \"absent\") {\n            delete map[memberKey];\n          }\n        }\n        this.presence._synthesizeLeaves(valuesArray(this.residualMembers));\n        for (const memberKey in this.residualMembers) {\n          delete map[memberKey];\n        }\n        this.residualMembers = null;\n        this.setInProgress(false);\n      }\n      this.emit(\"sync\");\n    }\n    waitSync(callback) {\n      const syncInProgress = this.syncInProgress;\n      logger_default.logAction(logger_default.LOG_MINOR, \"PresenceMap.waitSync()\", \"channel = \" + this.presence.channel.name + \"; syncInProgress = \" + syncInProgress);\n      if (!syncInProgress) {\n        callback();\n        return;\n      }\n      this.once(\"sync\", callback);\n    }\n    clear() {\n      this.map = {};\n      this.setInProgress(false);\n      this.residualMembers = null;\n    }\n    setInProgress(inProgress) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"PresenceMap.setInProgress()\", \"inProgress = \" + inProgress);\n      this.syncInProgress = inProgress;\n      this.presence.syncComplete = !inProgress;\n    }\n  };\n  var realtimepresence_default = RealtimePresence;\n\n  // src/common/lib/transport/websockettransport.ts\n  var shortName = TransportNames.WebSocket;\n  function isNodeWebSocket(ws) {\n    return !!ws.on;\n  }\n  var WebSocketTransport = class extends transport_default {\n    constructor(connectionManager, auth, params) {\n      super(connectionManager, auth, params);\n      this.shortName = shortName;\n      params.heartbeats = Platform.Config.useProtocolHeartbeats;\n      this.wsHost = params.host;\n    }\n    static isAvailable() {\n      return !!Platform.Config.WebSocket;\n    }\n    createWebSocket(uri, connectParams) {\n      this.uri = uri + toQueryString(connectParams);\n      return new Platform.Config.WebSocket(this.uri);\n    }\n    toString() {\n      return \"WebSocketTransport; uri=\" + this.uri;\n    }\n    connect() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"starting\");\n      transport_default.prototype.connect.call(this);\n      const self2 = this,\n        params = this.params,\n        options = params.options;\n      const wsScheme = options.tls ? \"wss://\" : \"ws://\";\n      const wsUri = wsScheme + this.wsHost + \":\" + defaults_default.getPort(options) + \"/\";\n      logger_default.logAction(logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"uri: \" + wsUri);\n      whenPromiseSettles(this.auth.getAuthParams(), function (err, authParams) {\n        if (self2.isDisposed) {\n          return;\n        }\n        let paramStr = \"\";\n        for (const param in authParams) paramStr += \" \" + param + \": \" + authParams[param] + \";\";\n        logger_default.logAction(logger_default.LOG_MINOR, \"WebSocketTransport.connect()\", \"authParams:\" + paramStr + \" err: \" + err);\n        if (err) {\n          self2.disconnect(err);\n          return;\n        }\n        const connectParams = params.getConnectParams(authParams);\n        try {\n          const wsConnection = self2.wsConnection = self2.createWebSocket(wsUri, connectParams);\n          wsConnection.binaryType = Platform.Config.binaryType;\n          wsConnection.onopen = function () {\n            self2.onWsOpen();\n          };\n          wsConnection.onclose = function (ev) {\n            self2.onWsClose(ev);\n          };\n          wsConnection.onmessage = function (ev) {\n            self2.onWsData(ev.data);\n          };\n          wsConnection.onerror = function (ev) {\n            self2.onWsError(ev);\n          };\n          if (isNodeWebSocket(wsConnection)) {\n            wsConnection.on(\"ping\", function () {\n              self2.onActivity();\n            });\n          }\n        } catch (e) {\n          logger_default.logAction(logger_default.LOG_ERROR, \"WebSocketTransport.connect()\", \"Unexpected exception creating websocket: err = \" + (e.stack || e.message));\n          self2.disconnect(e);\n        }\n      });\n    }\n    send(message) {\n      const wsConnection = this.wsConnection;\n      if (!wsConnection) {\n        logger_default.logAction(logger_default.LOG_ERROR, \"WebSocketTransport.send()\", \"No socket connection\");\n        return;\n      }\n      try {\n        wsConnection.send(serialize2(message, this.connectionManager.realtime._MsgPack, this.params.format));\n      } catch (e) {\n        const msg = \"Exception from ws connection when trying to send: \" + inspectError(e);\n        logger_default.logAction(logger_default.LOG_ERROR, \"WebSocketTransport.send()\", msg);\n        this.finish(\"disconnected\", new ErrorInfo(msg, 5e4, 500));\n      }\n    }\n    onWsData(data) {\n      logger_default.logAction(logger_default.LOG_MICRO, \"WebSocketTransport.onWsData()\", \"data received; length = \" + data.length + \"; type = \" + typeof data);\n      try {\n        this.onProtocolMessage(deserialize(data, this.connectionManager.realtime._MsgPack, this.connectionManager.realtime._RealtimePresence, this.format));\n      } catch (e) {\n        logger_default.logAction(logger_default.LOG_ERROR, \"WebSocketTransport.onWsData()\", \"Unexpected exception handing channel message: \" + e.stack);\n      }\n    }\n    onWsOpen() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"WebSocketTransport.onWsOpen()\", \"opened WebSocket\");\n      this.emit(\"preconnect\");\n    }\n    onWsClose(ev) {\n      let wasClean, code;\n      if (typeof ev == \"object\") {\n        code = ev.code;\n        wasClean = ev.wasClean || code === 1e3;\n      } else {\n        code = ev;\n        wasClean = code == 1e3;\n      }\n      delete this.wsConnection;\n      if (wasClean) {\n        logger_default.logAction(logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", \"Cleanly closed WebSocket\");\n        const err = new ErrorInfo(\"Websocket closed\", 80003, 400);\n        this.finish(\"disconnected\", err);\n      } else {\n        const msg = \"Unclean disconnection of WebSocket ; code = \" + code,\n          err = new ErrorInfo(msg, 80003, 400);\n        logger_default.logAction(logger_default.LOG_MINOR, \"WebSocketTransport.onWsClose()\", msg);\n        this.finish(\"disconnected\", err);\n      }\n      this.emit(\"disposed\");\n    }\n    onWsError(err) {\n      logger_default.logAction(logger_default.LOG_MINOR, \"WebSocketTransport.onError()\", \"Error from WebSocket: \" + err.message);\n      Platform.Config.nextTick(() => {\n        this.disconnect(Error(err.message));\n      });\n    }\n    dispose() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"WebSocketTransport.dispose()\", \"\");\n      this.isDisposed = true;\n      const wsConnection = this.wsConnection;\n      if (wsConnection) {\n        wsConnection.onmessage = function () {};\n        delete this.wsConnection;\n        Platform.Config.nextTick(function () {\n          logger_default.logAction(logger_default.LOG_MICRO, \"WebSocketTransport.dispose()\", \"closing websocket\");\n          if (!wsConnection) {\n            throw new Error(\"WebSocketTransport.dispose(): wsConnection is not defined\");\n          }\n          wsConnection.close();\n        });\n      }\n    }\n  };\n  var websockettransport_default = WebSocketTransport;\n\n  // src/common/lib/client/filteredsubscriptions.ts\n  var FilteredSubscriptions = class {\n    static subscribeFilter(channel, filter, listener) {\n      const filteredListener = m => {\n        var _a2, _b, _c, _d, _e, _f;\n        const mapping = {\n          name: m.name,\n          refTimeserial: (_b = (_a2 = m.extras) == null ? void 0 : _a2.ref) == null ? void 0 : _b.timeserial,\n          refType: (_d = (_c = m.extras) == null ? void 0 : _c.ref) == null ? void 0 : _d.type,\n          isRef: !!((_f = (_e = m.extras) == null ? void 0 : _e.ref) == null ? void 0 : _f.timeserial),\n          clientId: m.clientId\n        };\n        if (Object.entries(filter).find(([key, value]) => value !== void 0 ? mapping[key] !== value : false)) {\n          return;\n        }\n        listener(m);\n      };\n      this.addFilteredSubscription(channel, filter, listener, filteredListener);\n      channel.subscriptions.on(filteredListener);\n    }\n    // Adds a new filtered subscription\n    static addFilteredSubscription(channel, filter, realListener, filteredListener) {\n      var _a2;\n      if (!channel.filteredSubscriptions) {\n        channel.filteredSubscriptions = /* @__PURE__ */new Map();\n      }\n      if (channel.filteredSubscriptions.has(realListener)) {\n        const realListenerMap = channel.filteredSubscriptions.get(realListener);\n        realListenerMap.set(filter, ((_a2 = realListenerMap == null ? void 0 : realListenerMap.get(filter)) == null ? void 0 : _a2.concat(filteredListener)) || [filteredListener]);\n      } else {\n        channel.filteredSubscriptions.set(realListener, /* @__PURE__ */new Map([[filter, [filteredListener]]]));\n      }\n    }\n    static getAndDeleteFilteredSubscriptions(channel, filter, realListener) {\n      if (!channel.filteredSubscriptions) {\n        return [];\n      }\n      if (!realListener && filter) {\n        return Array.from(channel.filteredSubscriptions.entries()).map(([key, filterMaps]) => {\n          var _a2;\n          let listenerMaps = filterMaps.get(filter);\n          filterMaps.delete(filter);\n          if (filterMaps.size === 0) {\n            (_a2 = channel.filteredSubscriptions) == null ? void 0 : _a2.delete(key);\n          }\n          return listenerMaps;\n        }).reduce((prev, cur) => cur ? prev.concat(...cur) : prev, []);\n      }\n      if (!realListener || !channel.filteredSubscriptions.has(realListener)) {\n        return [];\n      }\n      const realListenerMap = channel.filteredSubscriptions.get(realListener);\n      if (!filter) {\n        const listeners2 = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);\n        channel.filteredSubscriptions.delete(realListener);\n        return listeners2;\n      }\n      let listeners = realListenerMap.get(filter);\n      realListenerMap.delete(filter);\n      return listeners || [];\n    }\n  };\n\n  // src/common/lib/client/defaultrealtime.ts\n  var _DefaultRealtime = class _DefaultRealtime extends baserealtime_default {\n    // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\n    constructor(options) {\n      var _a2;\n      const MsgPack = _DefaultRealtime._MsgPack;\n      if (!MsgPack) {\n        throw new Error(\"Expected DefaultRealtime._MsgPack to have been set\");\n      }\n      super(defaults_default.objectifyOptions(options, true, \"Realtime\", __spreadProps(__spreadValues({}, allCommonModularPlugins), {\n        Crypto: (_a2 = _DefaultRealtime.Crypto) != null ? _a2 : void 0,\n        MsgPack,\n        RealtimePresence: {\n          RealtimePresence: realtimepresence_default,\n          presenceMessageFromValues: fromValues2,\n          presenceMessagesFromValuesArray: fromValuesArray2\n        },\n        WebSocketTransport: websockettransport_default,\n        MessageInteractions: FilteredSubscriptions\n      })));\n    }\n    static get Crypto() {\n      if (this._Crypto === null) {\n        throw new Error(\"Encryption not enabled; use ably.encryption.js instead\");\n      }\n      return this._Crypto;\n    }\n    static set Crypto(newValue) {\n      this._Crypto = newValue;\n    }\n  };\n  _DefaultRealtime.Utils = utils_exports;\n  _DefaultRealtime.ConnectionManager = connectionmanager_default;\n  _DefaultRealtime.ProtocolMessage = protocolmessage_default;\n  _DefaultRealtime._Crypto = null;\n  _DefaultRealtime.Message = DefaultMessage;\n  _DefaultRealtime.PresenceMessage = DefaultPresenceMessage;\n  _DefaultRealtime._MsgPack = null;\n  // Used by tests\n  _DefaultRealtime._Http = Http;\n  var DefaultRealtime = _DefaultRealtime;\n\n  // src/platform/web/lib/util/hmac-sha256.ts\n  var uint8Array = Uint8Array;\n  var uint32Array = Uint32Array;\n  var pow = Math.pow;\n  var DEFAULT_STATE = new uint32Array(8);\n  var ROUND_CONSTANTS = [];\n  var M = new uint32Array(64);\n  function getFractionalBits(n2) {\n    return (n2 - (n2 | 0)) * pow(2, 32) | 0;\n  }\n  var n = 2;\n  var nPrime = 0;\n  while (nPrime < 64) {\n    isPrime = true;\n    for (factor = 2; factor <= n / 2; factor++) {\n      if (n % factor === 0) {\n        isPrime = false;\n      }\n    }\n    if (isPrime) {\n      if (nPrime < 8) {\n        DEFAULT_STATE[nPrime] = getFractionalBits(pow(n, 1 / 2));\n      }\n      ROUND_CONSTANTS[nPrime] = getFractionalBits(pow(n, 1 / 3));\n      nPrime++;\n    }\n    n++;\n  }\n  var isPrime;\n  var factor;\n  var LittleEndian = !!new uint8Array(new uint32Array([1]).buffer)[0];\n  function convertEndian(word) {\n    if (LittleEndian) {\n      return (\n        // byte 1 -> byte 4\n        word >>> 24 |\n        // byte 2 -> byte 3\n        (word >>> 16 & 255) << 8 |\n        // byte 3 -> byte 2\n        (word & 65280) << 8 |\n        // byte 4 -> byte 1\n        word << 24\n      );\n    } else {\n      return word;\n    }\n  }\n  function rightRotate(word, bits) {\n    return word >>> bits | word << 32 - bits;\n  }\n  function sha256(data) {\n    var STATE = DEFAULT_STATE.slice();\n    var legth = data.length;\n    var bitLength = legth * 8;\n    var newBitLength = 512 - (bitLength + 64) % 512 - 1 + bitLength + 65;\n    var bytes = new uint8Array(newBitLength / 8);\n    var words = new uint32Array(bytes.buffer);\n    bytes.set(data, 0);\n    bytes[legth] = 128;\n    words[words.length - 1] = convertEndian(bitLength);\n    var round;\n    for (var block = 0; block < newBitLength / 32; block += 16) {\n      var workingState = STATE.slice();\n      for (round = 0; round < 64; round++) {\n        var MRound;\n        if (round < 16) {\n          MRound = convertEndian(words[block + round]);\n        } else {\n          var gamma0x = M[round - 15];\n          var gamma1x = M[round - 2];\n          MRound = M[round - 7] + M[round - 16] + (rightRotate(gamma0x, 7) ^ rightRotate(gamma0x, 18) ^ gamma0x >>> 3) + (rightRotate(gamma1x, 17) ^ rightRotate(gamma1x, 19) ^ gamma1x >>> 10);\n        }\n        M[round] = MRound |= 0;\n        var t1 = (rightRotate(workingState[4], 6) ^ rightRotate(workingState[4], 11) ^ rightRotate(workingState[4], 25)) + (workingState[4] & workingState[5] ^ ~workingState[4] & workingState[6]) + workingState[7] + MRound + ROUND_CONSTANTS[round];\n        var t2 = (rightRotate(workingState[0], 2) ^ rightRotate(workingState[0], 13) ^ rightRotate(workingState[0], 22)) + (workingState[0] & workingState[1] ^ workingState[2] & (workingState[0] ^ workingState[1]));\n        for (var i = 7; i > 0; i--) {\n          workingState[i] = workingState[i - 1];\n        }\n        workingState[0] = t1 + t2 | 0;\n        workingState[4] = workingState[4] + t1 | 0;\n      }\n      for (round = 0; round < 8; round++) {\n        STATE[round] = STATE[round] + workingState[round] | 0;\n      }\n    }\n    return new uint8Array(new uint32Array(STATE.map(function (val) {\n      return convertEndian(val);\n    })).buffer);\n  }\n  function hmac2(key, data) {\n    if (key.length > 64) key = sha256(key);\n    if (key.length < 64) {\n      const tmp = new Uint8Array(64);\n      tmp.set(key, 0);\n      key = tmp;\n    }\n    var innerKey = new Uint8Array(64);\n    var outerKey = new Uint8Array(64);\n    for (var i = 0; i < 64; i++) {\n      innerKey[i] = 54 ^ key[i];\n      outerKey[i] = 92 ^ key[i];\n    }\n    var msg = new Uint8Array(data.length + 64);\n    msg.set(innerKey, 0);\n    msg.set(data, 64);\n    var result = new Uint8Array(64 + 32);\n    result.set(outerKey, 0);\n    result.set(sha256(msg), 64);\n    return sha256(result);\n  }\n\n  // src/platform/web/lib/util/bufferutils.ts\n  var BufferUtils = class {\n    constructor() {\n      this.base64CharSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n      this.hexCharSet = \"0123456789abcdef\";\n    }\n    // // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js\n    uint8ViewToBase64(bytes) {\n      let base64 = \"\";\n      const encodings = this.base64CharSet;\n      const byteLength = bytes.byteLength;\n      const byteRemainder = byteLength % 3;\n      const mainLength = byteLength - byteRemainder;\n      let a, b, c, d;\n      let chunk;\n      for (let i = 0; i < mainLength; i = i + 3) {\n        chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];\n        a = (chunk & 16515072) >> 18;\n        b = (chunk & 258048) >> 12;\n        c = (chunk & 4032) >> 6;\n        d = chunk & 63;\n        base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n      }\n      if (byteRemainder == 1) {\n        chunk = bytes[mainLength];\n        a = (chunk & 252) >> 2;\n        b = (chunk & 3) << 4;\n        base64 += encodings[a] + encodings[b] + \"==\";\n      } else if (byteRemainder == 2) {\n        chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];\n        a = (chunk & 64512) >> 10;\n        b = (chunk & 1008) >> 4;\n        c = (chunk & 15) << 2;\n        base64 += encodings[a] + encodings[b] + encodings[c] + \"=\";\n      }\n      return base64;\n    }\n    base64ToArrayBuffer(base64) {\n      const binary_string = atob == null ? void 0 : atob(base64);\n      const len = binary_string.length;\n      const bytes = new Uint8Array(len);\n      for (let i = 0; i < len; i++) {\n        const ascii = binary_string.charCodeAt(i);\n        bytes[i] = ascii;\n      }\n      return bytes.buffer;\n    }\n    isBuffer(buffer) {\n      return buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\n    }\n    /* In browsers, returns a Uint8Array */\n    toBuffer(buffer) {\n      if (!ArrayBuffer) {\n        throw new Error(\"Can't convert to Buffer: browser does not support the necessary types\");\n      }\n      if (buffer instanceof ArrayBuffer) {\n        return new Uint8Array(buffer);\n      }\n      if (ArrayBuffer.isView(buffer)) {\n        return new Uint8Array(buffer.buffer);\n      }\n      throw new Error(\"BufferUtils.toBuffer expected an ArrayBuffer or a view onto one\");\n    }\n    toArrayBuffer(buffer) {\n      if (buffer instanceof ArrayBuffer) {\n        return buffer;\n      }\n      return this.toBuffer(buffer).buffer;\n    }\n    base64Encode(buffer) {\n      return this.uint8ViewToBase64(this.toBuffer(buffer));\n    }\n    base64Decode(str) {\n      if (ArrayBuffer && Platform.Config.atob) {\n        return this.base64ToArrayBuffer(str);\n      } else {\n        throw new Error(\"Expected ArrayBuffer to exist and Platform.Config.atob to be configured\");\n      }\n    }\n    hexEncode(buffer) {\n      const arrayBuffer = buffer instanceof ArrayBuffer ? buffer : buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n      const uint8Array2 = new Uint8Array(arrayBuffer);\n      return uint8Array2.reduce((accum, byte) => accum + byte.toString(16).padStart(2, \"0\"), \"\");\n    }\n    hexDecode(hexEncodedBytes) {\n      if (hexEncodedBytes.length % 2 !== 0) {\n        throw new Error(\"Can't create a byte array from a hex string of odd length\");\n      }\n      const uint8Array2 = new Uint8Array(hexEncodedBytes.length / 2);\n      for (let i = 0; i < uint8Array2.length; i++) {\n        uint8Array2[i] = parseInt(hexEncodedBytes.slice(2 * i, 2 * (i + 1)), 16);\n      }\n      return uint8Array2.buffer.slice(uint8Array2.byteOffset, uint8Array2.byteOffset + uint8Array2.byteLength);\n    }\n    utf8Encode(string) {\n      if (Platform.Config.TextEncoder) {\n        return new Platform.Config.TextEncoder().encode(string).buffer;\n      } else {\n        throw new Error(\"Expected TextEncoder to be configured\");\n      }\n    }\n    /* For utf8 decoding we apply slightly stricter input validation than to\n     * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from\n     * can take (in particular allowing strings, which are just interpreted as\n     * binary); here we ensure that the input is actually a buffer since trying\n     * to utf8-decode a string to another string is almost certainly a mistake */\n    utf8Decode(buffer) {\n      if (!this.isBuffer(buffer)) {\n        throw new Error(\"Expected input of utf8decode to be an arraybuffer or typed array\");\n      }\n      if (TextDecoder) {\n        return new TextDecoder().decode(buffer);\n      } else {\n        throw new Error(\"Expected TextDecoder to be configured\");\n      }\n    }\n    areBuffersEqual(buffer1, buffer2) {\n      if (!buffer1 || !buffer2) return false;\n      const arrayBuffer1 = this.toArrayBuffer(buffer1);\n      const arrayBuffer2 = this.toArrayBuffer(buffer2);\n      if (arrayBuffer1.byteLength != arrayBuffer2.byteLength) return false;\n      const bytes1 = new Uint8Array(arrayBuffer1);\n      const bytes2 = new Uint8Array(arrayBuffer2);\n      for (var i = 0; i < bytes1.length; i++) {\n        if (bytes1[i] != bytes2[i]) return false;\n      }\n      return true;\n    }\n    byteLength(buffer) {\n      if (buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer)) {\n        return buffer.byteLength;\n      }\n      return -1;\n    }\n    /* Returns ArrayBuffer on browser and Buffer on Node.js */\n    arrayBufferViewToBuffer(arrayBufferView) {\n      return arrayBufferView.buffer;\n    }\n    hmacSha256(message, key) {\n      return hmac2(this.toBuffer(key), this.toBuffer(message));\n    }\n  };\n  var bufferutils_default = new BufferUtils();\n\n  // src/platform/web/lib/util/crypto.ts\n  var createCryptoClass = function (config, bufferUtils) {\n    var DEFAULT_ALGORITHM = \"aes\";\n    var DEFAULT_KEYLENGTH = 256;\n    var DEFAULT_MODE = \"cbc\";\n    var DEFAULT_BLOCKLENGTH = 16;\n    function validateCipherParams(params) {\n      if (params.algorithm === \"aes\" && params.mode === \"cbc\") {\n        if (params.keyLength === 128 || params.keyLength === 256) {\n          return;\n        }\n        throw new Error(\"Unsupported key length \" + params.keyLength + \" for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)\");\n      }\n    }\n    function normaliseBase64(string) {\n      return string.replace(\"_\", \"/\").replace(\"-\", \"+\");\n    }\n    function isCipherParams(params) {\n      return params instanceof CipherParams;\n    }\n    class CipherParams {\n      constructor(algorithm, keyLength, mode, key) {\n        this.algorithm = algorithm;\n        this.keyLength = keyLength;\n        this.mode = mode;\n        this.key = key;\n      }\n    }\n    class Crypto2 {\n      /**\n       * Obtain a complete CipherParams instance from the provided params, filling\n       * in any not provided with default values, calculating a keyLength from\n       * the supplied key, and validating the result.\n       * @param params an object containing at a minimum a `key` key with value the\n       * key, as either a binary or a base64-encoded string.\n       * May optionally also contain: algorithm (defaults to AES),\n       * mode (defaults to 'cbc')\n       */\n      static getDefaultParams(params) {\n        var key;\n        if (!params.key) {\n          throw new Error(\"Crypto.getDefaultParams: a key is required\");\n        }\n        if (typeof params.key === \"string\") {\n          key = bufferUtils.toArrayBuffer(bufferUtils.base64Decode(normaliseBase64(params.key)));\n        } else if (params.key instanceof ArrayBuffer) {\n          key = params.key;\n        } else {\n          key = bufferUtils.toArrayBuffer(params.key);\n        }\n        var algorithm = params.algorithm || DEFAULT_ALGORITHM;\n        var keyLength = key.byteLength * 8;\n        var mode = params.mode || DEFAULT_MODE;\n        var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\n        if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\n          throw new Error(\"Crypto.getDefaultParams: a keyLength of \" + params.keyLength + \" was specified, but the key actually has length \" + cipherParams.keyLength);\n        }\n        validateCipherParams(cipherParams);\n        return cipherParams;\n      }\n      /**\n       * Generate a random encryption key from the supplied keylength (or the\n       * default keyLength if none supplied) as an ArrayBuffer\n       * @param keyLength (optional) the required keyLength in bits\n       */\n      static async generateRandomKey(keyLength) {\n        try {\n          return config.getRandomArrayBuffer((keyLength || DEFAULT_KEYLENGTH) / 8);\n        } catch (err) {\n          throw new ErrorInfo(\"Failed to generate random key: \" + err.message, 400, 5e4, err);\n        }\n      }\n      /**\n       * Internal; get a ChannelCipher instance based on the given cipherParams\n       * @param params either a CipherParams instance or some subset of its\n       * fields that includes a key\n       */\n      static getCipher(params) {\n        var _a2;\n        var cipherParams = isCipherParams(params) ? params : this.getDefaultParams(params);\n        return {\n          cipherParams,\n          cipher: new CBCCipher(cipherParams, (_a2 = params.iv) != null ? _a2 : null)\n        };\n      }\n    }\n    Crypto2.CipherParams = CipherParams;\n    Crypto2;\n    class CBCCipher {\n      constructor(params, iv) {\n        if (!crypto.subtle) {\n          if (isSecureContext) {\n            throw new Error(\"Crypto operations are not possible since the browser\\u2019s SubtleCrypto class is unavailable (reason unknown).\");\n          } else {\n            throw new Error(\"Crypto operations are is not possible since the current environment is a non-secure context and hence the browser\\u2019s SubtleCrypto class is not available.\");\n          }\n        }\n        this.algorithm = params.algorithm + \"-\" + String(params.keyLength) + \"-\" + params.mode;\n        this.webCryptoAlgorithm = params.algorithm + \"-\" + params.mode;\n        this.key = bufferUtils.toArrayBuffer(params.key);\n        this.iv = iv ? bufferUtils.toArrayBuffer(iv) : null;\n      }\n      concat(buffer1, buffer2) {\n        const output = new ArrayBuffer(buffer1.byteLength + buffer2.byteLength);\n        const outputView = new DataView(output);\n        const buffer1View = new DataView(bufferUtils.toArrayBuffer(buffer1));\n        for (let i = 0; i < buffer1View.byteLength; i++) {\n          outputView.setInt8(i, buffer1View.getInt8(i));\n        }\n        const buffer2View = new DataView(bufferUtils.toArrayBuffer(buffer2));\n        for (let i = 0; i < buffer2View.byteLength; i++) {\n          outputView.setInt8(buffer1View.byteLength + i, buffer2View.getInt8(i));\n        }\n        return output;\n      }\n      async encrypt(plaintext) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"CBCCipher.encrypt()\", \"\");\n        const iv = await this.getIv();\n        const cryptoKey = await crypto.subtle.importKey(\"raw\", this.key, this.webCryptoAlgorithm, false, [\"encrypt\"]);\n        const ciphertext = await crypto.subtle.encrypt({\n          name: this.webCryptoAlgorithm,\n          iv\n        }, cryptoKey, plaintext);\n        return this.concat(iv, ciphertext);\n      }\n      async decrypt(ciphertext) {\n        logger_default.logAction(logger_default.LOG_MICRO, \"CBCCipher.decrypt()\", \"\");\n        const ciphertextArrayBuffer = bufferUtils.toArrayBuffer(ciphertext);\n        const iv = ciphertextArrayBuffer.slice(0, DEFAULT_BLOCKLENGTH);\n        const ciphertextBody = ciphertextArrayBuffer.slice(DEFAULT_BLOCKLENGTH);\n        const cryptoKey = await crypto.subtle.importKey(\"raw\", this.key, this.webCryptoAlgorithm, false, [\"decrypt\"]);\n        return crypto.subtle.decrypt({\n          name: this.webCryptoAlgorithm,\n          iv\n        }, cryptoKey, ciphertextBody);\n      }\n      async getIv() {\n        if (this.iv) {\n          var iv = this.iv;\n          this.iv = null;\n          return iv;\n        }\n        const randomBlock = await config.getRandomArrayBuffer(DEFAULT_BLOCKLENGTH);\n        return bufferUtils.toArrayBuffer(randomBlock);\n      }\n    }\n    return Crypto2;\n  };\n\n  // src/common/constants/XHRStates.ts\n  var XHRStates = /* @__PURE__ */(XHRStates2 => {\n    XHRStates2[XHRStates2[\"REQ_SEND\"] = 0] = \"REQ_SEND\";\n    XHRStates2[XHRStates2[\"REQ_RECV\"] = 1] = \"REQ_RECV\";\n    XHRStates2[XHRStates2[\"REQ_RECV_POLL\"] = 2] = \"REQ_RECV_POLL\";\n    XHRStates2[XHRStates2[\"REQ_RECV_STREAM\"] = 3] = \"REQ_RECV_STREAM\";\n    return XHRStates2;\n  })(XHRStates || {});\n  var XHRStates_default = XHRStates;\n\n  // src/platform/web/lib/http/http.ts\n  function createMissingImplementationError() {\n    return new ErrorInfo(\"No HTTP request plugin provided. Provide at least one of the FetchRequest or XHRRequest plugins.\", 400, 4e4);\n  }\n  var _a;\n  var Http2 = (_a = class {\n    constructor(client) {\n      this.checksInProgress = null;\n      this.checkConnectivity = void 0;\n      this.supportsAuthHeaders = false;\n      this.supportsLinkHeaders = false;\n      var _a2;\n      this.client = client != null ? client : null;\n      const connectivityCheckUrl = (client == null ? void 0 : client.options.connectivityCheckUrl) || defaults_default.connectivityCheckUrl;\n      const connectivityCheckParams = (_a2 = client == null ? void 0 : client.options.connectivityCheckParams) != null ? _a2 : null;\n      const connectivityUrlIsDefault = !(client == null ? void 0 : client.options.connectivityCheckUrl);\n      const requestImplementations = __spreadValues(__spreadValues({}, Http2.bundledRequestImplementations), client == null ? void 0 : client._additionalHTTPRequestImplementations);\n      const xhrRequestImplementation = requestImplementations.XHRRequest;\n      const fetchRequestImplementation = requestImplementations.FetchRequest;\n      const hasImplementation = !!(xhrRequestImplementation || fetchRequestImplementation);\n      if (!hasImplementation) {\n        throw createMissingImplementationError();\n      }\n      if (Platform.Config.xhrSupported && xhrRequestImplementation) {\n        this.supportsAuthHeaders = true;\n        this.Request = async function (method, uri, headers, params, body) {\n          return new Promise(resolve => {\n            var _a3;\n            const req = xhrRequestImplementation.createRequest(uri, headers, params, body, XHRStates_default.REQ_SEND, (_a3 = client && client.options.timeouts) != null ? _a3 : null, method);\n            req.once(\"complete\", (error, body2, headers2, unpacked, statusCode) => resolve({\n              error,\n              body: body2,\n              headers: headers2,\n              unpacked,\n              statusCode\n            }));\n            req.exec();\n          });\n        };\n        if (client == null ? void 0 : client.options.disableConnectivityCheck) {\n          this.checkConnectivity = async function () {\n            return true;\n          };\n        } else {\n          this.checkConnectivity = async function () {\n            var _a3;\n            logger_default.logAction(logger_default.LOG_MICRO, \"(XHRRequest)Http.checkConnectivity()\", \"Sending; \" + connectivityCheckUrl);\n            const requestResult = await this.doUri(HttpMethods_default.Get, connectivityCheckUrl, null, null, connectivityCheckParams);\n            let result = false;\n            if (!connectivityUrlIsDefault) {\n              result = !requestResult.error && isSuccessCode(requestResult.statusCode);\n            } else {\n              result = !requestResult.error && ((_a3 = requestResult.body) == null ? void 0 : _a3.replace(/\\n/, \"\")) == \"yes\";\n            }\n            logger_default.logAction(logger_default.LOG_MICRO, \"(XHRRequest)Http.checkConnectivity()\", \"Result: \" + result);\n            return result;\n          };\n        }\n      } else if (Platform.Config.fetchSupported && fetchRequestImplementation) {\n        this.supportsAuthHeaders = true;\n        this.Request = async (method, uri, headers, params, body) => {\n          return fetchRequestImplementation(method, client != null ? client : null, uri, headers, params, body);\n        };\n        this.checkConnectivity = async function () {\n          var _a3;\n          logger_default.logAction(logger_default.LOG_MICRO, \"(Fetch)Http.checkConnectivity()\", \"Sending; \" + connectivityCheckUrl);\n          const requestResult = await this.doUri(HttpMethods_default.Get, connectivityCheckUrl, null, null, null);\n          const result = !requestResult.error && ((_a3 = requestResult.body) == null ? void 0 : _a3.replace(/\\n/, \"\")) == \"yes\";\n          logger_default.logAction(logger_default.LOG_MICRO, \"(Fetch)Http.checkConnectivity()\", \"Result: \" + result);\n          return result;\n        };\n      } else {\n        this.Request = async () => {\n          const error = hasImplementation ? new PartialErrorInfo(\"no supported HTTP transports available\", null, 400) : createMissingImplementationError();\n          return {\n            error\n          };\n        };\n      }\n    }\n    async doUri(method, uri, headers, body, params) {\n      if (!this.Request) {\n        return {\n          error: new PartialErrorInfo(\"Request invoked before assigned to\", null, 500)\n        };\n      }\n      return this.Request(method, uri, headers, params, body);\n    }\n    shouldFallback(errorInfo) {\n      const statusCode = errorInfo.statusCode;\n      return statusCode === 408 && !errorInfo.code || statusCode === 400 && !errorInfo.code || statusCode >= 500 && statusCode <= 504;\n    }\n  }, _a.methods = [HttpMethods_default.Get, HttpMethods_default.Delete, HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a.methodsWithoutBody = [HttpMethods_default.Get, HttpMethods_default.Delete], _a.methodsWithBody = [HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a);\n  var http_default = Http2;\n\n  // src/platform/web/config.ts\n  var globalObject3 = getGlobalObject();\n  if (typeof Window === \"undefined\" && typeof WorkerGlobalScope === \"undefined\") {\n    console.log(\"Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm\");\n  }\n  function allowComet() {\n    const loc = globalObject3.location;\n    return !globalObject3.WebSocket || !loc || !loc.origin || loc.origin.indexOf(\"http\") > -1;\n  }\n  function isWebWorkerContext() {\n    if (typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  var userAgent = globalObject3.navigator && globalObject3.navigator.userAgent.toString();\n  var currentUrl = globalObject3.location && globalObject3.location.href;\n  var Config = {\n    agent: \"browser\",\n    logTimestamps: true,\n    userAgent,\n    currentUrl,\n    binaryType: \"arraybuffer\",\n    WebSocket: globalObject3.WebSocket,\n    fetchSupported: !!globalObject3.fetch,\n    xhrSupported: globalObject3.XMLHttpRequest && \"withCredentials\" in new XMLHttpRequest(),\n    allowComet: allowComet(),\n    useProtocolHeartbeats: true,\n    supportsBinary: !!globalObject3.TextDecoder,\n    /* Per Paddy (https://ably-real-time.slack.com/archives/CURL4U2FP/p1705674537763479) web intentionally prefers JSON to MessagePack:\n     *\n     * > browsers' support for binary types in general was historically poor, and JSON transport performance is significantly better in a browser than msgpack. In modern browsers then binary is supported consistently, but I'd still expect that JSON encode/decode performance is dramatically better than msgpack in a browser.\n     */\n    preferBinary: false,\n    ArrayBuffer: globalObject3.ArrayBuffer,\n    atob: globalObject3.atob,\n    nextTick: typeof globalObject3.setImmediate !== \"undefined\" ? globalObject3.setImmediate.bind(globalObject3) : function (f) {\n      setTimeout(f, 0);\n    },\n    addEventListener: globalObject3.addEventListener,\n    inspect: JSON.stringify,\n    stringByteSize: function (str) {\n      return globalObject3.TextDecoder && new globalObject3.TextEncoder().encode(str).length || str.length;\n    },\n    TextEncoder: globalObject3.TextEncoder,\n    TextDecoder: globalObject3.TextDecoder,\n    getRandomArrayBuffer: async function (byteLength) {\n      const byteArray = new Uint8Array(byteLength);\n      globalObject3.crypto.getRandomValues(byteArray);\n      return byteArray.buffer;\n    },\n    isWebworker: isWebWorkerContext()\n  };\n  var config_default = Config;\n\n  // src/common/lib/transport/comettransport.ts\n  function shouldBeErrorAction(err) {\n    const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\n    if (err.code) {\n      if (auth_default.isTokenErr(err)) return false;\n      if (UNRESOLVABLE_ERROR_CODES.includes(err.code)) return true;\n      return err.code >= 4e4 && err.code < 5e4;\n    } else {\n      return false;\n    }\n  }\n  function protocolMessageFromRawError(err) {\n    if (shouldBeErrorAction(err)) {\n      return [fromValues3({\n        action: actions2.ERROR,\n        error: err\n      })];\n    } else {\n      return [fromValues3({\n        action: actions2.DISCONNECTED,\n        error: err\n      })];\n    }\n  }\n  var CometTransport = class extends transport_default {\n    constructor(connectionManager, auth, params) {\n      super(connectionManager, auth, params, /* binary not supported for comet so force JSON protocol */\n      true);\n      /* Historical comment, back from when we supported JSONP:\n       *\n       * > For comet, we could do the auth update by aborting the current recv and\n       * > starting a new one with the new token, that'd be sufficient for realtime.\n       * > Problem is JSONP - you can't cancel truly abort a recv once started. So\n       * > we need to send an AUTH for jsonp. In which case it's simpler to keep all\n       * > comet transports the same and do it for all of them. So we send the AUTH\n       * > instead, and don't need to abort the recv\n       *\n       * Now that weâ€™ve dropped JSONP support, we may be able to revisit the above;\n       * see https://github.com/ably/ably-js/issues/1214.\n       */\n      this.onAuthUpdated = tokenDetails => {\n        this.authParams = {\n          access_token: tokenDetails.token\n        };\n      };\n      this.stream = \"stream\" in params ? params.stream : true;\n      this.sendRequest = null;\n      this.recvRequest = null;\n      this.pendingCallback = null;\n      this.pendingItems = null;\n    }\n    connect() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"CometTransport.connect()\", \"starting\");\n      transport_default.prototype.connect.call(this);\n      const params = this.params;\n      const options = params.options;\n      const host = defaults_default.getHost(options, params.host);\n      const port = defaults_default.getPort(options);\n      const cometScheme = options.tls ? \"https://\" : \"http://\";\n      this.baseUri = cometScheme + host + \":\" + port + \"/comet/\";\n      const connectUri = this.baseUri + \"connect\";\n      logger_default.logAction(logger_default.LOG_MINOR, \"CometTransport.connect()\", \"uri: \" + connectUri);\n      whenPromiseSettles(this.auth.getAuthParams(), (err, authParams) => {\n        if (err) {\n          this.disconnect(err);\n          return;\n        }\n        if (this.isDisposed) {\n          return;\n        }\n        this.authParams = authParams;\n        const connectParams = this.params.getConnectParams(authParams);\n        if (\"stream\" in connectParams) this.stream = connectParams.stream;\n        logger_default.logAction(logger_default.LOG_MINOR, \"CometTransport.connect()\", \"connectParams:\" + toQueryString(connectParams));\n        let preconnected = false;\n        const connectRequest = this.recvRequest = this.createRequest(connectUri, null, connectParams, null, this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV);\n        connectRequest.on(\"data\", data => {\n          if (!this.recvRequest) {\n            return;\n          }\n          if (!preconnected) {\n            preconnected = true;\n            this.emit(\"preconnect\");\n          }\n          this.onData(data);\n        });\n        connectRequest.on(\"complete\", err2 => {\n          if (!this.recvRequest) {\n            err2 = err2 || new ErrorInfo(\"Request cancelled\", 80003, 400);\n          }\n          this.recvRequest = null;\n          if (!preconnected && !err2) {\n            preconnected = true;\n            this.emit(\"preconnect\");\n          }\n          this.onActivity();\n          if (err2) {\n            if (err2.code) {\n              this.onData(protocolMessageFromRawError(err2));\n            } else {\n              this.disconnect(err2);\n            }\n            return;\n          }\n          Platform.Config.nextTick(() => {\n            this.recv();\n          });\n        });\n        connectRequest.exec();\n      });\n    }\n    requestClose() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"CometTransport.requestClose()\");\n      this._requestCloseOrDisconnect(true);\n    }\n    requestDisconnect() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"CometTransport.requestDisconnect()\");\n      this._requestCloseOrDisconnect(false);\n    }\n    _requestCloseOrDisconnect(closing) {\n      const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\n      if (closeOrDisconnectUri) {\n        const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates_default.REQ_SEND);\n        request.on(\"complete\", err => {\n          if (err) {\n            logger_default.logAction(logger_default.LOG_ERROR, \"CometTransport.request\" + (closing ? \"Close()\" : \"Disconnect()\"), \"request returned err = \" + inspectError(err));\n            this.finish(\"disconnected\", err);\n          }\n        });\n        request.exec();\n      }\n    }\n    dispose() {\n      logger_default.logAction(logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"\");\n      if (!this.isDisposed) {\n        this.isDisposed = true;\n        if (this.recvRequest) {\n          logger_default.logAction(logger_default.LOG_MINOR, \"CometTransport.dispose()\", \"aborting recv request\");\n          this.recvRequest.abort();\n          this.recvRequest = null;\n        }\n        this.finish(\"disconnected\", connectionerrors_default.disconnected());\n        Platform.Config.nextTick(() => {\n          this.emit(\"disposed\");\n        });\n      }\n    }\n    onConnect(message) {\n      var _a2;\n      if (this.isDisposed) {\n        return;\n      }\n      const connectionStr = (_a2 = message.connectionDetails) == null ? void 0 : _a2.connectionKey;\n      transport_default.prototype.onConnect.call(this, message);\n      const baseConnectionUri = this.baseUri + connectionStr;\n      logger_default.logAction(logger_default.LOG_MICRO, \"CometTransport.onConnect()\", \"baseUri = \" + baseConnectionUri);\n      this.sendUri = baseConnectionUri + \"/send\";\n      this.recvUri = baseConnectionUri + \"/recv\";\n      this.closeUri = baseConnectionUri + \"/close\";\n      this.disconnectUri = baseConnectionUri + \"/disconnect\";\n    }\n    send(message) {\n      if (this.sendRequest) {\n        this.pendingItems = this.pendingItems || [];\n        this.pendingItems.push(message);\n        return;\n      }\n      const pendingItems = this.pendingItems || [];\n      pendingItems.push(message);\n      this.pendingItems = null;\n      this.sendItems(pendingItems);\n    }\n    sendAnyPending() {\n      const pendingItems = this.pendingItems;\n      if (!pendingItems) {\n        return;\n      }\n      this.pendingItems = null;\n      this.sendItems(pendingItems);\n    }\n    sendItems(items) {\n      const sendRequest = this.sendRequest = this.createRequest(this.sendUri, null, this.authParams, this.encodeRequest(items), XHRStates_default.REQ_SEND);\n      sendRequest.on(\"complete\", (err, data) => {\n        if (err) logger_default.logAction(logger_default.LOG_ERROR, \"CometTransport.sendItems()\", \"on complete: err = \" + inspectError(err));\n        this.sendRequest = null;\n        if (err) {\n          if (err.code) {\n            this.onData(protocolMessageFromRawError(err));\n          } else {\n            this.disconnect(err);\n          }\n          return;\n        }\n        if (data) {\n          this.onData(data);\n        }\n        if (this.pendingItems) {\n          Platform.Config.nextTick(() => {\n            if (!this.sendRequest) {\n              this.sendAnyPending();\n            }\n          });\n        }\n      });\n      sendRequest.exec();\n    }\n    recv() {\n      if (this.recvRequest) return;\n      if (!this.isConnected) return;\n      const recvRequest = this.recvRequest = this.createRequest(this.recvUri, null, this.authParams, null, this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV_POLL);\n      recvRequest.on(\"data\", data => {\n        this.onData(data);\n      });\n      recvRequest.on(\"complete\", err => {\n        this.recvRequest = null;\n        this.onActivity();\n        if (err) {\n          if (err.code) {\n            this.onData(protocolMessageFromRawError(err));\n          } else {\n            this.disconnect(err);\n          }\n          return;\n        }\n        Platform.Config.nextTick(() => {\n          this.recv();\n        });\n      });\n      recvRequest.exec();\n    }\n    onData(responseData) {\n      try {\n        const items = this.decodeResponse(responseData);\n        if (items && items.length) for (let i = 0; i < items.length; i++) this.onProtocolMessage(fromDeserialized(items[i], this.connectionManager.realtime._RealtimePresence));\n      } catch (e) {\n        logger_default.logAction(logger_default.LOG_ERROR, \"CometTransport.onData()\", \"Unexpected exception handing channel event: \" + e.stack);\n      }\n    }\n    encodeRequest(requestItems) {\n      return JSON.stringify(requestItems);\n    }\n    decodeResponse(responseData) {\n      if (typeof responseData == \"string\") return JSON.parse(responseData);\n      return responseData;\n    }\n  };\n  var comettransport_default = CometTransport;\n\n  // src/platform/web/lib/http/request/xhrrequest.ts\n  function isAblyError(responseBody, headers) {\n    return allToLowerCase(keysArray(headers)).includes(\"x-ably-errorcode\");\n  }\n  function getAblyError(responseBody, headers) {\n    if (isAblyError(responseBody, headers)) {\n      return responseBody.error && ErrorInfo.fromValues(responseBody.error);\n    }\n  }\n  var noop3 = function () {};\n  var idCounter = 0;\n  var pendingRequests = {};\n  function getHeader(xhr, header) {\n    return xhr.getResponseHeader && xhr.getResponseHeader(header);\n  }\n  function isEncodingChunked(xhr) {\n    return xhr.getResponseHeader && (xhr.getResponseHeader(\"transfer-encoding\") || !xhr.getResponseHeader(\"content-length\"));\n  }\n  function getHeadersAsObject(xhr) {\n    const headerPairs = xhr.getAllResponseHeaders().trim().split(\"\\r\\n\");\n    const headers = {};\n    for (let i = 0; i < headerPairs.length; i++) {\n      const parts = headerPairs[i].split(\":\").map(x => x.trim());\n      headers[parts[0].toLowerCase()] = parts[1];\n    }\n    return headers;\n  }\n  var XHRRequest = class _XHRRequest extends eventemitter_default {\n    constructor(uri, headers, params, body, requestMode, timeouts, method) {\n      super();\n      params = params || {};\n      params.rnd = cheapRandStr();\n      this.uri = uri + toQueryString(params);\n      this.headers = headers || {};\n      this.body = body;\n      this.method = method ? method.toUpperCase() : isNil(body) ? \"GET\" : \"POST\";\n      this.requestMode = requestMode;\n      this.timeouts = timeouts;\n      this.timedOut = false;\n      this.requestComplete = false;\n      this.id = String(++idCounter);\n      pendingRequests[this.id] = this;\n    }\n    static createRequest(uri, headers, params, body, requestMode, timeouts, method) {\n      const _timeouts = timeouts || defaults_default.TIMEOUTS;\n      return new _XHRRequest(uri, headers, copy(params), body, requestMode, _timeouts, method);\n    }\n    complete(err, body, headers, unpacked, statusCode) {\n      if (!this.requestComplete) {\n        this.requestComplete = true;\n        if (!err && body) {\n          this.emit(\"data\", body);\n        }\n        this.emit(\"complete\", err, body, headers, unpacked, statusCode);\n        this.dispose();\n      }\n    }\n    abort() {\n      this.dispose();\n    }\n    exec() {\n      let headers = this.headers;\n      const timeout = this.requestMode == XHRStates_default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout,\n        timer = this.timer = setTimeout(() => {\n          this.timedOut = true;\n          xhr.abort();\n        }, timeout),\n        method = this.method,\n        xhr = this.xhr = new XMLHttpRequest(),\n        accept = headers[\"accept\"];\n      let body = this.body;\n      let responseType = \"text\";\n      if (!accept) {\n        headers[\"accept\"] = \"application/json\";\n      } else if (accept.indexOf(\"application/x-msgpack\") === 0) {\n        responseType = \"arraybuffer\";\n      }\n      if (body) {\n        const contentType = headers[\"content-type\"] || (headers[\"content-type\"] = \"application/json\");\n        if (contentType.indexOf(\"application/json\") > -1 && typeof body != \"string\") body = JSON.stringify(body);\n      }\n      xhr.open(method, this.uri, true);\n      xhr.responseType = responseType;\n      if (\"authorization\" in headers) {\n        xhr.withCredentials = true;\n      }\n      for (const h in headers) xhr.setRequestHeader(h, headers[h]);\n      const errorHandler = (errorEvent, message, code, statusCode2) => {\n        var _a2;\n        let errorMessage = message + \" (event type: \" + errorEvent.type + \")\";\n        if ((_a2 = this == null ? void 0 : this.xhr) == null ? void 0 : _a2.statusText) errorMessage += \", current statusText is \" + this.xhr.statusText;\n        logger_default.logAction(logger_default.LOG_ERROR, \"Request.on\" + errorEvent.type + \"()\", errorMessage);\n        this.complete(new PartialErrorInfo(errorMessage, code, statusCode2));\n      };\n      xhr.onerror = function (errorEvent) {\n        errorHandler(errorEvent, \"XHR error occurred\", null, 400);\n      };\n      xhr.onabort = errorEvent => {\n        if (this.timedOut) {\n          errorHandler(errorEvent, \"Request aborted due to request timeout expiring\", null, 408);\n        } else {\n          errorHandler(errorEvent, \"Request cancelled\", null, 400);\n        }\n      };\n      xhr.ontimeout = function (errorEvent) {\n        errorHandler(errorEvent, \"Request timed out\", null, 408);\n      };\n      let streaming;\n      let statusCode;\n      let successResponse;\n      let streamPos = 0;\n      let unpacked = false;\n      const onResponse = () => {\n        clearTimeout(timer);\n        successResponse = statusCode < 400;\n        if (statusCode == 204) {\n          this.complete(null, null, null, null, statusCode);\n          return;\n        }\n        streaming = this.requestMode == XHRStates_default.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);\n      };\n      const onEnd = () => {\n        let parsedResponse;\n        try {\n          const contentType = getHeader(xhr, \"content-type\");\n          const json = contentType ? contentType.indexOf(\"application/json\") >= 0 : xhr.responseType == \"text\";\n          if (json) {\n            const jsonResponseBody = xhr.responseType === \"arraybuffer\" ? Platform.BufferUtils.utf8Decode(xhr.response) : String(xhr.responseText);\n            if (jsonResponseBody.length) {\n              parsedResponse = JSON.parse(jsonResponseBody);\n            } else {\n              parsedResponse = jsonResponseBody;\n            }\n            unpacked = true;\n          } else {\n            parsedResponse = xhr.response;\n          }\n          if (parsedResponse.response !== void 0) {\n            statusCode = parsedResponse.statusCode;\n            successResponse = statusCode < 400;\n            headers = parsedResponse.headers;\n            parsedResponse = parsedResponse.response;\n          } else {\n            headers = getHeadersAsObject(xhr);\n          }\n        } catch (e) {\n          this.complete(new PartialErrorInfo(\"Malformed response body from server: \" + e.message, null, 400));\n          return;\n        }\n        if (successResponse || Array.isArray(parsedResponse)) {\n          this.complete(null, parsedResponse, headers, unpacked, statusCode);\n          return;\n        }\n        let err = getAblyError(parsedResponse, headers);\n        if (!err) {\n          err = new PartialErrorInfo(\"Error response received from server: \" + statusCode + \" body was: \" + Platform.Config.inspect(parsedResponse), null, statusCode);\n        }\n        this.complete(err, parsedResponse, headers, unpacked, statusCode);\n      };\n      function onProgress() {\n        const responseText = xhr.responseText;\n        const bodyEnd = responseText.length - 1;\n        let idx, chunk;\n        while (streamPos < bodyEnd && (idx = responseText.indexOf(\"\\n\", streamPos)) > -1) {\n          chunk = responseText.slice(streamPos, idx);\n          streamPos = idx + 1;\n          onChunk(chunk);\n        }\n      }\n      const onChunk = chunk => {\n        try {\n          chunk = JSON.parse(chunk);\n        } catch (e) {\n          this.complete(new PartialErrorInfo(\"Malformed response body from server: \" + e.message, null, 400));\n          return;\n        }\n        this.emit(\"data\", chunk);\n      };\n      const onStreamEnd = () => {\n        onProgress();\n        this.streamComplete = true;\n        Platform.Config.nextTick(() => {\n          this.complete();\n        });\n      };\n      xhr.onreadystatechange = function () {\n        const readyState = xhr.readyState;\n        if (readyState < 3) return;\n        if (xhr.status !== 0) {\n          if (statusCode === void 0) {\n            statusCode = xhr.status;\n            onResponse();\n          }\n          if (readyState == 3 && streaming) {\n            onProgress();\n          } else if (readyState == 4) {\n            if (streaming) onStreamEnd();else onEnd();\n          }\n        }\n      };\n      xhr.send(body);\n    }\n    dispose() {\n      const xhr = this.xhr;\n      if (xhr) {\n        xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop3;\n        this.xhr = null;\n        const timer = this.timer;\n        if (timer) {\n          clearTimeout(timer);\n          this.timer = null;\n        }\n        if (!this.requestComplete) xhr.abort();\n      }\n      delete pendingRequests[this.id];\n    }\n  };\n  var xhrrequest_default = XHRRequest;\n\n  // src/platform/web/lib/transport/xhrpollingtransport.ts\n  var shortName2 = TransportNames.XhrPolling;\n  var XHRPollingTransport = class extends comettransport_default {\n    constructor(connectionManager, auth, params) {\n      super(connectionManager, auth, params);\n      this.shortName = shortName2;\n      params.stream = false;\n      this.shortName = shortName2;\n    }\n    static isAvailable() {\n      return !!(Platform.Config.xhrSupported && Platform.Config.allowComet);\n    }\n    toString() {\n      return \"XHRPollingTransport; uri=\" + this.baseUri + \"; isConnected=\" + this.isConnected;\n    }\n    createRequest(uri, headers, params, body, requestMode) {\n      return xhrrequest_default.createRequest(uri, headers, params, body, requestMode, this.timeouts);\n    }\n  };\n  var xhrpollingtransport_default = XHRPollingTransport;\n\n  // src/platform/web/lib/transport/index.ts\n  var order = [\"xhr_polling\"];\n  var defaultTransports = {\n    order,\n    bundledImplementations: {\n      web_socket: websockettransport_default,\n      xhr_polling: xhrpollingtransport_default\n    }\n  };\n  var transport_default2 = defaultTransports;\n\n  // src/platform/web/lib/util/webstorage.ts\n  var test = \"ablyjs-storage-test\";\n  var globalObject4 = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : self;\n  var Webstorage = class {\n    constructor() {\n      try {\n        globalObject4.sessionStorage.setItem(test, test);\n        globalObject4.sessionStorage.removeItem(test);\n        this.sessionSupported = true;\n      } catch (e) {\n        this.sessionSupported = false;\n      }\n      try {\n        globalObject4.localStorage.setItem(test, test);\n        globalObject4.localStorage.removeItem(test);\n        this.localSupported = true;\n      } catch (e) {\n        this.localSupported = false;\n      }\n    }\n    get(name) {\n      return this._get(name, false);\n    }\n    getSession(name) {\n      return this._get(name, true);\n    }\n    remove(name) {\n      return this._remove(name, false);\n    }\n    removeSession(name) {\n      return this._remove(name, true);\n    }\n    set(name, value, ttl) {\n      return this._set(name, value, ttl, false);\n    }\n    setSession(name, value, ttl) {\n      return this._set(name, value, ttl, true);\n    }\n    _set(name, value, ttl, session) {\n      const wrappedValue = {\n        value\n      };\n      if (ttl) {\n        wrappedValue.expires = Date.now() + ttl;\n      }\n      return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));\n    }\n    _get(name, session) {\n      if (session && !this.sessionSupported) throw new Error(\"Session Storage not supported\");\n      if (!session && !this.localSupported) throw new Error(\"Local Storage not supported\");\n      const rawItem = this.storageInterface(session).getItem(name);\n      if (!rawItem) return null;\n      const wrappedValue = JSON.parse(rawItem);\n      if (wrappedValue.expires && wrappedValue.expires < Date.now()) {\n        this.storageInterface(session).removeItem(name);\n        return null;\n      }\n      return wrappedValue.value;\n    }\n    _remove(name, session) {\n      return this.storageInterface(session).removeItem(name);\n    }\n    storageInterface(session) {\n      return session ? globalObject4.sessionStorage : globalObject4.localStorage;\n    }\n  };\n  var webstorage_default = new Webstorage();\n\n  // src/platform/web/lib/util/defaults.ts\n  var Defaults2 = {\n    connectivityCheckUrl: \"https://internet-up.ably-realtime.com/is-the-internet-up.txt\",\n    wsConnectivityUrl: \"wss://ws-up.ably-realtime.com\",\n    /* Order matters here: the base transport is the leftmost one in the\n     * intersection of baseTransportOrder and the transports clientOption that's\n     * supported. */\n    defaultTransports: [TransportNames.XhrPolling, TransportNames.WebSocket]\n  };\n  var defaults_default2 = Defaults2;\n\n  // src/platform/web/lib/util/msgpack.ts\n  function inspect(buffer) {\n    if (buffer === void 0) return \"undefined\";\n    let view;\n    let type;\n    if (buffer instanceof ArrayBuffer) {\n      type = \"ArrayBuffer\";\n      view = new DataView(buffer);\n    } else if (buffer instanceof DataView) {\n      type = \"DataView\";\n      view = buffer;\n    }\n    if (!view) return JSON.stringify(buffer);\n    const bytes = [];\n    for (let i = 0; i < buffer.byteLength; i++) {\n      if (i > 20) {\n        bytes.push(\"...\");\n        break;\n      }\n      let byte_ = view.getUint8(i).toString(16);\n      if (byte_.length === 1) byte_ = \"0\" + byte_;\n      bytes.push(byte_);\n    }\n    return \"<\" + type + \" \" + bytes.join(\" \") + \">\";\n  }\n  function utf8Write(view, offset, string) {\n    for (let i = 0, l = string.length; i < l; i++) {\n      const codePoint = string.charCodeAt(i);\n      if (codePoint < 128) {\n        view.setUint8(offset++, codePoint >>> 0 & 127 | 0);\n        continue;\n      }\n      if (codePoint < 2048) {\n        view.setUint8(offset++, codePoint >>> 6 & 31 | 192);\n        view.setUint8(offset++, codePoint >>> 0 & 63 | 128);\n        continue;\n      }\n      if (codePoint < 65536) {\n        view.setUint8(offset++, codePoint >>> 12 & 15 | 224);\n        view.setUint8(offset++, codePoint >>> 6 & 63 | 128);\n        view.setUint8(offset++, codePoint >>> 0 & 63 | 128);\n        continue;\n      }\n      if (codePoint < 1114112) {\n        view.setUint8(offset++, codePoint >>> 18 & 7 | 240);\n        view.setUint8(offset++, codePoint >>> 12 & 63 | 128);\n        view.setUint8(offset++, codePoint >>> 6 & 63 | 128);\n        view.setUint8(offset++, codePoint >>> 0 & 63 | 128);\n        continue;\n      }\n      throw new Error(\"bad codepoint \" + codePoint);\n    }\n  }\n  function utf8Read(view, offset, length) {\n    let string = \"\";\n    for (let i = offset, end = offset + length; i < end; i++) {\n      const byte_ = view.getUint8(i);\n      if ((byte_ & 128) === 0) {\n        string += String.fromCharCode(byte_);\n        continue;\n      }\n      if ((byte_ & 224) === 192) {\n        string += String.fromCharCode((byte_ & 15) << 6 | view.getUint8(++i) & 63);\n        continue;\n      }\n      if ((byte_ & 240) === 224) {\n        string += String.fromCharCode((byte_ & 15) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0);\n        continue;\n      }\n      if ((byte_ & 248) === 240) {\n        string += String.fromCharCode((byte_ & 7) << 18 | (view.getUint8(++i) & 63) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0);\n        continue;\n      }\n      throw new Error(\"Invalid byte \" + byte_.toString(16));\n    }\n    return string;\n  }\n  function utf8ByteCount(string) {\n    let count = 0;\n    for (let i = 0, l = string.length; i < l; i++) {\n      const codePoint = string.charCodeAt(i);\n      if (codePoint < 128) {\n        count += 1;\n        continue;\n      }\n      if (codePoint < 2048) {\n        count += 2;\n        continue;\n      }\n      if (codePoint < 65536) {\n        count += 3;\n        continue;\n      }\n      if (codePoint < 1114112) {\n        count += 4;\n        continue;\n      }\n      throw new Error(\"bad codepoint \" + codePoint);\n    }\n    return count;\n  }\n  function encode2(value, sparse) {\n    const size = sizeof(value, sparse);\n    if (size === 0) return void 0;\n    const buffer = new ArrayBuffer(size);\n    const view = new DataView(buffer);\n    _encode(value, view, 0, sparse);\n    return buffer;\n  }\n  var SH_L_32 = (1 << 16) * (1 << 16);\n  var SH_R_32 = 1 / SH_L_32;\n  function getInt64(view, offset) {\n    offset = offset || 0;\n    return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);\n  }\n  function getUint64(view, offset) {\n    offset = offset || 0;\n    return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);\n  }\n  function setInt64(view, offset, val) {\n    if (val < 9223372036854776e3) {\n      view.setInt32(offset, Math.floor(val * SH_R_32));\n      view.setInt32(offset + 4, val & -1);\n    } else {\n      view.setUint32(offset, 2147483647);\n      view.setUint32(offset + 4, 2147483647);\n    }\n  }\n  function setUint64(view, offset, val) {\n    if (val < 18446744073709552e3) {\n      view.setUint32(offset, Math.floor(val * SH_R_32));\n      view.setInt32(offset + 4, val & -1);\n    } else {\n      view.setUint32(offset, 4294967295);\n      view.setUint32(offset + 4, 4294967295);\n    }\n  }\n  var Decoder = class {\n    constructor(view, offset) {\n      this.map = length => {\n        const value = {};\n        for (let i = 0; i < length; i++) {\n          const key = this.parse();\n          value[key] = this.parse();\n        }\n        return value;\n      };\n      this.bin = length => {\n        const value = new ArrayBuffer(length);\n        new Uint8Array(value).set(new Uint8Array(this.view.buffer, this.offset, length), 0);\n        this.offset += length;\n        return value;\n      };\n      this.buf = this.bin;\n      this.str = length => {\n        const value = utf8Read(this.view, this.offset, length);\n        this.offset += length;\n        return value;\n      };\n      this.array = length => {\n        const value = new Array(length);\n        for (let i = 0; i < length; i++) {\n          value[i] = this.parse();\n        }\n        return value;\n      };\n      this.ext = length => {\n        this.offset += length;\n        return {\n          type: this.view.getInt8(this.offset),\n          data: this.buf(length)\n        };\n      };\n      this.parse = () => {\n        const type = this.view.getUint8(this.offset);\n        let value, length;\n        if ((type & 128) === 0) {\n          this.offset++;\n          return type;\n        }\n        if ((type & 240) === 128) {\n          length = type & 15;\n          this.offset++;\n          return this.map(length);\n        }\n        if ((type & 240) === 144) {\n          length = type & 15;\n          this.offset++;\n          return this.array(length);\n        }\n        if ((type & 224) === 160) {\n          length = type & 31;\n          this.offset++;\n          return this.str(length);\n        }\n        if ((type & 224) === 224) {\n          value = this.view.getInt8(this.offset);\n          this.offset++;\n          return value;\n        }\n        switch (type) {\n          case 192:\n            this.offset++;\n            return null;\n          case 193:\n            this.offset++;\n            return void 0;\n          case 194:\n            this.offset++;\n            return false;\n          case 195:\n            this.offset++;\n            return true;\n          case 196:\n            length = this.view.getUint8(this.offset + 1);\n            this.offset += 2;\n            return this.bin(length);\n          case 197:\n            length = this.view.getUint16(this.offset + 1);\n            this.offset += 3;\n            return this.bin(length);\n          case 198:\n            length = this.view.getUint32(this.offset + 1);\n            this.offset += 5;\n            return this.bin(length);\n          case 199:\n            length = this.view.getUint8(this.offset + 1);\n            this.offset += 2;\n            return this.ext(length);\n          case 200:\n            length = this.view.getUint16(this.offset + 1);\n            this.offset += 3;\n            return this.ext(length);\n          case 201:\n            length = this.view.getUint32(this.offset + 1);\n            this.offset += 5;\n            return this.ext(length);\n          case 202:\n            value = this.view.getFloat32(this.offset + 1);\n            this.offset += 5;\n            return value;\n          case 203:\n            value = this.view.getFloat64(this.offset + 1);\n            this.offset += 9;\n            return value;\n          case 204:\n            value = this.view.getUint8(this.offset + 1);\n            this.offset += 2;\n            return value;\n          case 205:\n            value = this.view.getUint16(this.offset + 1);\n            this.offset += 3;\n            return value;\n          case 206:\n            value = this.view.getUint32(this.offset + 1);\n            this.offset += 5;\n            return value;\n          case 207:\n            value = getUint64(this.view, this.offset + 1);\n            this.offset += 9;\n            return value;\n          case 208:\n            value = this.view.getInt8(this.offset + 1);\n            this.offset += 2;\n            return value;\n          case 209:\n            value = this.view.getInt16(this.offset + 1);\n            this.offset += 3;\n            return value;\n          case 210:\n            value = this.view.getInt32(this.offset + 1);\n            this.offset += 5;\n            return value;\n          case 211:\n            value = getInt64(this.view, this.offset + 1);\n            this.offset += 9;\n            return value;\n          case 212:\n            length = 1;\n            this.offset++;\n            return this.ext(length);\n          case 213:\n            length = 2;\n            this.offset++;\n            return this.ext(length);\n          case 214:\n            length = 4;\n            this.offset++;\n            return this.ext(length);\n          case 215:\n            length = 8;\n            this.offset++;\n            return this.ext(length);\n          case 216:\n            length = 16;\n            this.offset++;\n            return this.ext(length);\n          case 217:\n            length = this.view.getUint8(this.offset + 1);\n            this.offset += 2;\n            return this.str(length);\n          case 218:\n            length = this.view.getUint16(this.offset + 1);\n            this.offset += 3;\n            return this.str(length);\n          case 219:\n            length = this.view.getUint32(this.offset + 1);\n            this.offset += 5;\n            return this.str(length);\n          case 220:\n            length = this.view.getUint16(this.offset + 1);\n            this.offset += 3;\n            return this.array(length);\n          case 221:\n            length = this.view.getUint32(this.offset + 1);\n            this.offset += 5;\n            return this.array(length);\n          case 222:\n            length = this.view.getUint16(this.offset + 1);\n            this.offset += 3;\n            return this.map(length);\n          case 223:\n            length = this.view.getUint32(this.offset + 1);\n            this.offset += 5;\n            return this.map(length);\n        }\n        throw new Error(\"Unknown type 0x\" + type.toString(16));\n      };\n      this.offset = offset || 0;\n      this.view = view;\n    }\n  };\n  function decode3(buffer) {\n    const view = new DataView(buffer);\n    const decoder = new Decoder(view);\n    const value = decoder.parse();\n    if (decoder.offset !== buffer.byteLength) throw new Error(buffer.byteLength - decoder.offset + \" trailing bytes\");\n    return value;\n  }\n  function encodeableKeys(value, sparse) {\n    return Object.keys(value).filter(function (e) {\n      const val = value[e],\n        type = typeof val;\n      return (!sparse || val !== void 0 && val !== null) && (\"function\" !== type || !!val.toJSON);\n    });\n  }\n  function _encode(value, view, offset, sparse) {\n    const type = typeof value;\n    if (typeof value === \"string\") {\n      const length = utf8ByteCount(value);\n      if (length < 32) {\n        view.setUint8(offset, length | 160);\n        utf8Write(view, offset + 1, value);\n        return 1 + length;\n      }\n      if (length < 256) {\n        view.setUint8(offset, 217);\n        view.setUint8(offset + 1, length);\n        utf8Write(view, offset + 2, value);\n        return 2 + length;\n      }\n      if (length < 65536) {\n        view.setUint8(offset, 218);\n        view.setUint16(offset + 1, length);\n        utf8Write(view, offset + 3, value);\n        return 3 + length;\n      }\n      if (length < 4294967296) {\n        view.setUint8(offset, 219);\n        view.setUint32(offset + 1, length);\n        utf8Write(view, offset + 5, value);\n        return 5 + length;\n      }\n    }\n    if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n      value = value.buffer;\n    }\n    if (value instanceof ArrayBuffer) {\n      const length = value.byteLength;\n      if (length < 256) {\n        view.setUint8(offset, 196);\n        view.setUint8(offset + 1, length);\n        new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);\n        return 2 + length;\n      }\n      if (length < 65536) {\n        view.setUint8(offset, 197);\n        view.setUint16(offset + 1, length);\n        new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);\n        return 3 + length;\n      }\n      if (length < 4294967296) {\n        view.setUint8(offset, 198);\n        view.setUint32(offset + 1, length);\n        new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);\n        return 5 + length;\n      }\n    }\n    if (typeof value === \"number\") {\n      if (Math.floor(value) !== value) {\n        view.setUint8(offset, 203);\n        view.setFloat64(offset + 1, value);\n        return 9;\n      }\n      if (value >= 0) {\n        if (value < 128) {\n          view.setUint8(offset, value);\n          return 1;\n        }\n        if (value < 256) {\n          view.setUint8(offset, 204);\n          view.setUint8(offset + 1, value);\n          return 2;\n        }\n        if (value < 65536) {\n          view.setUint8(offset, 205);\n          view.setUint16(offset + 1, value);\n          return 3;\n        }\n        if (value < 4294967296) {\n          view.setUint8(offset, 206);\n          view.setUint32(offset + 1, value);\n          return 5;\n        }\n        if (value < 18446744073709552e3) {\n          view.setUint8(offset, 207);\n          setUint64(view, offset + 1, value);\n          return 9;\n        }\n        throw new Error(\"Number too big 0x\" + value.toString(16));\n      }\n      if (value >= -32) {\n        view.setInt8(offset, value);\n        return 1;\n      }\n      if (value >= -128) {\n        view.setUint8(offset, 208);\n        view.setInt8(offset + 1, value);\n        return 2;\n      }\n      if (value >= -32768) {\n        view.setUint8(offset, 209);\n        view.setInt16(offset + 1, value);\n        return 3;\n      }\n      if (value >= -2147483648) {\n        view.setUint8(offset, 210);\n        view.setInt32(offset + 1, value);\n        return 5;\n      }\n      if (value >= -9223372036854776e3) {\n        view.setUint8(offset, 211);\n        setInt64(view, offset + 1, value);\n        return 9;\n      }\n      throw new Error(\"Number too small -0x\" + (-value).toString(16).substr(1));\n    }\n    if (type === \"undefined\") {\n      if (sparse) return 0;\n      view.setUint8(offset, 212);\n      view.setUint8(offset + 1, 0);\n      view.setUint8(offset + 2, 0);\n      return 3;\n    }\n    if (value === null) {\n      if (sparse) return 0;\n      view.setUint8(offset, 192);\n      return 1;\n    }\n    if (type === \"boolean\") {\n      view.setUint8(offset, value ? 195 : 194);\n      return 1;\n    }\n    if (\"function\" === typeof value.toJSON) return _encode(value.toJSON(), view, offset, sparse);\n    if (type === \"object\") {\n      let length,\n        size = 0;\n      let keys;\n      const isArray = Array.isArray(value);\n      if (isArray) {\n        length = value.length;\n      } else {\n        keys = encodeableKeys(value, sparse);\n        length = keys.length;\n      }\n      if (length < 16) {\n        view.setUint8(offset, length | (isArray ? 144 : 128));\n        size = 1;\n      } else if (length < 65536) {\n        view.setUint8(offset, isArray ? 220 : 222);\n        view.setUint16(offset + 1, length);\n        size = 3;\n      } else if (length < 4294967296) {\n        view.setUint8(offset, isArray ? 221 : 223);\n        view.setUint32(offset + 1, length);\n        size = 5;\n      }\n      if (isArray) {\n        for (let i = 0; i < length; i++) {\n          size += _encode(value[i], view, offset + size, sparse);\n        }\n      } else if (keys) {\n        for (let i = 0; i < length; i++) {\n          const key = keys[i];\n          size += _encode(key, view, offset + size);\n          size += _encode(value[key], view, offset + size, sparse);\n        }\n      }\n      return size;\n    }\n    if (type === \"function\") return 0;\n    throw new Error(\"Unknown type \" + type);\n  }\n  function sizeof(value, sparse) {\n    const type = typeof value;\n    if (type === \"string\") {\n      const length = utf8ByteCount(value);\n      if (length < 32) {\n        return 1 + length;\n      }\n      if (length < 256) {\n        return 2 + length;\n      }\n      if (length < 65536) {\n        return 3 + length;\n      }\n      if (length < 4294967296) {\n        return 5 + length;\n      }\n    }\n    if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n      value = value.buffer;\n    }\n    if (value instanceof ArrayBuffer) {\n      const length = value.byteLength;\n      if (length < 256) {\n        return 2 + length;\n      }\n      if (length < 65536) {\n        return 3 + length;\n      }\n      if (length < 4294967296) {\n        return 5 + length;\n      }\n    }\n    if (typeof value === \"number\") {\n      if (Math.floor(value) !== value) return 9;\n      if (value >= 0) {\n        if (value < 128) return 1;\n        if (value < 256) return 2;\n        if (value < 65536) return 3;\n        if (value < 4294967296) return 5;\n        if (value < 18446744073709552e3) return 9;\n        throw new Error(\"Number too big 0x\" + value.toString(16));\n      }\n      if (value >= -32) return 1;\n      if (value >= -128) return 2;\n      if (value >= -32768) return 3;\n      if (value >= -2147483648) return 5;\n      if (value >= -9223372036854776e3) return 9;\n      throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n    }\n    if (type === \"boolean\") return 1;\n    if (value === null) return sparse ? 0 : 1;\n    if (value === void 0) return sparse ? 0 : 3;\n    if (\"function\" === typeof value.toJSON) return sizeof(value.toJSON(), sparse);\n    if (type === \"object\") {\n      let length,\n        size = 0;\n      if (Array.isArray(value)) {\n        length = value.length;\n        for (let i = 0; i < length; i++) {\n          size += sizeof(value[i], sparse);\n        }\n      } else {\n        const keys = encodeableKeys(value, sparse);\n        length = keys.length;\n        for (let i = 0; i < length; i++) {\n          const key = keys[i];\n          size += sizeof(key) + sizeof(value[key], sparse);\n        }\n      }\n      if (length < 16) {\n        return 1 + size;\n      }\n      if (length < 65536) {\n        return 3 + size;\n      }\n      if (length < 4294967296) {\n        return 5 + size;\n      }\n      throw new Error(\"Array or object too long 0x\" + length.toString(16));\n    }\n    if (type === \"function\") return 0;\n    throw new Error(\"Unknown type \" + type);\n  }\n  var msgpack_default = {\n    encode: encode2,\n    decode: decode3,\n    inspect,\n    utf8Write,\n    utf8Read,\n    utf8ByteCount\n  };\n\n  // src/platform/web/lib/http/request/fetchrequest.ts\n  function isAblyError2(responseBody, headers) {\n    return !!headers.get(\"x-ably-errorcode\");\n  }\n  function getAblyError2(responseBody, headers) {\n    if (isAblyError2(responseBody, headers)) {\n      return responseBody.error && ErrorInfo.fromValues(responseBody.error);\n    }\n  }\n  function convertHeaders(headers) {\n    const result = {};\n    headers.forEach((value, key) => {\n      result[key] = value;\n    });\n    return result;\n  }\n  async function fetchRequest(method, client, uri, headers, params, body) {\n    const fetchHeaders = new Headers(headers || {});\n    const _method = method ? method.toUpperCase() : isNil(body) ? \"GET\" : \"POST\";\n    const controller = new AbortController();\n    let timeout;\n    const timeoutPromise = new Promise(resolve => {\n      timeout = setTimeout(() => {\n        controller.abort();\n        resolve({\n          error: new PartialErrorInfo(\"Request timed out\", null, 408)\n        });\n      }, client ? client.options.timeouts.httpRequestTimeout : defaults_default.TIMEOUTS.httpRequestTimeout);\n    });\n    const requestInit = {\n      method: _method,\n      headers: fetchHeaders,\n      body\n    };\n    if (!Platform.Config.isWebworker) {\n      requestInit.credentials = fetchHeaders.has(\"authorization\") ? \"include\" : \"same-origin\";\n    }\n    const resultPromise = (async () => {\n      try {\n        const res = await getGlobalObject().fetch(uri + \"?\" + new URLSearchParams(params || {}), requestInit);\n        clearTimeout(timeout);\n        const contentType = res.headers.get(\"Content-Type\");\n        let body2;\n        if (contentType && contentType.indexOf(\"application/x-msgpack\") > -1) {\n          body2 = await res.arrayBuffer();\n        } else if (contentType && contentType.indexOf(\"application/json\") > -1) {\n          body2 = await res.json();\n        } else {\n          body2 = await res.text();\n        }\n        const unpacked = !!contentType && contentType.indexOf(\"application/x-msgpack\") === -1;\n        const headers2 = convertHeaders(res.headers);\n        if (!res.ok) {\n          const error = getAblyError2(body2, res.headers) || new PartialErrorInfo(\"Error response received from server: \" + res.status + \" body was: \" + Platform.Config.inspect(body2), null, res.status);\n          return {\n            error,\n            body: body2,\n            headers: headers2,\n            unpacked,\n            statusCode: res.status\n          };\n        } else {\n          return {\n            error: null,\n            body: body2,\n            headers: headers2,\n            unpacked,\n            statusCode: res.status\n          };\n        }\n      } catch (error) {\n        clearTimeout(timeout);\n        return {\n          error\n        };\n      }\n    })();\n    return Promise.race([timeoutPromise, resultPromise]);\n  }\n\n  // src/platform/web/lib/http/request/index.ts\n  var defaultBundledRequestImplementations = {\n    XHRRequest: xhrrequest_default,\n    FetchRequest: fetchRequest\n  };\n\n  // src/platform/web/index.ts\n  var Crypto = createCryptoClass(config_default, bufferutils_default);\n  Platform.Crypto = Crypto;\n  Platform.BufferUtils = bufferutils_default;\n  Platform.Http = http_default;\n  Platform.Config = config_default;\n  Platform.Transports = transport_default2;\n  Platform.WebStorage = webstorage_default;\n  for (const clientClass of [DefaultRest, DefaultRealtime]) {\n    clientClass.Crypto = Crypto;\n    clientClass._MsgPack = msgpack_default;\n  }\n  http_default.bundledRequestImplementations = defaultBundledRequestImplementations;\n  logger_default.initLogHandlers();\n  Platform.Defaults = getDefaults(defaults_default2);\n  if (Platform.Config.agent) {\n    Platform.Defaults.agent += \" \" + Platform.Config.agent;\n  }\n  var web_default = {\n    ErrorInfo,\n    Rest: DefaultRest,\n    Realtime: DefaultRealtime,\n    msgpack: msgpack_default\n  };\n  if (typeof module.exports == \"object\" && typeof exports == \"object\") {\n    var __cp = (to, from, except, desc) => {\n      if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of Object.getOwnPropertyNames(from)) {\n          if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except) Object.defineProperty(to, key, {\n            get: () => from[key],\n            enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable\n          });\n        }\n      }\n      return to;\n    };\n    module.exports = __cp(module.exports, exports);\n  }\n  return module.exports;\n});","map":{"version":3,"names":["web_exports","__export","Realtime","DefaultRealtime","Rest","DefaultRest","default","web_default","msgpack","msgpack_default","protocolMessageFromDeserialized","fromDeserializedIncludingDependencies","module","exports","__toCommonJS","Platform","globalObject","global","window","self","pad","timeSegment","three","padStart","getHandler","logger","Config","logTimestamps","msg","time","Date","getHours","getMinutes","getSeconds","getMilliseconds","getDefaultLoggers","_a2","consoleLogger","errorLogger","console","log","args","apply","warn","map","_Logger","constructor","logLevel","LOG_DEFAULT","initLogHandlers","logHandler","logErrorHandler","logActionNoStrip","level","action","message","shouldLog","renamedClientOption","oldName","newName","deprecationWarning","renamedMethod","className","LOG_NONE","LOG_ERROR","LOG_MAJOR","LOG_MINOR","LOG_MICRO","LOG_DEBUG","logAction","deprecated","description","setLog","handler","Logger","logger_default","utils_exports","Format","allSame","allToLowerCase","allToUpperCase","arrChooseN","arrDeleteValue","arrEquals","arrIntersect","arrIntersectOb","arrPopRandomElement","arrSubtract","arrWithoutValue","cheapRandStr","containsValue","copy","createMissingPluginError","dataSizeBytes","decodeBody","encodeBody","ensureArray","forInOwnNonNullProperties","getBackoffCoefficient","getGlobalObject","getJitterCoefficient","getRetryTime","inherits","inspectBody","inspectError","intersect","isEmpty","isErrorInfoOrPartialErrorInfo","isNil","isObject","keysArray","matchDerivedChannel","mixin","parseQueryString","prototypicalClone","randomString","shallowClone","shallowEquals","throwMissingPluginError","toBase64","toQueryString","valuesArray","whenPromiseSettles","toString","err","result","name","statusCode","code","cause","href","indexOf","ErrorInfo","_ErrorInfo","Error","Object","setPrototypeOf","prototype","fromValues","values","inspect","assign","PartialErrorInfo","_PartialErrorInfo","randomPosn","arrOrStr","Math","floor","random","length","target","i","source","key","hasOwnProperty","call","src","obj","Array","isArray","ob","prop","arg","ownProperties","F","ctor","superCtor","super_","val","arr","arr1","arr2","member","push","element","idx","res","splice","newArr","slice","ownOnly","fn","first","every","item","Format2","params","parts","encodeURIComponent","join","query","match","search","exec","decodeURIComponent","_b","body","BufferUtils","isBuffer","data","byteLength","stringByteSize","String","substr","numBytes","buffer","getRandomArrayBuffer","base64Encode","n2","numItems","min","mutableArr","promise","callback","then","catch","MsgPack","format","decode","JSON","parse","encode","stringify","toLowerCase","toUpperCase","count","initialTimeout","retryAttempt","keys","regex","qualifierParam","channelName","str","bufferUtils","textBuffer","utf8Encode","a","b","pluginName","version","agent","Defaults","ENVIRONMENT","REST_HOST","REALTIME_HOST","FALLBACK_HOSTS","PORT","TLS_PORT","TIMEOUTS","disconnectedRetryTimeout","suspendedRetryTimeout","httpRequestTimeout","channelRetryTimeout","fallbackRetryTimeout","connectionStateTtl","realtimeRequestTimeout","recvTimeout","webSocketConnectTimeout","webSocketSlowTimeout","httpMaxRetryCount","maxMessageSize","protocolVersion","getHost","getPort","getHttpScheme","environmentFallbackHosts","getFallbackHosts","getHosts","checkHost","objectifyOptions","normaliseOptions","defaultGetHeaders","defaultPostHeaders","options","host","ws","restHost","realtimeHost","tls","tlsPort","port","environment","fallbackHosts","hosts","concat","getRealtimeHost","production","getTimeouts","timeouts","getAgentString","agentStr","agents","agent2","allowKeyOrToken","sourceForErrorMessage","modularPluginsToInclude","optionsObj","token","__spreadProps","__spreadValues","plugins","recover","closeOnUnload","queueMessages","forEach","useBinaryProtocol","supportsBinary","preferBinary","headers","clientId","idempotentRestPublishing","connectivityCheckParams","connectivityCheckUrl","uri","qs","split","normaliseChannelOptions","Crypto2","channelOptions","cipher","getCipher","cipherParams","channelCipher","contentTypes","json","xml","html","defaultHeadersOptions","accept","contentType","defaults_default","getDefaults","platformDefaults","Multicaster","_Multicaster","members","e","stack","createPromise","Promise","resolve","reject","resolveAll","rejectAll","create","instance","multicaster_default","HttpMethods","HttpMethods2","HttpMethods_default","HttpStatusCodes","HttpStatusCodes2","isSuccessCode","HttpStatusCodes_default","MAX_TOKEN_LENGTH","pow","isRealtime","client","connection","normaliseAuthcallbackError","hmac","text","keyBuffer","digest","hmacSha256","c14n","capability","c14nCapability","sort","logAndValidateTokenAuthMethod","authOptions","authCallback","authUrl","tokenDetails","basicAuthForced","useTokenAuth","noWayToRenew","trId","getTokenRequestId","Auth","tokenParams","defaultTokenParams","currentTokenRequestId","waitingForTokenRequest","_saveTokenOptions","_saveBasicOptions","authorize","_forceNewToken","connectionManager","onAuthUpdated","tokenDetails2","Forbidden","actOnErrorFromAuthorize","_ensureValidAuthCredentials","timestamp","queryTime","requestToken","resolvedAuthOptions","resolvedTokenParams","tokenRequestCallback","cb","authHeaders","usePost","authMethod","providedQsParams","queryIdx","authParams","authUrlRequestCallback","error","contentTypeHeaderOrHeaders","unpacked","http","doUri","Post","Get","createTokenRequest","tokenRequest","signedTokenParams","tokenCb","keyName","path","tokenUri","baseUri","requestHeaders","do","tokenRequestCallbackTimeoutExpired","timeoutLength","tokenRequestCallbackTimeout","setTimeout","tokenRequestOrDetails","clearTimeout","objectSize","suppressMaxLengthCheck","err2","tokenResponse","keyParts","keySecret","request","ttl","getTimestamp","nonce","signText","mac","getAuthParams","method","access_token","getAuthHeaders","authorization","basicKey","isTimeOffsetSet","getTimestampUsingOffset","now","serverTimeOffset","_userSetClientId","forceSupersede","_tokenClientIdMismatch","expires","tokenRequestId","caughtError","multicaster","_uncheckedSetClientId","tokenClientId","isTokenErr","revokeTokens","specifiers","rest","auth_default","paramString","paramPairs","needle","appendingParams","logResult","logRequest","Http","platformHttp","checkConnectivity","supportsAuthHeaders","supportsLinkHeaders","_getHosts","connectionHost","uriFromHost","currentFallback","_currentFallback","validUntil","shouldFallback","tryAHost","candidateHosts","persistOnSuccess","shift","BaseClient","_c","_d","_e","_f","_g","_h","_additionalHTTPRequestImplementations","_MsgPack","normalOptions","keyMatch","auth","_rest","_Crypto","Crypto","__FilteredSubscriptions","MessageInteractions","_FilteredSubscriptions","channels","stats","version2","customHeaders","batchPublish","specOrSpecs","batchPresence","logOptions","baseclient_default","DeviceDetails","_DeviceDetails","toJSON","id","deviceSecret","platform","formFactor","metadata","deviceIdentityToken","recipient","state","toRequestBody","fromResponseBody","fromValuesArray","devicedetails_default","withAuthDetails","opCallback","unenvelope","NoContent","wrappedStatusCode","response","wrappedHeaders","wrappedErr","logResult2","Resource","_Resource","get","envelope","throwError","delete","Delete","post","patch","Patch","put","Put","doRequest","headers2","params2","decodedBody","decodeErr","httpResult","resource_default","getRelParams","linkUrl","urlMatch","parseRelLinks","linkHeader","relParams","linkMatch","returnErrOnly","useHPR","PaginatedResource","bodyHandler","useHttpPaginatedResponse","handlePage","items","HttpPaginatedResponse","PaginatedResult","resource","self2","current","next","hasNext","isLast","success","errorCode","errorMessage","paginatedresource_default","_PushChannelSubscription","channel","deviceId","PushChannelSubscription","pushchannelsubscription_default","Push","admin","Admin","deviceRegistrations","DeviceRegistrations","channelSubscriptions","ChannelSubscriptions","publish","payload","pushFullWait","fullWait","requestBody","save","device","deviceIdOrDetails","list","remove","removeWhere","_ChannelSubscriptions","subscription","listChannels","parsedBody","push_default","normaliseContext","context","baseEncodedPreviousPayload","normalizeCipherOptions","getMessageSize","size","extras","fromEncoded","encoded","inputOptions","fromEncodedArray","encodedArray","all","encrypt","encoding","ciphertext","algorithm","nativeDataType","encodeArray","messages","serialize","inputContext","lastPayload","xforms","lastProcessedEncodingIndex","encodingsToProcess","xform","base64Decode","utf8Decode","xformAlgorithm","decrypt","vcdiff","Uint8Array","deltaBase","deltaBaseBuffer","toBuffer","arrayBufferViewToBuffer","Message","getMessagesSize","total","arguments","connectionId","connectionKey","message_default","actions","toActionValue","actionString","fromEncoded2","fromValues2","decode2","fromEncodedArray2","stringifyAction","PresenceMessage","fromResponseBody2","fromValuesArray2","fromData","isSynthesized","substring","parseId","msgSerial","parseInt","index","presencemessage_default","RestPresence","presenceMixin","basePath","history","restpresence_default","MSG_ID_ENTROPY_BYTES","allEmptyIds","RestChannel","presence","setOptions","channelMixin","second","msgIdBase","_publish","status","restchannel_default","Stats","_Stats","entries","schema","appId","inProgress","unit","intervalId","stats_default","RestChannelMixin","RestPresenceMixin","Channels","statsValues","timeUri","encoder","decoder","_method","paginatedResource","resbody","methods","includes","methodsWithBody","requestBodyDTO","singleSpecMode","batchResults","channelsParam","resolvedOptions","targets","specifier","type","value","release","BaseRest","allCommonModularPlugins","DefaultMessage","DefaultPresenceMessage","_DefaultRest","newValue","_Http","callListener","eventThis","listener","removeListener","targetListeners","eventFilter","listeners","eventName","targetListenersIndex","EventEmitter","any","events","anyOnce","eventsOnce","on","event","off","firstArg","secondArg","emit","eventsOnceListeners","eventsListeners","once","argCount","listenerWrapper","innerArgs","whenState","targetState","currentState","eventemitter_default","actions2","HEARTBEAT","ACK","NACK","CONNECT","CONNECTED","DISCONNECT","DISCONNECTED","CLOSE","CLOSED","ERROR","ATTACH","ATTACHED","DETACH","DETACHED","PRESENCE","MESSAGE","SYNC","AUTH","ACTIVATE","ActionName","flags","HAS_PRESENCE","HAS_BACKLOG","RESUMED","TRANSIENT","ATTACH_RESUME","PUBLISH","SUBSCRIBE","PRESENCE_SUBSCRIBE","flagNames","MODE_ALL","toStringArray","array","channelModes","serialize2","deserialize","serialized","presenceMessagePlugin","deserialized","fromDeserialized","presenceMessageFromValues","ProtocolMessage","presenceMessagesFromValuesArray","fromValues3","simpleAttributes","attribute","attribIndex","accessToken","filter","hasFlag","stringifiedParams","flag","setFlag","getMode","encodeModesToFlags","modes","mode","decodeModesFromFlags","protocolmessage_default","MessageQueue","last","copyAll","append","prepend","unshift","completeMessages","serial","startSerial","endSerial","completeAllMessages","Number","MAX_SAFE_INTEGER","MAX_VALUE","resetSendAttempted","sendAttempted","clear","messagequeue_default","PendingMessage","merged","ackRequired","Protocol","transport","messageQueue","onAck","onNack","onceIdle","send","pendingMessage","realtime","_RealtimePresence","getTransport","getPendingMessages","clearPendingMessages","finish","disconnect","protocol_default","ConnectionStateChange","previous","retryIn","reason","connectionstatechange_default","ConnectionErrorCodes","SUSPENDED","FAILED","CLOSING","UNKNOWN_CONNECTION_ERR","UNKNOWN_CHANNEL_ERR","ConnectionErrors","disconnected","suspended","failed","closing","closed","unknownConnectionErr","unknownChannelErr","isRetriable","connectionerrors_default","closeMessage","disconnectMessage","Transport","forceJsonProtocol","heartbeats","isConnected","isFinished","isDisposed","maxIdleInterval","idleTimer","lastActivity","connect","close","requestClose","requestDisconnect","fail","dispose","onProtocolMessage","shortName","onActivity","onConnect","connectionDetails","onClose","onDisconnect","onChannelMessage","onFatalError","maxPromisedIdle","ping","setIdleTimer","timeout","onIdleTimerExpire","sinceLast","timeRemaining","tryConnect","transportCtor","transportParams","transportAttemptTimer","errorCb","isAvailable","transport_default","TransportNames","TransportNames2","WebSocket","Comet","XhrPolling","globalObject2","haveWebStorage","WebStorage","localSupported","haveSessionStorage","sessionSupported","noop","transportPreferenceName","sessionRecoveryName","getSessionRecoverData","getSession","setSessionRecoverData","setSession","clearSessionRecoverData","removeSession","bundleWith","dest","maxSize","kind","proposed","decodeRecoveryKey","recoveryKey","TransportParams","getConnectParams","resume","recoveryContext","echoMessages","echo","stream","v","ConnectionManager","_ConnectionManager","supportedTransports","disconnectedRetryCount","pendingChannelMessagesState","isProcessing","queue","initTransports","connectingTimeout","states","initialized","terminal","queueEvents","sendEvents","failState","connecting","retryDelay","connected","errorReason","queuedMessages","transports","defaultTransports","transportPreference","webSocketTransportAvailable","baseTransport","httpHosts","wsHosts","activeProtocol","lastAutoReconnectAttempt","forceFallbackHost","connectCounter","wsCheckResult","webSocketSlowTimer","webSocketGiveUpTimer","abandonedWebSocket","addEventListener","persistConnection","bind","requestState","pendingTransport","disconnectAllTransports","startConnect","additionalImplementations","storage","implementations","Transports","bundledImplementations","order","transportName","_additionalTransportImplementations","createTransportParams","getTransportParams","decideMode","modeCb","recoverFn","lastSessionData","shouldRecover","tryATransport","candidate","proposedTransport","notifyState","setTransportPending","cancelWebSocketSlowTimer","cancelWebSocketGiveUpTimer","activateTransport","unpersistConnection","deactivateTransport","persistTransportPreference","existingState","connectedState","existingActiveProtocol","setConnection","onConnectionDetailsUpdate","nextTick","connectedErr","_connectionId","connectionDetails2","currentProtocol","wasActive","wasPending","noTransportsScheduledForActivation","queuePendingMessages","unpersistTransportPreference","retryImmediately","newConnectionState","hasConnectionError","prevConnId","connIdChanged","recoverFailure","clearConnection","createRecoveryKey","channelSerials","checkConnectionStateFreshness","disconnectedAt","location","getError","getStateError","activeState","enactStateChange","stateChange","newState","startTransitionTimer","transitionState","transitionTimer","cancelTransitionTimer","startSuspendTimer","suspendTimer","checkSuspendTimer","cancelSuspendTimer","startRetryTimer","interval","retryTimer","cancelRetryTimer","startWebSocketSlowTimer","checkWsConnectivity","connectivity","startWebSocketGiveUpTimer","connectBase","indicated","change","autoReconnect","sendQueuedMessages","propogateConnectionInterruption","failQueuedMessages","closeImpl","connectCount","recoverChannels","connectImpl","authCb","getTransportPreference","connectWs","tryTransportWithFallbacks","shouldContinue","giveUp","hostAttemptCb","fatal","tryFallbackHosts","activeTransport","authMsg","successListener","failureListener","queueEvent","sendImpl","shouldQueue","lastQueued","pendingMessages","numQueued","processNextPendingChannelMessage","pendingChannelMessage","processChannelMessage","finally","onTimeout","onHeartbeat","pingStart","responseId","timer","responseTime","completed","onPingComplete","onTransportActive","abort","set","wsConnectivityUrl","finished","onopen","onclose","onerror","connectionmanager_default","Connection","ably","connection_default","ChannelStateChange","resumed","hasBacklog","channelstatechange_default","noop2","validateChannelOptions","currentMode","RealtimeChannel","_RealtimeChannel","retryCount","restMixin","untilAttach","properties","attachSerial","from_serial","_presence","RealtimePresence","subscriptions","syncChannelSerial","channelSerial","_requestedFlags","_mode","_attachResume","_decodingContext","_lastPayload","messageId","protocolMessageChannelSerial","decodeFailureRecoveryInProgress","_allChannelChanges","invalidStateError","processListenerArgs","previousChannelOptions","_shouldReattachToSetOptions","attachImpl","prevOptions","requestedParams","omitAgent","existingParams","sendMessage","onEvent","attach","_attach","forceReattach","attachReason","attachMsg","detach","detachImpl","subscribe","subscribeFilter","unsubscribe","filteredSubscriptions","has","getAndDeleteFilteredSubscriptions","l","sync","syncMessage","sendPresence","processMessage","setChannelSerial","isSync","modesFromFlags","hasPresence","onAttached","updateOnAttached","checkPendingState","detachErr","presenceMsg","setPresence","firstMessage","lastMessage","delta","from","_startDecodeFailureRecovery","clearStateTimer","actOnChannelState","cmState","startStateTimerIfNotRunning","timeoutPendingState","stateTimer","getReleaseErr","s","channelParams","_","paramsWithoutAgent","__objRest","realtimechannel_default","BaseRealtime","_BaseRealtime","transportImplementationsFromPlugins","_channels","Channels2","autoConnect","WebSocketTransport","XHRPolling","serials","connectionState","connectionStateToChannelState","fromChannelStates","toChannelState","channelId","getDerived","deriveOptions","releaseErr","baserealtime_default","getClientId","realtimePresence","isAnonymousOrWildcard","waitAttached","newerThan","existing","itemOrderings","existingOrderings","syncComplete","PresenceMap","_myMembers","pendingPresence","enter","_enterOrUpdateClient","update","enterClient","updateClient","leave","leaveClient","waitForSync","returnMembers","waitSync","presenceSet","syncCursor","myMembers","broadcastMessages","connId","startSync","endSync","_synthesizeLeaves","_ensureMyMembersPresent","pendingPresCount","presenceArray","_clearMyMembers","failPendingPresence","reenterCb","memberKey","entry","_args","syncInProgress","residualMembers","getClient","existingItem","setInProgress","realtimepresence_default","isNodeWebSocket","useProtocolHeartbeats","wsHost","createWebSocket","connectParams","wsScheme","wsUri","paramStr","param","wsConnection","binaryType","onWsOpen","ev","onWsClose","onmessage","onWsData","onWsError","wasClean","websockettransport_default","FilteredSubscriptions","filteredListener","m","mapping","refTimeserial","ref","timeserial","refType","isRef","find","addFilteredSubscription","realListener","Map","realListenerMap","filterMaps","listenerMaps","reduce","prev","cur","listeners2","_DefaultRealtime","Utils","uint8Array","uint32Array","Uint32Array","DEFAULT_STATE","ROUND_CONSTANTS","M","getFractionalBits","n","nPrime","isPrime","factor","LittleEndian","convertEndian","word","rightRotate","bits","sha256","STATE","legth","bitLength","newBitLength","bytes","words","round","block","workingState","MRound","gamma0x","gamma1x","t1","t2","hmac2","tmp","innerKey","outerKey","base64CharSet","hexCharSet","uint8ViewToBase64","base64","encodings","byteRemainder","mainLength","c","d","chunk","base64ToArrayBuffer","binary_string","atob","len","ascii","charCodeAt","ArrayBuffer","isView","toArrayBuffer","hexEncode","arrayBuffer","byteOffset","uint8Array2","accum","byte","hexDecode","hexEncodedBytes","string","TextEncoder","TextDecoder","areBuffersEqual","buffer1","buffer2","arrayBuffer1","arrayBuffer2","bytes1","bytes2","arrayBufferView","bufferutils_default","createCryptoClass","config","DEFAULT_ALGORITHM","DEFAULT_KEYLENGTH","DEFAULT_MODE","DEFAULT_BLOCKLENGTH","validateCipherParams","keyLength","normaliseBase64","replace","isCipherParams","CipherParams","getDefaultParams","generateRandomKey","CBCCipher","iv","crypto","subtle","isSecureContext","webCryptoAlgorithm","output","outputView","DataView","buffer1View","setInt8","getInt8","buffer2View","plaintext","getIv","cryptoKey","importKey","ciphertextArrayBuffer","ciphertextBody","randomBlock","XHRStates","XHRStates2","XHRStates_default","createMissingImplementationError","_a","Http2","checksInProgress","connectivityUrlIsDefault","requestImplementations","bundledRequestImplementations","xhrRequestImplementation","XHRRequest","fetchRequestImplementation","FetchRequest","hasImplementation","xhrSupported","Request","_a3","req","createRequest","REQ_SEND","body2","disableConnectivityCheck","requestResult","fetchSupported","errorInfo","methodsWithoutBody","http_default","globalObject3","Window","WorkerGlobalScope","allowComet","loc","origin","isWebWorkerContext","userAgent","navigator","currentUrl","fetch","XMLHttpRequest","setImmediate","f","byteArray","getRandomValues","isWebworker","config_default","shouldBeErrorAction","UNRESOLVABLE_ERROR_CODES","protocolMessageFromRawError","CometTransport","sendRequest","recvRequest","pendingCallback","pendingItems","cometScheme","connectUri","preconnected","connectRequest","REQ_RECV_STREAM","REQ_RECV","onData","recv","_requestCloseOrDisconnect","closeOrDisconnectUri","closeUri","disconnectUri","connectionStr","baseConnectionUri","sendUri","recvUri","sendItems","sendAnyPending","encodeRequest","REQ_RECV_POLL","responseData","decodeResponse","requestItems","comettransport_default","isAblyError","responseBody","getAblyError","noop3","idCounter","pendingRequests","getHeader","xhr","header","getResponseHeader","isEncodingChunked","getHeadersAsObject","headerPairs","getAllResponseHeaders","trim","x","_XHRRequest","requestMode","rnd","timedOut","requestComplete","_timeouts","complete","responseType","open","withCredentials","h","setRequestHeader","errorHandler","errorEvent","statusCode2","statusText","onabort","ontimeout","streaming","successResponse","streamPos","onResponse","onEnd","parsedResponse","jsonResponseBody","responseText","onProgress","bodyEnd","onChunk","onStreamEnd","streamComplete","onreadystatechange","readyState","xhrrequest_default","shortName2","XHRPollingTransport","xhrpollingtransport_default","web_socket","xhr_polling","transport_default2","test","globalObject4","Webstorage","sessionStorage","setItem","removeItem","localStorage","_get","_remove","_set","session","wrappedValue","storageInterface","rawItem","getItem","webstorage_default","Defaults2","defaults_default2","view","byte_","getUint8","utf8Write","offset","codePoint","setUint8","utf8Read","end","fromCharCode","utf8ByteCount","encode2","sparse","sizeof","_encode","SH_L_32","SH_R_32","getInt64","getInt32","getUint32","getUint64","setInt64","setInt32","setUint32","setUint64","Decoder","bin","buf","ext","getUint16","getFloat32","getFloat64","getInt16","decode3","encodeableKeys","setUint16","setFloat64","setInt16","isAblyError2","getAblyError2","convertHeaders","fetchRequest","fetchHeaders","Headers","controller","AbortController","timeoutPromise","requestInit","credentials","resultPromise","URLSearchParams","ok","race","defaultBundledRequestImplementations","clientClass"],"sources":["/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/index.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/platform.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/util/logger.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/util/utils.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/types/errorinfo.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/package.json","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/util/defaults.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/util/multicaster.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/constants/HttpMethods.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/constants/HttpStatusCodes.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/auth.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/types/http.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/baseclient.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/types/devicedetails.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/resource.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/paginatedresource.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/types/pushchannelsubscription.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/push.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/types/message.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/types/presencemessage.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/restpresence.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/restchannel.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/types/stats.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/restchannelmixin.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/restpresencemixin.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/rest.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/baserest.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/modularplugins.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/types/defaultmessage.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/types/defaultpresencemessage.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/defaultrest.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/util/eventemitter.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/types/protocolmessage.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/transport/messagequeue.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/transport/protocol.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/connectionstatechange.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/transport/connectionerrors.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/transport/transport.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/constants/TransportName.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/transport/connectionmanager.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/connection.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/channelstatechange.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/realtimechannel.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/baserealtime.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/realtimepresence.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/transport/websockettransport.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/filteredsubscriptions.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/client/defaultrealtime.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/lib/util/hmac-sha256.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/lib/util/bufferutils.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/lib/util/crypto.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/constants/XHRStates.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/lib/http/http.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/config.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/common/lib/transport/comettransport.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/lib/http/request/xhrrequest.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/lib/transport/xhrpollingtransport.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/lib/transport/index.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/lib/util/webstorage.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/lib/util/defaults.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/lib/util/msgpack.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/lib/http/request/fetchrequest.ts","/Users/trinhduong/chatroom2/my-react-app/node_modules/ably/src/platform/web/lib/http/request/index.ts"],"sourcesContent":["// Common\r\nimport { DefaultRest } from '../../common/lib/client/defaultrest';\r\nimport { DefaultRealtime } from '../../common/lib/client/defaultrealtime';\r\nimport Platform from '../../common/platform';\r\nimport ErrorInfo from '../../common/lib/types/errorinfo';\r\nimport { fromDeserializedIncludingDependencies as protocolMessageFromDeserialized } from '../../common/lib/types/protocolmessage';\r\n\r\n// Platform Specific\r\nimport BufferUtils from './lib/util/bufferutils';\r\n// @ts-ignore\r\nimport { createCryptoClass } from './lib/util/crypto';\r\nimport Http from './lib/http/http';\r\nimport Config from './config';\r\n// @ts-ignore\r\nimport Transports from './lib/transport';\r\nimport Logger from '../../common/lib/util/logger';\r\nimport { getDefaults } from '../../common/lib/util/defaults';\r\nimport WebStorage from './lib/util/webstorage';\r\nimport PlatformDefaults from './lib/util/defaults';\r\nimport msgpack from './lib/util/msgpack';\r\nimport { defaultBundledRequestImplementations } from './lib/http/request';\r\n\r\nconst Crypto = createCryptoClass(Config, BufferUtils);\r\n\r\nPlatform.Crypto = Crypto;\r\nPlatform.BufferUtils = BufferUtils;\r\nPlatform.Http = Http;\r\nPlatform.Config = Config;\r\nPlatform.Transports = Transports;\r\nPlatform.WebStorage = WebStorage;\r\n\r\nfor (const clientClass of [DefaultRest, DefaultRealtime]) {\r\n  clientClass.Crypto = Crypto;\r\n  clientClass._MsgPack = msgpack;\r\n}\r\n\r\nHttp.bundledRequestImplementations = defaultBundledRequestImplementations;\r\n\r\nLogger.initLogHandlers();\r\n\r\nPlatform.Defaults = getDefaults(PlatformDefaults);\r\n\r\nif (Platform.Config.agent) {\r\n  // @ts-ignore\r\n  Platform.Defaults.agent += ' ' + Platform.Config.agent;\r\n}\r\n\r\nexport { DefaultRest as Rest, DefaultRealtime as Realtime, msgpack, protocolMessageFromDeserialized };\r\n\r\nexport default {\r\n  ErrorInfo,\r\n  Rest: DefaultRest,\r\n  Realtime: DefaultRealtime,\r\n  msgpack,\r\n};\r\n","import { IPlatformConfig } from './types/IPlatformConfig';\r\nimport { IPlatformHttpStatic } from './types/http';\r\nimport IDefaults from './types/IDefaults';\r\nimport IWebStorage from './types/IWebStorage';\r\nimport IBufferUtils from './types/IBufferUtils';\r\nimport * as WebBufferUtils from '../platform/web/lib/util/bufferutils';\r\nimport * as NodeBufferUtils from '../platform/nodejs/lib/util/bufferutils';\r\nimport { IUntypedCryptoStatic } from '../common/types/ICryptoStatic';\r\nimport TransportName from './constants/TransportName';\r\nimport { TransportCtor } from './lib/transport/transport';\r\n\r\nexport type Bufferlike = WebBufferUtils.Bufferlike | NodeBufferUtils.Bufferlike;\r\ntype BufferUtilsOutput = WebBufferUtils.Output | NodeBufferUtils.Output;\r\ntype ToBufferOutput = WebBufferUtils.ToBufferOutput | NodeBufferUtils.ToBufferOutput;\r\n\r\nexport type TransportImplementations = Partial<Record<TransportName, TransportCtor>>;\r\n\r\nexport default class Platform {\r\n  static Config: IPlatformConfig;\r\n  /*\r\n     What we actually _want_ is for Platform to be a generic class\r\n     parameterised by Bufferlike etc, but that requires far-reaching changes to\r\n     components that make use of Platform. So instead we have to advertise a\r\n     BufferUtils object that accepts a broader range of data types than it\r\n     can in reality handle.\r\n   */\r\n  static BufferUtils: IBufferUtils<Bufferlike, BufferUtilsOutput, ToBufferOutput>;\r\n  /*\r\n     Weâ€™d like this to be ICryptoStatic with the correct generic arguments,\r\n     but Platform doesnâ€™t currently allow that, as described in the BufferUtils\r\n     comment above.\r\n   */\r\n  static Crypto: IUntypedCryptoStatic | null;\r\n  static Http: IPlatformHttpStatic;\r\n  static Transports: {\r\n    order: TransportName[];\r\n    // Transport implementations that always come with this platform\r\n    bundledImplementations: TransportImplementations;\r\n  };\r\n  static Defaults: IDefaults;\r\n  static WebStorage: IWebStorage | null;\r\n}\r\n","import Platform from 'common/platform';\r\n\r\nexport type LoggerOptions = {\r\n  handler: LoggerFunction;\r\n  level: LogLevels;\r\n};\r\ntype LoggerFunction = (...args: string[]) => void;\r\n\r\n// Workaround for salesforce lightning locker compatibility\r\n// This is a shorthand version of Utils.getGlobalObject (which we can't use here without creating a circular import)\r\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\r\n\r\nenum LogLevels {\r\n  None = 0,\r\n  Error = 1,\r\n  Major = 2,\r\n  Minor = 3,\r\n  Micro = 4,\r\n}\r\n\r\nfunction pad(timeSegment: number, three?: number) {\r\n  return `${timeSegment}`.padStart(three ? 3 : 2, '0');\r\n}\r\n\r\nfunction getHandler(logger: Function): Function {\r\n  return Platform.Config.logTimestamps\r\n    ? function (msg: unknown) {\r\n        const time = new Date();\r\n        logger(\r\n          pad(time.getHours()) +\r\n            ':' +\r\n            pad(time.getMinutes()) +\r\n            ':' +\r\n            pad(time.getSeconds()) +\r\n            '.' +\r\n            pad(time.getMilliseconds(), 1) +\r\n            ' ' +\r\n            msg,\r\n        );\r\n      }\r\n    : logger;\r\n}\r\n\r\nconst getDefaultLoggers = (): [Function, Function] => {\r\n  let consoleLogger;\r\n  let errorLogger;\r\n\r\n  // we expect ably-js to be run in environments which have `console` object available with its `log` function\r\n  if (typeof globalObject?.console?.log === 'function') {\r\n    consoleLogger = function (...args: unknown[]) {\r\n      console.log.apply(console, args);\r\n    };\r\n\r\n    errorLogger = console.warn\r\n      ? function (...args: unknown[]) {\r\n          console.warn.apply(console, args);\r\n        }\r\n      : consoleLogger;\r\n  } else {\r\n    // otherwise we should fallback to noop for log functions\r\n    consoleLogger = errorLogger = function () {};\r\n  }\r\n\r\n  return [consoleLogger, errorLogger].map(getHandler) as [Function, Function];\r\n};\r\n\r\nclass Logger {\r\n  private static logLevel: LogLevels = LogLevels.Error; // default logLevel\r\n  private static logHandler: Function;\r\n  private static logErrorHandler: Function;\r\n\r\n  // public constants\r\n  static readonly LOG_NONE: LogLevels = LogLevels.None;\r\n  static readonly LOG_ERROR: LogLevels = LogLevels.Error;\r\n  static readonly LOG_MAJOR: LogLevels = LogLevels.Major;\r\n  static readonly LOG_MINOR: LogLevels = LogLevels.Minor;\r\n  static readonly LOG_MICRO: LogLevels = LogLevels.Micro;\r\n  // aliases\r\n  static readonly LOG_DEFAULT: LogLevels = LogLevels.Error;\r\n  static readonly LOG_DEBUG: LogLevels = LogLevels.Micro;\r\n\r\n  constructor() {\r\n    Logger.logLevel = Logger.LOG_DEFAULT;\r\n  }\r\n\r\n  static initLogHandlers() {\r\n    const [logHandler, logErrorHandler] = getDefaultLoggers();\r\n    this.logHandler = logHandler;\r\n    this.logErrorHandler = logErrorHandler;\r\n  }\r\n\r\n  /* public static functions */\r\n  /**\r\n   * In the modular variant of the SDK, the `stripLogs` esbuild plugin strips out all calls to this method (when invoked as `Logger.logAction(...)`) except when called with level `Logger.LOG_ERROR`. If you wish for a log statement to never be stripped, use the {@link logActionNoStrip} method instead.\r\n   *\r\n   * The aforementioned plugin expects `level` to be an expression of the form `Logger.LOG_*`; that is, you canâ€™t dynamically specify the log level.\r\n   */\r\n  static logAction = (level: LogLevels, action: string, message?: string) => {\r\n    this.logActionNoStrip(level, action, message);\r\n  };\r\n\r\n  /**\r\n   * Calls to this method are never stripped by the `stripLogs` esbuild plugin. Use it for log statements that you wish to always be included in the modular variant of the SDK.\r\n   */\r\n  static logActionNoStrip(level: LogLevels, action: string, message?: string) {\r\n    if (Logger.shouldLog(level)) {\r\n      (level === LogLevels.Error ? Logger.logErrorHandler : Logger.logHandler)('Ably: ' + action + ': ' + message);\r\n    }\r\n  }\r\n\r\n  static deprecated = (description: string, msg: string) => {\r\n    Logger.deprecationWarning(`${description} is deprecated and will be removed in a future version. ${msg}`);\r\n  };\r\n\r\n  static renamedClientOption(oldName: string, newName: string) {\r\n    Logger.deprecationWarning(\r\n      `The \\`${oldName}\\` client option has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`,\r\n    );\r\n  }\r\n\r\n  static renamedMethod(className: string, oldName: string, newName: string) {\r\n    Logger.deprecationWarning(\r\n      `\\`${className}\\`â€™s \\`${oldName}\\` method has been renamed to \\`${newName}\\`. Please update your code to use \\`${newName}\\` instead. \\`${oldName}\\` will be removed in a future version.`,\r\n    );\r\n  }\r\n\r\n  static deprecationWarning(message: string) {\r\n    if (Logger.shouldLog(LogLevels.Error)) {\r\n      Logger.logErrorHandler(`Ably: Deprecation warning - ${message}`);\r\n    }\r\n  }\r\n\r\n  /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\r\n\t   the object being serialised if the log level will not output the message */\r\n  static shouldLog = (level: LogLevels) => {\r\n    return level <= Logger.logLevel;\r\n  };\r\n\r\n  static setLog = (level: LogLevels | undefined, handler: Function | undefined) => {\r\n    if (level !== undefined) Logger.logLevel = level;\r\n    if (handler !== undefined) Logger.logHandler = Logger.logErrorHandler = handler;\r\n  };\r\n}\r\n\r\nexport default Logger;\r\n","import Platform from 'common/platform';\r\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport { ModularPlugins } from '../client/modularplugins';\r\nimport { MsgPack } from 'common/types/msgpack';\r\n\r\nfunction randomPosn(arrOrStr: Array<unknown> | string) {\r\n  return Math.floor(Math.random() * arrOrStr.length);\r\n}\r\n\r\n/**\r\n * Add a set of properties to a target object\r\n *\r\n * @param target the target object\r\n * @param args objects, which enumerable properties are added to target, by reference only\r\n * @returns target object with added properties\r\n */\r\nexport function mixin(\r\n  target: Record<string, unknown>,\r\n  ...args: Array<object | undefined | null>\r\n): Record<string, unknown> {\r\n  for (let i = 0; i < args.length; i++) {\r\n    const source = args[i];\r\n    if (!source) {\r\n      break;\r\n    }\r\n\r\n    for (const key in source) {\r\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n        target[key] = (source as Record<string, unknown>)[key];\r\n      }\r\n    }\r\n  }\r\n  return target;\r\n}\r\n\r\n/**\r\n * Creates a copy of enumerable properties of the source object\r\n *\r\n * @param src object to copy\r\n * @returns copy of src\r\n */\r\nexport function copy<T = Record<string, unknown>>(src: T | Record<string, unknown> | null | undefined): T {\r\n  return mixin({}, src as Record<string, unknown>) as T;\r\n}\r\n\r\n/*\r\n * Ensures that an Array object is always returned\r\n * returning the original Array of obj is an Array\r\n * else wrapping the obj in a single element Array\r\n */\r\nexport function ensureArray(obj: Record<string, unknown>): unknown[] {\r\n  if (isNil(obj)) {\r\n    return [];\r\n  }\r\n  if (Array.isArray(obj)) {\r\n    return obj;\r\n  }\r\n  return [obj];\r\n}\r\n\r\nexport function isObject(ob: unknown): ob is Record<string, unknown> {\r\n  return Object.prototype.toString.call(ob) == '[object Object]';\r\n}\r\n\r\n/*\r\n * Determine whether or not an object contains\r\n * any enumerable properties.\r\n * ob: the object\r\n */\r\nexport function isEmpty(ob: Record<string, unknown> | unknown[]): boolean {\r\n  for (const prop in ob) return false;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Checks if `value` is `null` or `undefined`.\r\n *\r\n * Source: https://github.com/lodash/lodash/blob/main/src/isNil.ts\r\n */\r\nexport function isNil(arg: unknown): arg is null | undefined {\r\n  return arg == null;\r\n}\r\n\r\n/*\r\n * Perform a simple shallow clone of an object.\r\n * Result is an object irrespective of whether\r\n * the input is an object or array. All\r\n * enumerable properties are copied.\r\n * ob: the object\r\n */\r\nexport function shallowClone(ob: Record<string, unknown>): Record<string, unknown> {\r\n  const result = new Object() as Record<string, unknown>;\r\n  for (const prop in ob) result[prop] = ob[prop];\r\n  return result;\r\n}\r\n\r\n/*\r\n * Clone an object by creating a new object with the\r\n * given object as its prototype. Optionally\r\n * a set of additional own properties can be\r\n * supplied to be added to the newly created clone.\r\n * ob:            the object to be cloned\r\n * ownProperties: optional object with additional\r\n *                properties to add\r\n */\r\nexport function prototypicalClone(\r\n  ob: Record<string, unknown>,\r\n  ownProperties: Record<string, unknown>,\r\n): Record<string, unknown> {\r\n  class F {}\r\n  F.prototype = ob;\r\n  const result = new F() as Record<string, unknown>;\r\n  if (ownProperties) mixin(result, ownProperties);\r\n  return result;\r\n}\r\n\r\n/*\r\n * Declare a constructor to represent a subclass\r\n * of another constructor\r\n * If platform has a built-in version we use that from Platform, else we\r\n * define here (so can make use of other Utils fns)\r\n * See node.js util.inherits\r\n */\r\nexport const inherits = function (ctor: any, superCtor: Function) {\r\n  if (Platform.Config.inherits) {\r\n    Platform.Config.inherits(ctor, superCtor);\r\n    return;\r\n  }\r\n  ctor.super_ = superCtor;\r\n  ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\r\n};\r\n\r\n/*\r\n * Determine whether or not an object has an enumerable\r\n * property whose value equals a given value.\r\n * ob:  the object\r\n * val: the value to find\r\n */\r\nexport function containsValue(ob: Record<string, unknown>, val: unknown): boolean {\r\n  for (const i in ob) {\r\n    if (ob[i] == val) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function intersect<K extends string, T>(arr: Array<K>, ob: K[] | Partial<Record<K, T>>): K[] {\r\n  return Array.isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\r\n}\r\n\r\nexport function arrIntersect<T>(arr1: Array<T>, arr2: Array<T>): Array<T> {\r\n  const result = [];\r\n  for (let i = 0; i < arr1.length; i++) {\r\n    const member = arr1[i];\r\n    if (arr2.indexOf(member) != -1) result.push(member);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function arrIntersectOb<K extends string>(arr: Array<K>, ob: Partial<Record<K, unknown>>): K[] {\r\n  const result = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const member = arr[i];\r\n    if (member in ob) result.push(member);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function arrSubtract<T>(arr1: Array<T>, arr2: Array<T>): Array<T> {\r\n  const result = [];\r\n  for (let i = 0; i < arr1.length; i++) {\r\n    const element = arr1[i];\r\n    if (arr2.indexOf(element) == -1) result.push(element);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function arrDeleteValue<T>(arr: Array<T>, val: T): boolean {\r\n  const idx = arr.indexOf(val);\r\n  const res = idx != -1;\r\n  if (res) arr.splice(idx, 1);\r\n  return res;\r\n}\r\n\r\nexport function arrWithoutValue<T>(arr: Array<T>, val: T): Array<T> {\r\n  const newArr = arr.slice();\r\n  arrDeleteValue(newArr, val);\r\n  return newArr;\r\n}\r\n\r\n/*\r\n * Construct an array of the keys of the enumerable\r\n * properties of a given object, optionally limited\r\n * to only the own properties.\r\n * ob:      the object\r\n * ownOnly: boolean, get own properties only\r\n */\r\nexport function keysArray(ob: Record<string, unknown>, ownOnly?: boolean): Array<string> {\r\n  const result = [];\r\n  for (const prop in ob) {\r\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\r\n    result.push(prop);\r\n  }\r\n  return result;\r\n}\r\n\r\n/*\r\n * Construct an array of the values of the enumerable\r\n * properties of a given object, optionally limited\r\n * to only the own properties.\r\n * ob:      the object\r\n * ownOnly: boolean, get own properties only\r\n */\r\nexport function valuesArray<T>(ob: Record<string, T>, ownOnly?: boolean): T[] {\r\n  const result = [];\r\n  for (const prop in ob) {\r\n    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop)) continue;\r\n    result.push(ob[prop]);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function forInOwnNonNullProperties(ob: Record<string, unknown>, fn: (prop: string) => void): void {\r\n  for (const prop in ob) {\r\n    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\r\n      fn(prop);\r\n    }\r\n  }\r\n}\r\n\r\nexport function allSame(arr: Array<Record<string, unknown>>, prop: string): boolean {\r\n  if (arr.length === 0) {\r\n    return true;\r\n  }\r\n  const first = arr[0][prop];\r\n  return arr.every(function (item) {\r\n    return item[prop] === first;\r\n  });\r\n}\r\n\r\nexport enum Format {\r\n  msgpack = 'msgpack',\r\n  json = 'json',\r\n}\r\n\r\nexport function arrPopRandomElement<T>(arr: Array<T>): T {\r\n  return arr.splice(randomPosn(arr), 1)[0];\r\n}\r\n\r\nexport function toQueryString(params?: Record<string, string> | null): string {\r\n  const parts = [];\r\n  if (params) {\r\n    for (const key in params) parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));\r\n  }\r\n  return parts.length ? '?' + parts.join('&') : '';\r\n}\r\n\r\nexport function parseQueryString(query: string): Record<string, string> {\r\n  let match;\r\n  const search = /([^?&=]+)=?([^&]*)/g;\r\n  const result: Record<string, string> = {};\r\n\r\n  while ((match = search.exec(query))) result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\r\n\r\n  return result;\r\n}\r\n\r\nexport function isErrorInfoOrPartialErrorInfo(err: unknown): err is ErrorInfo | PartialErrorInfo {\r\n  return typeof err == 'object' && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);\r\n}\r\n\r\nexport function inspectError(err: unknown): string {\r\n  if (\r\n    err instanceof Error ||\r\n    (err as ErrorInfo)?.constructor?.name === 'ErrorInfo' ||\r\n    (err as PartialErrorInfo)?.constructor?.name === 'PartialErrorInfo'\r\n  )\r\n    return (err as Error).toString();\r\n  return Platform.Config.inspect(err);\r\n}\r\n\r\nexport function inspectBody(body: unknown): string {\r\n  if (Platform.BufferUtils.isBuffer(body)) {\r\n    return (body as any).toString();\r\n  } else if (typeof body === 'string') {\r\n    return body;\r\n  } else {\r\n    return Platform.Config.inspect(body);\r\n  }\r\n}\r\n\r\n/* Data is assumed to be either a string or a buffer. */\r\nexport function dataSizeBytes(data: string | Buffer): number {\r\n  if (Platform.BufferUtils.isBuffer(data)) {\r\n    return Platform.BufferUtils.byteLength(data);\r\n  }\r\n  if (typeof data === 'string') {\r\n    return Platform.Config.stringByteSize(data);\r\n  }\r\n  throw new Error('Expected input of Utils.dataSizeBytes to be a buffer or string, but was: ' + typeof data);\r\n}\r\n\r\nexport function cheapRandStr(): string {\r\n  return String(Math.random()).substr(2);\r\n}\r\n\r\n/* Takes param the minimum number of bytes of entropy the string must\r\n * include, not the length of the string. String length produced is not\r\n * guaranteed. */\r\nexport const randomString = async (numBytes: number): Promise<string> => {\r\n  const buffer = await Platform.Config.getRandomArrayBuffer(numBytes);\r\n  return Platform.BufferUtils.base64Encode(buffer);\r\n};\r\n\r\n/* Pick n elements at random without replacement from an array */\r\nexport function arrChooseN<T>(arr: Array<T>, n: number): Array<T> {\r\n  const numItems = Math.min(n, arr.length),\r\n    mutableArr = arr.slice(),\r\n    result: Array<T> = [];\r\n  for (let i = 0; i < numItems; i++) {\r\n    result.push(arrPopRandomElement(mutableArr));\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Uses a callback to communicate the result of a `Promise`. The first argument passed to the callback will be either an error (when the promise is rejected) or `null` (when the promise is fulfilled). In the case where the promise is fulfilled, the resulting value will be passed to the callback as a second argument.\r\n */\r\nexport function whenPromiseSettles<T, E = unknown>(\r\n  promise: Promise<T>,\r\n  callback?: (err: E | null, result?: T) => void,\r\n) {\r\n  promise\r\n    .then((result) => {\r\n      callback?.(null, result);\r\n    })\r\n    .catch((err: unknown) => {\r\n      // We make no guarantees about the type of the error that gets passed to the callback. Issue https://github.com/ably/ably-js/issues/1617 will think about how to correctly handle error types.\r\n      callback?.(err as E);\r\n    });\r\n}\r\n\r\nexport function decodeBody<T>(body: unknown, MsgPack: MsgPack | null, format?: Format | null): T {\r\n  if (format == 'msgpack') {\r\n    if (!MsgPack) {\r\n      throwMissingPluginError('MsgPack');\r\n    }\r\n    return MsgPack.decode(body as Buffer);\r\n  }\r\n\r\n  return JSON.parse(String(body));\r\n}\r\n\r\nexport function encodeBody(body: unknown, MsgPack: MsgPack | null, format?: Format): string | Buffer {\r\n  if (format == 'msgpack') {\r\n    if (!MsgPack) {\r\n      throwMissingPluginError('MsgPack');\r\n    }\r\n    return MsgPack.encode(body, true) as Buffer;\r\n  }\r\n\r\n  return JSON.stringify(body);\r\n}\r\n\r\nexport function allToLowerCase(arr: Array<string>): Array<string> {\r\n  return arr.map(function (element) {\r\n    return element && element.toLowerCase();\r\n  });\r\n}\r\n\r\nexport function allToUpperCase(arr: Array<string>): Array<string> {\r\n  return arr.map(function (element) {\r\n    return element && element.toUpperCase();\r\n  });\r\n}\r\n\r\nexport function getBackoffCoefficient(count: number) {\r\n  return Math.min((count + 2) / 3, 2);\r\n}\r\n\r\nexport function getJitterCoefficient() {\r\n  return 1 - Math.random() * 0.2;\r\n}\r\n\r\n/**\r\n *\r\n * @param initialTimeout initial timeout value\r\n * @param retryAttempt integer indicating retryAttempt\r\n * @returns RetryTimeout value for given timeout and retryAttempt.\r\n * If x is the value generated then,\r\n * Upper bound = min((retryAttempt + 2) / 3, 2) * initialTimeout,\r\n * Lower bound = 0.8 * Upper bound,\r\n * Lower bound < x < Upper bound\r\n */\r\nexport function getRetryTime(initialTimeout: number, retryAttempt: number) {\r\n  return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\r\n}\r\n\r\nexport function getGlobalObject() {\r\n  if (typeof global !== 'undefined') {\r\n    return global;\r\n  }\r\n\r\n  if (typeof window !== 'undefined') {\r\n    return window;\r\n  }\r\n\r\n  return self;\r\n}\r\n\r\nexport function shallowEquals(source: Record<string, unknown>, target: Record<string, unknown>) {\r\n  return (\r\n    Object.keys(source).every((key) => source[key] === target[key]) &&\r\n    Object.keys(target).every((key) => target[key] === source[key])\r\n  );\r\n}\r\n\r\nexport function matchDerivedChannel(name: string) {\r\n  /**\r\n   * This regex check is to retain existing channel params if any e.g [?rewind=1]foo to\r\n   * [filter=xyz?rewind=1]foo. This is to keep channel compatibility around use of\r\n   * channel params that work with derived channels.\r\n   *\r\n   * This eslint unsafe regex warning is triggered because the RegExp uses nested quantifiers,\r\n   * but it does not create any situation where the regex engine has to\r\n   * explore a large number of possible matches so itâ€™s safe to ignore\r\n   */\r\n  const regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/; // eslint-disable-line\r\n  const match = name.match(regex);\r\n  if (!match || !match.length || match.length < 5) {\r\n    throw new ErrorInfo('regex match failed', 400, 40010);\r\n  }\r\n  // Fail if there is already a channel qualifier, eg [meta]foo should fail instead of just overriding with [filter=xyz]foo\r\n  if (match![2]) {\r\n    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);\r\n  }\r\n  // Return match values to be added to derive channel quantifier.\r\n  return {\r\n    qualifierParam: match[3] || '',\r\n    channelName: match[4],\r\n  };\r\n}\r\n\r\nexport function toBase64(str: string) {\r\n  const bufferUtils = Platform.BufferUtils;\r\n  const textBuffer = bufferUtils.utf8Encode(str);\r\n  return bufferUtils.base64Encode(textBuffer);\r\n}\r\n\r\nexport function arrEquals(a: any[], b: any[]) {\r\n  return (\r\n    a.length === b.length &&\r\n    a.every(function (val, i) {\r\n      return val === b[i];\r\n    })\r\n  );\r\n}\r\n\r\nexport function createMissingPluginError(pluginName: keyof ModularPlugins): ErrorInfo {\r\n  return new ErrorInfo(`${pluginName} plugin not provided`, 40019, 400);\r\n}\r\n\r\nexport function throwMissingPluginError(pluginName: keyof ModularPlugins): never {\r\n  throw createMissingPluginError(pluginName);\r\n}\r\n","import Platform from 'common/platform';\r\nimport * as Utils from '../util/utils';\r\nimport * as API from '../../../../ably';\r\n\r\nexport interface IPartialErrorInfo extends Error {\r\n  code: number | null;\r\n  statusCode?: number;\r\n  cause?: string | Error | ErrorInfo;\r\n  href?: string;\r\n}\r\n\r\nfunction toString(err: ErrorInfo | PartialErrorInfo) {\r\n  let result = '[' + err.constructor.name;\r\n  if (err.message) result += ': ' + err.message;\r\n  if (err.statusCode) result += '; statusCode=' + err.statusCode;\r\n  if (err.code) result += '; code=' + err.code;\r\n  if (err.cause) result += '; cause=' + Utils.inspectError(err.cause);\r\n  if (err.href && !(err.message && err.message.indexOf('help.ably.io') > -1)) result += '; see ' + err.href + ' ';\r\n  result += ']';\r\n  return result;\r\n}\r\n\r\nexport interface IConvertibleToErrorInfo {\r\n  message: string;\r\n  code: number;\r\n  statusCode: number;\r\n}\r\n\r\nexport default class ErrorInfo extends Error implements IPartialErrorInfo, API.ErrorInfo {\r\n  code: number;\r\n  statusCode: number;\r\n  cause?: string | Error | ErrorInfo;\r\n  href?: string;\r\n\r\n  constructor(message: string, code: number, statusCode: number, cause?: string | Error | ErrorInfo) {\r\n    super(message);\r\n    if (typeof Object.setPrototypeOf !== 'undefined') {\r\n      Object.setPrototypeOf(this, ErrorInfo.prototype);\r\n    }\r\n    this.code = code;\r\n    this.statusCode = statusCode;\r\n    this.cause = cause;\r\n  }\r\n\r\n  toString(): string {\r\n    return toString(this);\r\n  }\r\n\r\n  static fromValues(values: IConvertibleToErrorInfo): ErrorInfo {\r\n    const { message, code, statusCode } = values;\r\n    if (typeof message !== 'string' || typeof code !== 'number' || typeof statusCode !== 'number') {\r\n      throw new Error('ErrorInfo.fromValues(): invalid values: ' + Platform.Config.inspect(values));\r\n    }\r\n    const result = Object.assign(new ErrorInfo(message, code, statusCode), values);\r\n    if (result.code && !result.href) {\r\n      result.href = 'https://help.ably.io/error/' + result.code;\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\nexport class PartialErrorInfo extends Error implements IPartialErrorInfo {\r\n  code: number | null;\r\n  statusCode?: number;\r\n  cause?: string | Error | ErrorInfo;\r\n  href?: string;\r\n\r\n  constructor(message: string, code: number | null, statusCode?: number, cause?: string | Error | ErrorInfo) {\r\n    super(message);\r\n    if (typeof Object.setPrototypeOf !== 'undefined') {\r\n      Object.setPrototypeOf(this, PartialErrorInfo.prototype);\r\n    }\r\n    this.code = code;\r\n    this.statusCode = statusCode;\r\n    this.cause = cause;\r\n  }\r\n\r\n  toString(): string {\r\n    return toString(this);\r\n  }\r\n}\r\n","{\r\n  \"name\": \"ably\",\r\n  \"description\": \"Realtime client library for Ably, the realtime messaging service\",\r\n  \"version\": \"2.0.2\",\r\n  \"license\": \"Apache-2.0\",\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/ably/ably-js/issues\",\r\n    \"email\": \"support@ably.com\"\r\n  },\r\n  \"react-native\": \"./build/ably-reactnative.js\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"types\": \"./ably.d.ts\",\r\n      \"node\": \"./build/ably-node.js\",\r\n      \"react-native\": \"./build/ably-reactnative.js\",\r\n      \"default\": \"./build/ably.js\"\r\n    },\r\n    \"./modular\": {\r\n      \"types\": \"./modular.d.ts\",\r\n      \"import\": \"./build/modular/index.mjs\"\r\n    },\r\n    \"./react\": {\r\n      \"require\": \"./react/cjs/index.js\",\r\n      \"import\": \"./react/mjs/index.js\"\r\n    }\r\n  },\r\n  \"typings\": \"./ably.d.ts\",\r\n  \"files\": [\r\n    \"build/**\",\r\n    \"ably.d.ts\",\r\n    \"modular.d.ts\",\r\n    \"resources/**\",\r\n    \"src/**\",\r\n    \"react/**\"\r\n  ],\r\n  \"dependencies\": {\r\n    \"@ably/msgpack-js\": \"^0.4.0\",\r\n    \"fastestsmallesttextencoderdecoder\": \"^1.0.22\",\r\n    \"got\": \"^11.8.5\",\r\n    \"ws\": \"^8.14.2\"\r\n  },\r\n  \"peerDependencies\": {\r\n    \"react\": \">=16.8.0\",\r\n    \"react-dom\": \">=16.8.0\"\r\n  },\r\n  \"peerDependenciesMeta\": {\r\n    \"react\": {\r\n      \"optional\": true\r\n    },\r\n    \"react-dom\": {\r\n      \"optional\": true\r\n    }\r\n  },\r\n  \"devDependencies\": {\r\n    \"@ably/vcdiff-decoder\": \"1.0.6\",\r\n    \"@arethetypeswrong/cli\": \"^0.13.1\",\r\n    \"@babel/generator\": \"^7.23.6\",\r\n    \"@babel/parser\": \"^7.23.6\",\r\n    \"@babel/traverse\": \"^7.23.7\",\r\n    \"@testing-library/react\": \"^13.3.0\",\r\n    \"@types/cli-table\": \"^0.3.4\",\r\n    \"@types/jmespath\": \"^0.15.2\",\r\n    \"@types/node\": \"^18.0.0\",\r\n    \"@types/request\": \"^2.48.7\",\r\n    \"@types/ws\": \"^8.2.0\",\r\n    \"@typescript-eslint/eslint-plugin\": \"^5.59.6\",\r\n    \"@typescript-eslint/parser\": \"^5.59.6\",\r\n    \"@vitejs/plugin-react\": \"^1.3.2\",\r\n    \"async\": \"ably-forks/async#requirejs\",\r\n    \"aws-sdk\": \"^2.1413.0\",\r\n    \"chai\": \"^4.2.0\",\r\n    \"cli-table\": \"^0.3.11\",\r\n    \"cors\": \"^2.8.5\",\r\n    \"esbuild\": \"^0.18.10\",\r\n    \"esbuild-plugin-umd-wrapper\": \"ably-forks/esbuild-plugin-umd-wrapper#1.0.7-optional-amd-named-module\",\r\n    \"esbuild-runner\": \"^2.2.2\",\r\n    \"eslint\": \"^7.13.0\",\r\n    \"eslint-plugin-import\": \"^2.28.0\",\r\n    \"eslint-plugin-jsdoc\": \"^40.0.0\",\r\n    \"eslint-plugin-react\": \"^7.32.2\",\r\n    \"eslint-plugin-react-hooks\": \"^4.6.0\",\r\n    \"eslint-plugin-security\": \"^1.4.0\",\r\n    \"express\": \"^4.17.1\",\r\n    \"glob\": \"~4.4\",\r\n    \"grunt\": \"^1.6.1\",\r\n    \"grunt-cli\": \"~1.2.0\",\r\n    \"grunt-shell\": \"~1.1\",\r\n    \"grunt-webpack\": \"^5.0.0\",\r\n    \"hexy\": \"~0.2\",\r\n    \"jmespath\": \"^0.16.0\",\r\n    \"jsdom\": \"^20.0.0\",\r\n    \"minimist\": \"^1.2.5\",\r\n    \"mocha\": \"^8.1.3\",\r\n    \"mocha-junit-reporter\": \"^2.2.1\",\r\n    \"path-browserify\": \"^1.0.1\",\r\n    \"playwright\": \"^1.39.0\",\r\n    \"prettier\": \"^2.8.8\",\r\n    \"process\": \"^0.11.10\",\r\n    \"react\": \">=18.1.0\",\r\n    \"react-dom\": \">=18.1.0\",\r\n    \"requirejs\": \"~2.1\",\r\n    \"shelljs\": \"~0.8\",\r\n    \"source-map-explorer\": \"^2.5.2\",\r\n    \"source-map-support\": \"^0.5.21\",\r\n    \"stream-browserify\": \"^3.0.0\",\r\n    \"ts-loader\": \"^9.4.2\",\r\n    \"tsconfig-paths-webpack-plugin\": \"^4.0.1\",\r\n    \"tslib\": \"^2.3.1\",\r\n    \"typedoc\": \"^0.24.7\",\r\n    \"typescript\": \"^4.9.5\",\r\n    \"vite\": \"^4.4.9\",\r\n    \"vitest\": \"^0.18.0\",\r\n    \"webpack\": \"^5.79.0\",\r\n    \"webpack-cli\": \"^5.0.1\"\r\n  },\r\n  \"engines\": {\r\n    \"node\": \">=16\"\r\n  },\r\n  \"repository\": \"ably/ably-js\",\r\n  \"jspm\": {\r\n    \"registry\": \"npm\",\r\n    \"directories\": {\r\n      \"lib\": \"build\"\r\n    },\r\n    \"main\": \"ably\"\r\n  },\r\n  \"scripts\": {\r\n    \"start:react\": \"npx vite serve\",\r\n    \"grunt\": \"grunt\",\r\n    \"test\": \"npm run test:node\",\r\n    \"test:node\": \"npm run build:node && mocha\",\r\n    \"test:node:skip-build\": \"mocha\",\r\n    \"test:webserver\": \"grunt test:webserver\",\r\n    \"test:playwright\": \"node test/support/runPlaywrightTests.js\",\r\n    \"test:react\": \"vitest run\",\r\n    \"test:package\": \"grunt test:package\",\r\n    \"concat\": \"grunt concat\",\r\n    \"build\": \"grunt build:all && npm run build:react\",\r\n    \"build:node\": \"grunt build:node\",\r\n    \"build:browser\": \"grunt build:browser\",\r\n    \"build:react\": \"npm run build:react:mjs && npm run build:react:cjs && cp src/platform/react-hooks/res/package.react.json react/package.json\",\r\n    \"build:react:mjs\": \"tsc --project src/platform/react-hooks/tsconfig.mjs.json && cp src/platform/react-hooks/res/package.mjs.json react/mjs/package.json\",\r\n    \"build:react:cjs\": \"tsc --project src/platform/react-hooks/tsconfig.cjs.json && cp src/platform/react-hooks/res/package.cjs.json react/cjs/package.json\",\r\n    \"requirejs\": \"grunt requirejs\",\r\n    \"lint\": \"eslint .\",\r\n    \"lint:fix\": \"eslint --fix .\",\r\n    \"prepare\": \"npm run build\",\r\n    \"format\": \"prettier --write --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts modular.d.ts webpack.config.js Gruntfile.js scripts/*.[jt]s docs/**/*.md grunt\",\r\n    \"format:check\": \"prettier --check --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts modular.d.ts webpack.config.js Gruntfile.js scripts/*.[jt]s docs/**/*.md grunt\",\r\n    \"sourcemap\": \"source-map-explorer build/ably.min.js\",\r\n    \"modulereport\": \"tsc --noEmit --esModuleInterop scripts/moduleReport.ts && esr scripts/moduleReport.ts\",\r\n    \"docs\": \"typedoc\"\r\n  }\r\n}\r\n","import Platform from 'common/platform';\r\nimport * as Utils from './utils';\r\nimport Logger from './logger';\r\nimport ErrorInfo from 'common/lib/types/errorinfo';\r\nimport { version } from '../../../../package.json';\r\nimport ClientOptions, { NormalisedClientOptions } from 'common/types/ClientOptions';\r\nimport IDefaults from '../../types/IDefaults';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\r\nimport { ChannelOptions } from 'common/types/channel';\r\nimport { ModularPlugins } from '../client/modularplugins';\r\n\r\nlet agent = 'ably-js/' + version;\r\n\r\ntype CompleteDefaults = IDefaults & {\r\n  ENVIRONMENT: string;\r\n  REST_HOST: string;\r\n  REALTIME_HOST: string;\r\n  FALLBACK_HOSTS: string[];\r\n  PORT: number;\r\n  TLS_PORT: number;\r\n  TIMEOUTS: {\r\n    disconnectedRetryTimeout: number;\r\n    suspendedRetryTimeout: number;\r\n    httpRequestTimeout: number;\r\n    channelRetryTimeout: number;\r\n    fallbackRetryTimeout: number;\r\n    connectionStateTtl: number;\r\n    realtimeRequestTimeout: number;\r\n    recvTimeout: number;\r\n    webSocketConnectTimeout: number;\r\n    webSocketSlowTimeout: number;\r\n  };\r\n  httpMaxRetryCount: number;\r\n  maxMessageSize: number;\r\n  version: string;\r\n  protocolVersion: number;\r\n  agent: string;\r\n  getHost(options: ClientOptions, host?: string | null, ws?: boolean): string;\r\n  getPort(options: ClientOptions, tls?: boolean): number | undefined;\r\n  getHttpScheme(options: ClientOptions): string;\r\n  environmentFallbackHosts(environment: string): string[];\r\n  getFallbackHosts(options: NormalisedClientOptions): string[];\r\n  getHosts(options: NormalisedClientOptions, ws?: boolean): string[];\r\n  checkHost(host: string): void;\r\n  getRealtimeHost(options: ClientOptions, production: boolean, environment: string): string;\r\n  objectifyOptions(\r\n    options: undefined | ClientOptions | string,\r\n    allowKeyOrToken: boolean,\r\n    sourceForErrorMessage: string,\r\n    modularPluginsToInclude?: ModularPlugins,\r\n  ): ClientOptions;\r\n  normaliseOptions(options: ClientOptions, MsgPack: MsgPack | null): NormalisedClientOptions;\r\n  defaultGetHeaders(options: NormalisedClientOptions, headersOptions?: HeadersOptions): Record<string, string>;\r\n  defaultPostHeaders(options: NormalisedClientOptions, headersOptions?: HeadersOptions): Record<string, string>;\r\n};\r\n\r\nconst Defaults = {\r\n  ENVIRONMENT: '',\r\n  REST_HOST: 'rest.ably.io',\r\n  REALTIME_HOST: 'realtime.ably.io',\r\n  FALLBACK_HOSTS: [\r\n    'A.ably-realtime.com',\r\n    'B.ably-realtime.com',\r\n    'C.ably-realtime.com',\r\n    'D.ably-realtime.com',\r\n    'E.ably-realtime.com',\r\n  ],\r\n  PORT: 80,\r\n  TLS_PORT: 443,\r\n  TIMEOUTS: {\r\n    /* Documented as options params: */\r\n    disconnectedRetryTimeout: 15000,\r\n    suspendedRetryTimeout: 30000,\r\n    /* Undocumented, but part of the api and can be used by customers: */\r\n    httpRequestTimeout: 15000,\r\n    channelRetryTimeout: 15000,\r\n    fallbackRetryTimeout: 600000,\r\n    /* For internal / test use only: */\r\n    connectionStateTtl: 120000,\r\n    realtimeRequestTimeout: 10000,\r\n    recvTimeout: 90000,\r\n    webSocketConnectTimeout: 10000,\r\n    webSocketSlowTimeout: 4000,\r\n  },\r\n  httpMaxRetryCount: 3,\r\n  maxMessageSize: 65536,\r\n\r\n  version,\r\n  protocolVersion: 3,\r\n  agent,\r\n  getHost,\r\n  getPort,\r\n  getHttpScheme,\r\n  environmentFallbackHosts,\r\n  getFallbackHosts,\r\n  getHosts,\r\n  checkHost,\r\n  objectifyOptions,\r\n  normaliseOptions,\r\n  defaultGetHeaders,\r\n  defaultPostHeaders,\r\n};\r\n\r\nexport function getHost(options: ClientOptions, host?: string | null, ws?: boolean): string {\r\n  if (ws) host = (host == options.restHost && options.realtimeHost) || host || options.realtimeHost;\r\n  else host = host || options.restHost;\r\n\r\n  return host as string;\r\n}\r\n\r\nexport function getPort(options: ClientOptions, tls?: boolean): number | undefined {\r\n  return tls || options.tls ? options.tlsPort : options.port;\r\n}\r\n\r\nexport function getHttpScheme(options: ClientOptions): string {\r\n  return options.tls ? 'https://' : 'http://';\r\n}\r\n\r\n// construct environment fallback hosts as per RSC15i\r\nexport function environmentFallbackHosts(environment: string): string[] {\r\n  return [\r\n    environment + '-a-fallback.ably-realtime.com',\r\n    environment + '-b-fallback.ably-realtime.com',\r\n    environment + '-c-fallback.ably-realtime.com',\r\n    environment + '-d-fallback.ably-realtime.com',\r\n    environment + '-e-fallback.ably-realtime.com',\r\n  ];\r\n}\r\n\r\nexport function getFallbackHosts(options: NormalisedClientOptions): string[] {\r\n  const fallbackHosts = options.fallbackHosts,\r\n    httpMaxRetryCount =\r\n      typeof options.httpMaxRetryCount !== 'undefined' ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\r\n\r\n  return fallbackHosts ? Utils.arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\r\n}\r\n\r\nexport function getHosts(options: NormalisedClientOptions, ws?: boolean): string[] {\r\n  const hosts = [options.restHost].concat(getFallbackHosts(options));\r\n  return ws ? hosts.map((host) => getHost(options, host, true)) : hosts;\r\n}\r\n\r\nfunction checkHost(host: string): void {\r\n  if (typeof host !== 'string') {\r\n    throw new ErrorInfo('host must be a string; was a ' + typeof host, 40000, 400);\r\n  }\r\n  if (!host.length) {\r\n    throw new ErrorInfo('host must not be zero-length', 40000, 400);\r\n  }\r\n}\r\n\r\nfunction getRealtimeHost(options: ClientOptions, production: boolean, environment: string): string {\r\n  if (options.realtimeHost) return options.realtimeHost;\r\n  /* prefer setting realtimeHost to restHost as a custom restHost typically indicates\r\n   * a development environment is being used that can't be inferred by the library */\r\n  if (options.restHost) {\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'Defaults.normaliseOptions',\r\n      'restHost is set to \"' +\r\n        options.restHost +\r\n        '\" but realtimeHost is not set, so setting realtimeHost to \"' +\r\n        options.restHost +\r\n        '\" too. If this is not what you want, please set realtimeHost explicitly.',\r\n    );\r\n    return options.restHost;\r\n  }\r\n  return production ? Defaults.REALTIME_HOST : environment + '-' + Defaults.REALTIME_HOST;\r\n}\r\n\r\nfunction getTimeouts(options: ClientOptions) {\r\n  /* Allow values passed in options to override default timeouts */\r\n  const timeouts: Record<string, number> = {};\r\n  for (const prop in Defaults.TIMEOUTS) {\r\n    timeouts[prop] = (options as Record<string, number>)[prop] || (Defaults.TIMEOUTS as Record<string, number>)[prop];\r\n  }\r\n  return timeouts;\r\n}\r\n\r\nexport function getAgentString(options: ClientOptions): string {\r\n  let agentStr = Defaults.agent;\r\n  if (options.agents) {\r\n    for (var agent in options.agents) {\r\n      agentStr += ' ' + agent + '/' + options.agents[agent];\r\n    }\r\n  }\r\n  return agentStr;\r\n}\r\n\r\nexport function objectifyOptions(\r\n  options: undefined | ClientOptions | string,\r\n  allowKeyOrToken: boolean,\r\n  sourceForErrorMessage: string,\r\n  modularPluginsToInclude?: ModularPlugins,\r\n): ClientOptions {\r\n  if (options === undefined) {\r\n    const msg = allowKeyOrToken\r\n      ? `${sourceForErrorMessage} must be initialized with either a client options object, an Ably API key, or an Ably Token`\r\n      : `${sourceForErrorMessage} must be initialized with a client options object`;\r\n    Logger.logAction(Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\r\n    throw new Error(msg);\r\n  }\r\n\r\n  let optionsObj: ClientOptions;\r\n\r\n  if (typeof options === 'string') {\r\n    if (options.indexOf(':') == -1) {\r\n      if (!allowKeyOrToken) {\r\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably Token; you must provide a client options object with a \\`plugins\\` property. (Set this Ably Token as the objectâ€™s \\`token\\` property.)`;\r\n        Logger.logAction(Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\r\n        throw new Error(msg);\r\n      }\r\n\r\n      optionsObj = { token: options };\r\n    } else {\r\n      if (!allowKeyOrToken) {\r\n        const msg = `${sourceForErrorMessage} cannot be initialized with just an Ably API key; you must provide a client options object with a \\`plugins\\` property. (Set this Ably API key as the objectâ€™s \\`key\\` property.)`;\r\n        Logger.logAction(Logger.LOG_ERROR, `${sourceForErrorMessage}()`, msg);\r\n        throw new Error(msg);\r\n      }\r\n\r\n      optionsObj = { key: options };\r\n    }\r\n  } else {\r\n    optionsObj = options;\r\n  }\r\n\r\n  if (modularPluginsToInclude) {\r\n    optionsObj = { ...optionsObj, plugins: { ...modularPluginsToInclude, ...optionsObj.plugins } };\r\n  }\r\n\r\n  return optionsObj;\r\n}\r\n\r\nexport function normaliseOptions(options: ClientOptions, MsgPack: MsgPack | null): NormalisedClientOptions {\r\n  if (typeof options.recover === 'function' && options.closeOnUnload === true) {\r\n    Logger.logAction(\r\n      Logger.LOG_ERROR,\r\n      'Defaults.normaliseOptions',\r\n      'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter',\r\n    );\r\n    options.recover = undefined;\r\n  }\r\n\r\n  if (!('closeOnUnload' in options)) {\r\n    /* Have closeOnUnload default to true unless we have any indication that\r\n     * the user may want to recover the connection */\r\n    options.closeOnUnload = !options.recover;\r\n  }\r\n\r\n  if (!('queueMessages' in options)) options.queueMessages = true;\r\n\r\n  /* infer hosts and fallbacks based on the configured environment */\r\n  const environment = (options.environment && String(options.environment).toLowerCase()) || Defaults.ENVIRONMENT;\r\n  const production = !environment || environment === 'production';\r\n\r\n  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\r\n    options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);\r\n  }\r\n\r\n  const restHost = options.restHost || (production ? Defaults.REST_HOST : environment + '-' + Defaults.REST_HOST);\r\n  const realtimeHost = getRealtimeHost(options, production, environment);\r\n\r\n  (options.fallbackHosts || []).concat(restHost, realtimeHost).forEach(checkHost);\r\n\r\n  options.port = options.port || Defaults.PORT;\r\n  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\r\n  if (!('tls' in options)) options.tls = true;\r\n\r\n  const timeouts = getTimeouts(options);\r\n\r\n  if (MsgPack) {\r\n    if ('useBinaryProtocol' in options) {\r\n      options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;\r\n    } else {\r\n      options.useBinaryProtocol = Platform.Config.preferBinary;\r\n    }\r\n  } else {\r\n    options.useBinaryProtocol = false;\r\n  }\r\n\r\n  const headers: Record<string, string> = {};\r\n  if (options.clientId) {\r\n    headers['X-Ably-ClientId'] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));\r\n  }\r\n\r\n  if (!('idempotentRestPublishing' in options)) {\r\n    options.idempotentRestPublishing = true;\r\n  }\r\n\r\n  let connectivityCheckParams = null;\r\n  let connectivityCheckUrl = options.connectivityCheckUrl;\r\n  if (options.connectivityCheckUrl) {\r\n    let [uri, qs] = options.connectivityCheckUrl.split('?');\r\n    connectivityCheckParams = qs ? Utils.parseQueryString(qs) : {};\r\n    if (uri.indexOf('://') === -1) {\r\n      uri = 'https://' + uri;\r\n    }\r\n    connectivityCheckUrl = uri;\r\n  }\r\n\r\n  return {\r\n    ...options,\r\n    realtimeHost,\r\n    restHost,\r\n    maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize,\r\n    timeouts,\r\n    connectivityCheckParams,\r\n    connectivityCheckUrl,\r\n    headers,\r\n  };\r\n}\r\n\r\nexport function normaliseChannelOptions(Crypto: IUntypedCryptoStatic | null, options?: ChannelOptions) {\r\n  const channelOptions = options || {};\r\n  if (channelOptions.cipher) {\r\n    if (!Crypto) Utils.throwMissingPluginError('Crypto');\r\n    const cipher = Crypto.getCipher(channelOptions.cipher);\r\n    channelOptions.cipher = cipher.cipherParams;\r\n    channelOptions.channelCipher = cipher.cipher;\r\n  } else if ('cipher' in channelOptions) {\r\n    /* Don't deactivate an existing cipher unless options\r\n     * has a 'cipher' key that's falsey */\r\n    channelOptions.cipher = undefined;\r\n    channelOptions.channelCipher = null;\r\n  }\r\n  return channelOptions;\r\n}\r\n\r\nconst contentTypes = {\r\n  json: 'application/json',\r\n  xml: 'application/xml',\r\n  html: 'text/html',\r\n  msgpack: 'application/x-msgpack',\r\n};\r\n\r\nexport interface HeadersOptions {\r\n  format?: Utils.Format;\r\n  protocolVersion?: number;\r\n}\r\n\r\nconst defaultHeadersOptions: Required<HeadersOptions> = {\r\n  format: Utils.Format.json,\r\n  protocolVersion: Defaults.protocolVersion,\r\n};\r\n\r\nexport function defaultGetHeaders(\r\n  options: NormalisedClientOptions,\r\n  {\r\n    format = defaultHeadersOptions.format,\r\n    protocolVersion = defaultHeadersOptions.protocolVersion,\r\n  }: HeadersOptions = {},\r\n): Record<string, string> {\r\n  const accept = contentTypes[format];\r\n  return {\r\n    accept: accept,\r\n    'X-Ably-Version': protocolVersion.toString(),\r\n    'Ably-Agent': getAgentString(options),\r\n  };\r\n}\r\n\r\nexport function defaultPostHeaders(\r\n  options: NormalisedClientOptions,\r\n  {\r\n    format = defaultHeadersOptions.format,\r\n    protocolVersion = defaultHeadersOptions.protocolVersion,\r\n  }: HeadersOptions = {},\r\n): Record<string, string> {\r\n  let contentType;\r\n  const accept = (contentType = contentTypes[format]);\r\n\r\n  return {\r\n    accept: accept,\r\n    'content-type': contentType,\r\n    'X-Ably-Version': protocolVersion.toString(),\r\n    'Ably-Agent': getAgentString(options),\r\n  };\r\n}\r\n\r\nexport default Defaults as CompleteDefaults;\r\n\r\nexport function getDefaults(platformDefaults: IDefaults) {\r\n  return Object.assign(Defaults, platformDefaults);\r\n}\r\n","import { StandardCallback } from 'common/types/utils';\r\nimport ErrorInfo from 'common/lib/types/errorinfo';\r\nimport Logger from './logger';\r\n\r\nexport interface MulticasterInstance<T> extends Function {\r\n  (err?: ErrorInfo | null, result?: T): void;\r\n  push: (fn: StandardCallback<T>) => void;\r\n  /**\r\n   * Creates a promise that will be resolved or rejected when this instance is called.\r\n   */\r\n  createPromise: () => Promise<T>;\r\n  /**\r\n   * Syntatic sugar for when working in a context that uses promises; equivalent to calling as a function with arguments (null, result).\r\n   */\r\n  resolveAll(result: T): void;\r\n  /**\r\n   * Syntatic sugar for when working in a context that uses promises; equivalent to calling as a function with arguments (err).\r\n   */\r\n  rejectAll(err: ErrorInfo): void;\r\n}\r\n\r\nclass Multicaster<T> {\r\n  members: Array<StandardCallback<T>>;\r\n\r\n  // Private constructor; use static Multicaster.create instead\r\n  private constructor(members?: Array<StandardCallback<T> | undefined>) {\r\n    this.members = (members as Array<StandardCallback<T>>) || [];\r\n  }\r\n\r\n  private call(err?: ErrorInfo | null, result?: T): void {\r\n    for (const member of this.members) {\r\n      if (member) {\r\n        try {\r\n          member(err, result);\r\n        } catch (e) {\r\n          Logger.logAction(\r\n            Logger.LOG_ERROR,\r\n            'Multicaster multiple callback handler',\r\n            'Unexpected exception: ' + e + '; stack = ' + (e as Error).stack,\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  push(...args: Array<StandardCallback<T>>): void {\r\n    this.members.push(...args);\r\n  }\r\n\r\n  createPromise(): Promise<T> {\r\n    return new Promise((resolve, reject) => {\r\n      this.push((err, result) => {\r\n        err ? reject(err) : resolve(result!);\r\n      });\r\n    });\r\n  }\r\n\r\n  resolveAll(result: T) {\r\n    this.call(null, result);\r\n  }\r\n\r\n  rejectAll(err: ErrorInfo) {\r\n    this.call(err);\r\n  }\r\n\r\n  static create<T>(members?: Array<StandardCallback<T> | undefined>): MulticasterInstance<T> {\r\n    const instance = new Multicaster(members);\r\n    return Object.assign((err?: ErrorInfo | null, result?: T) => instance.call(err, result), {\r\n      push: (fn: StandardCallback<T>) => instance.push(fn),\r\n      createPromise: () => instance.createPromise(),\r\n      resolveAll: (result: T) => instance.resolveAll(result),\r\n      rejectAll: (err: ErrorInfo) => instance.rejectAll(err),\r\n    });\r\n  }\r\n}\r\n\r\nexport default Multicaster;\r\n","enum HttpMethods {\n  Get = 'get',\n  Delete = 'delete',\n  Post = 'post',\n  Put = 'put',\n  Patch = 'patch',\n}\n\nexport default HttpMethods;\n","enum HttpStatusCodes {\n  Success = 200,\n  NoContent = 204,\n  BadRequest = 400,\n  Unauthorized = 401,\n  Forbidden = 403,\n  RequestTimeout = 408,\n  InternalServerError = 500,\n}\n\nexport function isSuccessCode(statusCode: number) {\n  return statusCode >= HttpStatusCodes.Success && statusCode < HttpStatusCodes.BadRequest;\n}\n\nexport default HttpStatusCodes;\n","import Logger from '../util/logger';\r\nimport * as Utils from '../util/utils';\r\nimport Multicaster, { MulticasterInstance } from '../util/multicaster';\r\nimport ErrorInfo, { IPartialErrorInfo } from '../types/errorinfo';\r\nimport { RequestResultError, RequestParams, RequestResult } from '../../types/http';\r\nimport * as API from '../../../../ably';\r\nimport BaseClient from './baseclient';\r\nimport BaseRealtime from './baserealtime';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport HttpMethods from '../../constants/HttpMethods';\r\nimport HttpStatusCodes from 'common/constants/HttpStatusCodes';\r\nimport Platform, { Bufferlike } from '../../platform';\r\nimport Defaults from '../util/defaults';\r\n\r\ntype BatchResult<T> = API.BatchResult<T>;\r\ntype TokenRevocationTargetSpecifier = API.TokenRevocationTargetSpecifier;\r\ntype TokenRevocationOptions = API.TokenRevocationOptions;\r\ntype TokenRevocationSuccessResult = API.TokenRevocationSuccessResult;\r\ntype TokenRevocationFailureResult = API.TokenRevocationFailureResult;\r\ntype TokenRevocationResult = BatchResult<TokenRevocationSuccessResult | TokenRevocationFailureResult>;\r\n\r\nconst MAX_TOKEN_LENGTH = Math.pow(2, 17);\r\nfunction random() {\r\n  return ('000000' + Math.floor(Math.random() * 1e16)).slice(-16);\r\n}\r\n\r\nfunction isRealtime(client: BaseClient): client is BaseRealtime {\r\n  return !!(client as BaseRealtime).connection;\r\n}\r\n\r\n/* A client auth callback may give errors in any number of formats; normalise to an ErrorInfo or PartialErrorInfo */\r\nfunction normaliseAuthcallbackError(err: any) {\r\n  if (!Utils.isErrorInfoOrPartialErrorInfo(err)) {\r\n    return new ErrorInfo(Utils.inspectError(err), err.code || 40170, err.statusCode || 401);\r\n  }\r\n  /* network errors will not have an inherent error code */\r\n  if (!err.code) {\r\n    if (err.statusCode === 403) {\r\n      err.code = 40300;\r\n    } else {\r\n      err.code = 40170;\r\n      /* normalise statusCode to 401 per RSA4e */\r\n      err.statusCode = 401;\r\n    }\r\n  }\r\n  return err;\r\n}\r\n\r\nlet hmac = (text: string, key: string): string => {\r\n  const bufferUtils = Platform.BufferUtils;\r\n\r\n  const textBuffer = bufferUtils.utf8Encode(text);\r\n  const keyBuffer = bufferUtils.utf8Encode(key);\r\n\r\n  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);\r\n\r\n  return bufferUtils.base64Encode(digest);\r\n};\r\n\r\nfunction c14n(capability?: string | Record<string, Array<string>>) {\r\n  if (!capability) return '';\r\n\r\n  if (typeof capability == 'string') capability = JSON.parse(capability);\r\n\r\n  const c14nCapability: Record<string, Array<string>> = Object.create(null);\r\n  const keys = Utils.keysArray(capability as Record<string, Array<string>>, true);\r\n  if (!keys) return '';\r\n  keys.sort();\r\n  for (let i = 0; i < keys.length; i++) {\r\n    c14nCapability[keys[i]] = (capability as Record<string, Array<string>>)[keys[i]].sort();\r\n  }\r\n  return JSON.stringify(c14nCapability);\r\n}\r\n\r\nfunction logAndValidateTokenAuthMethod(authOptions: AuthOptions) {\r\n  if (authOptions.authCallback) {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with authCallback');\r\n  } else if (authOptions.authUrl) {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with authUrl');\r\n  } else if (authOptions.key) {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with client-side signing');\r\n  } else if (authOptions.tokenDetails) {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'using token auth with supplied token only');\r\n  } else {\r\n    const msg = 'authOptions must include valid authentication parameters';\r\n    Logger.logAction(Logger.LOG_ERROR, 'Auth()', msg);\r\n    throw new Error(msg);\r\n  }\r\n}\r\n\r\nfunction basicAuthForced(options: ClientOptions) {\r\n  return 'useTokenAuth' in options && !options.useTokenAuth;\r\n}\r\n\r\n/* RSA4 */\r\nexport function useTokenAuth(options: ClientOptions) {\r\n  return (\r\n    options.useTokenAuth ||\r\n    (!basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails))\r\n  );\r\n}\r\n\r\n/* RSA4a */\r\nfunction noWayToRenew(options: ClientOptions) {\r\n  return !options.key && !options.authCallback && !options.authUrl;\r\n}\r\n\r\nlet trId = 0;\r\nfunction getTokenRequestId() {\r\n  return trId++;\r\n}\r\n\r\n/**\r\n * Auth options used only for testing.\r\n */\r\ntype PrivateAuthOptions = {\r\n  requestHeaders?: Record<string, string>;\r\n  suppressMaxLengthCheck?: boolean;\r\n};\r\n\r\ntype AuthOptions = API.AuthOptions & PrivateAuthOptions;\r\n\r\nclass Auth {\r\n  client: BaseClient;\r\n  tokenParams: API.TokenParams;\r\n  currentTokenRequestId: number | null;\r\n  waitingForTokenRequest: MulticasterInstance<API.TokenDetails> | null;\r\n  // This initialization is always overwritten and only used to prevent a TypeScript compiler error\r\n  authOptions: AuthOptions = {} as AuthOptions;\r\n  tokenDetails?: API.TokenDetails | null;\r\n  method?: string;\r\n  key?: string;\r\n  basicKey?: string;\r\n  clientId?: string | null;\r\n\r\n  constructor(client: BaseClient, options: ClientOptions) {\r\n    this.client = client;\r\n    this.tokenParams = options.defaultTokenParams || {};\r\n    /* The id of the current token request if one is in progress, else null */\r\n    this.currentTokenRequestId = null;\r\n    this.waitingForTokenRequest = null;\r\n\r\n    if (useTokenAuth(options)) {\r\n      /* Token auth */\r\n      if (noWayToRenew(options)) {\r\n        Logger.logAction(\r\n          Logger.LOG_ERROR,\r\n          'Auth()',\r\n          'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help',\r\n        );\r\n      }\r\n      this._saveTokenOptions(options.defaultTokenParams as API.TokenDetails, options);\r\n      logAndValidateTokenAuthMethod(this.authOptions);\r\n    } else {\r\n      /* Basic auth */\r\n      if (!options.key) {\r\n        const msg =\r\n          'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';\r\n        Logger.logAction(Logger.LOG_ERROR, 'Auth()', msg);\r\n        throw new ErrorInfo(msg, 40160, 401);\r\n      }\r\n      Logger.logAction(Logger.LOG_MINOR, 'Auth()', 'anonymous, using basic auth');\r\n      this._saveBasicOptions(options);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Instructs the library to get a token immediately and ensures Token Auth\r\n   * is used for all future requests, storing the tokenParams and authOptions\r\n   * given as the new defaults for subsequent use.\r\n   */\r\n  async authorize(): Promise<API.TokenDetails>;\r\n\r\n  /**\r\n   * Instructs the library to get a token immediately and ensures Token Auth\r\n   * is used for all future requests, storing the tokenParams and authOptions\r\n   * given as the new defaults for subsequent use.\r\n   *\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   *\r\n   * - ttl:        (optional) the requested life of any new token in ms. If none\r\n   *               is specified a default of 1 hour is provided. The maximum lifetime\r\n   *               is 24hours; any request exceeding that lifetime will be rejected\r\n   *               with an error.\r\n   *\r\n   * - capability: (optional) the capability to associate with the access token.\r\n   *               If none is specified, a token will be requested with all of the\r\n   *               capabilities of the specified key.\r\n   *\r\n   * - clientId:   (optional) a client ID to associate with the token\r\n   *\r\n   * - timestamp:  (optional) the time in ms since the epoch. If none is specified,\r\n   *               the system will be queried for a time value to use.\r\n   */\r\n  async authorize(tokenParams: API.TokenParams | null): Promise<API.TokenDetails>;\r\n\r\n  /**\r\n   * Instructs the library to get a token immediately and ensures Token Auth\r\n   * is used for all future requests, storing the tokenParams and authOptions\r\n   * given as the new defaults for subsequent use.\r\n   *\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   *\r\n   * - ttl:        (optional) the requested life of any new token in ms. If none\r\n   *               is specified a default of 1 hour is provided. The maximum lifetime\r\n   *               is 24hours; any request exceeding that lifetime will be rejected\r\n   *               with an error.\r\n   *\r\n   * - capability: (optional) the capability to associate with the access token.\r\n   *               If none is specified, a token will be requested with all of the\r\n   *               capabilities of the specified key.\r\n   *\r\n   * - clientId:   (optional) a client ID to associate with the token\r\n   *\r\n   * - timestamp:  (optional) the time in ms since the epoch. If none is specified,\r\n   *               the system will be queried for a time value to use.\r\n   *\r\n   * @param authOptions\r\n   * an object containing auth options relevant to token auth:\r\n   *\r\n   * - queryTime   (optional) boolean indicating that the Ably system should be\r\n   *               queried for the current time when none is specified explicitly.\r\n   *\r\n   * - tokenDetails: (optional) object: An authenticated TokenDetails object.\r\n   *\r\n   * - token:        (optional) string: the `token` property of a tokenDetails object\r\n   *\r\n   * - authCallback:  (optional) a JavaScript callback to be called to get auth information.\r\n   *                  authCallback should be a function of (tokenParams, callback) that calls\r\n   *                  the callback with (err, result), where result is any of:\r\n   *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),\r\n   *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),\r\n   *                  - a token string\r\n   *\r\n   * - authUrl:       (optional) a URL to be used to GET or POST a set of token request\r\n   *                  params, to obtain a signed token request.\r\n   *\r\n   * - authHeaders:   (optional) a set of application-specific headers to be added to any request\r\n   *                  made to the authUrl.\r\n   *\r\n   * - authParams:    (optional) a set of application-specific query params to be added to any\r\n   *                  request made to the authUrl.\r\n   *\r\n   *\r\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\r\n   *                  requestToken request\r\n   */\r\n  async authorize(tokenParams: API.TokenParams | null, authOptions: AuthOptions | null): Promise<API.TokenDetails>;\r\n\r\n  async authorize(\r\n    tokenParams?: Record<string, any> | null,\r\n    authOptions?: AuthOptions | null,\r\n  ): Promise<API.TokenDetails> {\r\n    /* RSA10a: authorize() call implies token auth. If a key is passed it, we\r\n     * just check if it doesn't clash and assume we're generating a token from it */\r\n    if (authOptions && authOptions.key && this.authOptions.key !== authOptions.key) {\r\n      throw new ErrorInfo('Unable to update auth options with incompatible key', 40102, 401);\r\n    }\r\n\r\n    try {\r\n      let tokenDetails = await this._forceNewToken(tokenParams ?? null, authOptions ?? null);\r\n\r\n      /* RTC8\r\n       * - When authorize called by an end user and have a realtime connection,\r\n       * don't call back till new token has taken effect.\r\n       * - Use this.client.connection as a proxy for (this.client instanceof BaseRealtime),\r\n       * which doesn't work in node as BaseRealtime isn't part of the vm context for Rest clients */\r\n      if (isRealtime(this.client)) {\r\n        return new Promise((resolve, reject) => {\r\n          (this.client as BaseRealtime).connection.connectionManager.onAuthUpdated(\r\n            tokenDetails,\r\n            (err: unknown, tokenDetails?: API.TokenDetails) => (err ? reject(err) : resolve(tokenDetails!)),\r\n          );\r\n        });\r\n      } else {\r\n        return tokenDetails;\r\n      }\r\n    } catch (err) {\r\n      if ((this.client as BaseRealtime).connection && (err as ErrorInfo).statusCode === HttpStatusCodes.Forbidden) {\r\n        /* Per RSA4d & RSA4d1, if the auth server explicitly repudiates our right to\r\n         * stay connecticed by returning a 403, we actively disconnect the connection\r\n         * even though we may well still have time left in the old token. */\r\n        (this.client as BaseRealtime).connection.connectionManager.actOnErrorFromAuthorize(err as ErrorInfo);\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  /* For internal use, eg by connectionManager - useful when want to call back\r\n   * as soon as we have the new token, rather than waiting for it to take\r\n   * effect on the connection as #authorize does */\r\n  async _forceNewToken(\r\n    tokenParams: API.TokenParams | null,\r\n    authOptions: AuthOptions | null,\r\n  ): Promise<API.TokenDetails> {\r\n    /* get rid of current token even if still valid */\r\n    this.tokenDetails = null;\r\n\r\n    /* _save normalises the tokenParams and authOptions and updates the auth\r\n     * object. All subsequent operations should use the values on `this`,\r\n     * not the passed in ones. */\r\n    this._saveTokenOptions(tokenParams, authOptions);\r\n\r\n    logAndValidateTokenAuthMethod(this.authOptions);\r\n\r\n    try {\r\n      return this._ensureValidAuthCredentials(true);\r\n    } finally {\r\n      /* RSA10g */\r\n      delete this.tokenParams.timestamp;\r\n      delete this.authOptions.queryTime;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Request an access token\r\n   */\r\n  async requestToken(): Promise<API.TokenDetails>;\r\n\r\n  /**\r\n   * Request an access token\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified\r\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\r\n   *                  exceeding that lifetime will be rejected with an error.\r\n   *\r\n   * - capability:    (optional) the capability to associate with the access token.\r\n   *                  If none is specified, a token will be requested with all of the\r\n   *                  capabilities of the specified key.\r\n   *\r\n   * - clientId:      (optional) a client ID to associate with the token; if not\r\n   *                  specified, a clientId passed in constructing the Rest interface will be used\r\n   *\r\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\r\n   *                  the system will be queried for a time value to use.\r\n   */\r\n  async requestToken(tokenParams: API.TokenParams | null): Promise<API.TokenDetails>;\r\n\r\n  /**\r\n   * Request an access token\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified\r\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\r\n   *                  exceeding that lifetime will be rejected with an error.\r\n   *\r\n   * - capability:    (optional) the capability to associate with the access token.\r\n   *                  If none is specified, a token will be requested with all of the\r\n   *                  capabilities of the specified key.\r\n   *\r\n   * - clientId:      (optional) a client ID to associate with the token; if not\r\n   *                  specified, a clientId passed in constructing the Rest interface will be used\r\n   *\r\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\r\n   *                  the system will be queried for a time value to use.\r\n   *\r\n   * @param authOptions\r\n   * an object containing the request options:\r\n   * - key:           the key to use.\r\n   *\r\n   * - authCallback:  (optional) a JavaScript callback to be called to get auth information.\r\n   *                  authCallback should be a function of (tokenParams, callback) that calls\r\n   *                  the callback with (err, result), where result is any of:\r\n   *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),\r\n   *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),\r\n   *                  - a token string\r\n   *\r\n   * - authUrl:       (optional) a URL to be used to GET or POST a set of token request\r\n   *                  params, to obtain a signed token request.\r\n   *\r\n   * - authHeaders:   (optional) a set of application-specific headers to be added to any request\r\n   *                  made to the authUrl.\r\n   *\r\n   * - authParams:    (optional) a set of application-specific query params to be added to any\r\n   *                  request made to the authUrl.\r\n   *\r\n   * - queryTime      (optional) boolean indicating that the ably system should be\r\n   *                  queried for the current time when none is specified explicitly\r\n   *\r\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\r\n   *                  requestToken request\r\n   */\r\n  async requestToken(tokenParams: API.TokenParams | null, authOptions: AuthOptions): Promise<API.TokenDetails>;\r\n\r\n  async requestToken(tokenParams?: API.TokenParams | null, authOptions?: AuthOptions): Promise<API.TokenDetails> {\r\n    /* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */\r\n    const resolvedAuthOptions = authOptions || this.authOptions;\r\n    const resolvedTokenParams = tokenParams || Utils.copy(this.tokenParams);\r\n\r\n    /* first set up whatever callback will be used to get signed\r\n     * token requests */\r\n    let tokenRequestCallback: (\r\n        data: API.TokenParams,\r\n        callback: (\r\n          error: API.ErrorInfo | RequestResultError | string | null,\r\n          tokenRequestOrDetails: API.TokenDetails | API.TokenRequest | string | null,\r\n          contentType?: string,\r\n        ) => void,\r\n      ) => void,\r\n      client = this.client;\r\n\r\n    if (resolvedAuthOptions.authCallback) {\r\n      Logger.logAction(Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');\r\n      tokenRequestCallback = resolvedAuthOptions.authCallback;\r\n    } else if (resolvedAuthOptions.authUrl) {\r\n      Logger.logAction(Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');\r\n      tokenRequestCallback = (params, cb) => {\r\n        const authHeaders = Utils.mixin(\r\n          { accept: 'application/json, text/plain' },\r\n          resolvedAuthOptions.authHeaders,\r\n        ) as Record<string, string>;\r\n        const usePost = resolvedAuthOptions.authMethod && resolvedAuthOptions.authMethod.toLowerCase() === 'post';\r\n        let providedQsParams;\r\n        /* Combine authParams with any qs params given in the authUrl */\r\n        const queryIdx = resolvedAuthOptions.authUrl!.indexOf('?');\r\n        if (queryIdx > -1) {\r\n          providedQsParams = Utils.parseQueryString(resolvedAuthOptions.authUrl!.slice(queryIdx));\r\n          resolvedAuthOptions.authUrl = resolvedAuthOptions.authUrl!.slice(0, queryIdx);\r\n          if (!usePost) {\r\n            /* In case of conflict, authParams take precedence over qs params in the authUrl */\r\n            resolvedAuthOptions.authParams = Utils.mixin(\r\n              providedQsParams,\r\n              resolvedAuthOptions.authParams,\r\n            ) as typeof resolvedAuthOptions.authParams;\r\n          }\r\n        }\r\n        /* RSA8c2 */\r\n        const authParams = Utils.mixin({}, resolvedAuthOptions.authParams || {}, params) as RequestParams;\r\n        const authUrlRequestCallback = function (result: RequestResult) {\r\n          let body = (result.body ?? null) as string | Bufferlike | API.TokenDetails | API.TokenRequest | null;\r\n\r\n          let contentType: string | null = null;\r\n          if (result.error) {\r\n            Logger.logAction(\r\n              Logger.LOG_MICRO,\r\n              'Auth.requestToken().tokenRequestCallback',\r\n              'Received Error: ' + Utils.inspectError(result.error),\r\n            );\r\n          } else {\r\n            const contentTypeHeaderOrHeaders = result.headers!['content-type'] ?? null;\r\n            if (Array.isArray(contentTypeHeaderOrHeaders)) {\r\n              // Combine multiple header values into a comma-separated list per https://datatracker.ietf.org/doc/html/rfc9110#section-5.2; see https://github.com/ably/ably-js/issues/1616 for doing this consistently across the codebase.\r\n              contentType = contentTypeHeaderOrHeaders.join(', ');\r\n            } else {\r\n              contentType = contentTypeHeaderOrHeaders;\r\n            }\r\n            Logger.logAction(\r\n              Logger.LOG_MICRO,\r\n              'Auth.requestToken().tokenRequestCallback',\r\n              'Received; content-type: ' + contentType + '; body: ' + Utils.inspectBody(body),\r\n            );\r\n          }\r\n          if (result.error) {\r\n            cb(result.error, null);\r\n            return;\r\n          }\r\n          if (result.unpacked) {\r\n            cb(null, body as Exclude<typeof body, Bufferlike>);\r\n            return;\r\n          }\r\n          if (Platform.BufferUtils.isBuffer(body)) body = body.toString();\r\n          if (!contentType) {\r\n            cb(new ErrorInfo('authUrl response is missing a content-type header', 40170, 401), null);\r\n            return;\r\n          }\r\n          const json = contentType.indexOf('application/json') > -1,\r\n            text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;\r\n          if (!json && !text) {\r\n            cb(\r\n              new ErrorInfo(\r\n                'authUrl responded with unacceptable content-type ' +\r\n                  contentType +\r\n                  ', should be either text/plain, application/jwt or application/json',\r\n                40170,\r\n                401,\r\n              ),\r\n              null,\r\n            );\r\n            return;\r\n          }\r\n          if (json) {\r\n            if ((body as string).length > MAX_TOKEN_LENGTH) {\r\n              cb(new ErrorInfo('authUrl response exceeded max permitted length', 40170, 401), null);\r\n              return;\r\n            }\r\n            try {\r\n              body = JSON.parse(body as string);\r\n            } catch (e) {\r\n              cb(\r\n                new ErrorInfo(\r\n                  'Unexpected error processing authURL response; err = ' + (e as Error).message,\r\n                  40170,\r\n                  401,\r\n                ),\r\n                null,\r\n              );\r\n              return;\r\n            }\r\n          }\r\n          cb(null, body as Exclude<typeof body, Bufferlike>, contentType);\r\n        };\r\n        Logger.logAction(\r\n          Logger.LOG_MICRO,\r\n          'Auth.requestToken().tokenRequestCallback',\r\n          'Requesting token from ' +\r\n            resolvedAuthOptions.authUrl +\r\n            '; Params: ' +\r\n            JSON.stringify(authParams) +\r\n            '; method: ' +\r\n            (usePost ? 'POST' : 'GET'),\r\n        );\r\n        if (usePost) {\r\n          /* send body form-encoded */\r\n          const headers = authHeaders || {};\r\n          headers['content-type'] = 'application/x-www-form-urlencoded';\r\n          const body = Utils.toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */\r\n          Utils.whenPromiseSettles(\r\n            this.client.http.doUri(\r\n              HttpMethods.Post,\r\n              resolvedAuthOptions.authUrl!,\r\n              headers,\r\n              body,\r\n              providedQsParams as Record<string, string>,\r\n            ),\r\n            (err: any, result) =>\r\n              err\r\n                ? authUrlRequestCallback(err) // doUri isnâ€™t meant to throw an error, but handle any just in case\r\n                : authUrlRequestCallback(result!),\r\n          );\r\n        } else {\r\n          Utils.whenPromiseSettles(\r\n            this.client.http.doUri(HttpMethods.Get, resolvedAuthOptions.authUrl!, authHeaders || {}, null, authParams),\r\n            (err: any, result) =>\r\n              err\r\n                ? authUrlRequestCallback(err) // doUri isnâ€™t meant to throw an error, but handle any just in case\r\n                : authUrlRequestCallback(result!),\r\n          );\r\n        }\r\n      };\r\n    } else if (resolvedAuthOptions.key) {\r\n      Logger.logAction(Logger.LOG_MINOR, 'Auth.requestToken()', 'using token auth with client-side signing');\r\n      tokenRequestCallback = (params, cb) => {\r\n        Utils.whenPromiseSettles(this.createTokenRequest(params, resolvedAuthOptions), (err, result) =>\r\n          cb(err as string | ErrorInfo | null, result ?? null),\r\n        );\r\n      };\r\n    } else {\r\n      const msg =\r\n        'Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)';\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'Auth()',\r\n        'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help',\r\n      );\r\n      throw new ErrorInfo(msg, 40171, 403);\r\n    }\r\n\r\n    /* normalise token params */\r\n    if ('capability' in (resolvedTokenParams as Record<string, any>))\r\n      (resolvedTokenParams as Record<string, any>).capability = c14n(\r\n        (resolvedTokenParams as Record<string, any>).capability,\r\n      );\r\n\r\n    const tokenRequest = (\r\n      signedTokenParams: Record<string, any>,\r\n      tokenCb: (err: RequestResultError | null, tokenResponse?: API.TokenDetails | string, unpacked?: boolean) => void,\r\n    ) => {\r\n      const keyName = signedTokenParams.keyName,\r\n        path = '/keys/' + keyName + '/requestToken',\r\n        tokenUri = function (host: string) {\r\n          return client.baseUri(host) + path;\r\n        };\r\n\r\n      const requestHeaders = Defaults.defaultPostHeaders(this.client.options);\r\n      if (resolvedAuthOptions.requestHeaders) Utils.mixin(requestHeaders, resolvedAuthOptions.requestHeaders);\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'Auth.requestToken().requestToken',\r\n        'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams),\r\n      );\r\n      Utils.whenPromiseSettles(\r\n        this.client.http.do(HttpMethods.Post, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null),\r\n        (err: any, result) =>\r\n          err\r\n            ? tokenCb(err) // doUri isnâ€™t meant to throw an error, but handle any just in case\r\n            : tokenCb(result!.error, result!.body as API.TokenDetails | string | undefined, result!.unpacked),\r\n      );\r\n    };\r\n\r\n    return new Promise((resolve, reject) => {\r\n      let tokenRequestCallbackTimeoutExpired = false,\r\n        timeoutLength = this.client.options.timeouts.realtimeRequestTimeout,\r\n        tokenRequestCallbackTimeout = setTimeout(function () {\r\n          tokenRequestCallbackTimeoutExpired = true;\r\n          const msg = 'Token request callback timed out after ' + timeoutLength / 1000 + ' seconds';\r\n          Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', msg);\r\n          reject(new ErrorInfo(msg, 40170, 401));\r\n        }, timeoutLength);\r\n\r\n      tokenRequestCallback!(resolvedTokenParams, function (err, tokenRequestOrDetails, contentType) {\r\n        if (tokenRequestCallbackTimeoutExpired) return;\r\n        clearTimeout(tokenRequestCallbackTimeout);\r\n\r\n        if (err) {\r\n          Logger.logAction(\r\n            Logger.LOG_ERROR,\r\n            'Auth.requestToken()',\r\n            'token request signing call returned error; err = ' + Utils.inspectError(err),\r\n          );\r\n          reject(normaliseAuthcallbackError(err));\r\n          return;\r\n        }\r\n        /* the response from the callback might be a token string, a signed request or a token details */\r\n        if (typeof tokenRequestOrDetails === 'string') {\r\n          if (tokenRequestOrDetails.length === 0) {\r\n            reject(new ErrorInfo('Token string is empty', 40170, 401));\r\n          } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\r\n            reject(\r\n              new ErrorInfo(\r\n                'Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)',\r\n                40170,\r\n                401,\r\n              ),\r\n            );\r\n          } else if (tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {\r\n            /* common failure mode with poorly-implemented authCallbacks */\r\n            reject(new ErrorInfo('Token string was literal null/undefined', 40170, 401));\r\n          } else if (\r\n            tokenRequestOrDetails[0] === '{' &&\r\n            !(contentType && contentType.indexOf('application/jwt') > -1)\r\n          ) {\r\n            reject(\r\n              new ErrorInfo(\r\n                \"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\",\r\n                40170,\r\n                401,\r\n              ),\r\n            );\r\n          } else {\r\n            resolve({ token: tokenRequestOrDetails } as API.TokenDetails);\r\n          }\r\n          return;\r\n        }\r\n        if (typeof tokenRequestOrDetails !== 'object' || tokenRequestOrDetails === null) {\r\n          const msg =\r\n            'Expected token request callback to call back with a token string or token request/details object, but got a ' +\r\n            typeof tokenRequestOrDetails;\r\n          Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', msg);\r\n          reject(new ErrorInfo(msg, 40170, 401));\r\n          return;\r\n        }\r\n        const objectSize = JSON.stringify(tokenRequestOrDetails).length;\r\n        if (objectSize > MAX_TOKEN_LENGTH && !resolvedAuthOptions.suppressMaxLengthCheck) {\r\n          reject(\r\n            new ErrorInfo(\r\n              'Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)',\r\n              40170,\r\n              401,\r\n            ),\r\n          );\r\n          return;\r\n        }\r\n        if ('issued' in tokenRequestOrDetails) {\r\n          /* a tokenDetails object */\r\n          resolve(tokenRequestOrDetails);\r\n          return;\r\n        }\r\n        if (!('keyName' in tokenRequestOrDetails)) {\r\n          const msg =\r\n            'Expected token request callback to call back with a token string, token request object, or token details object';\r\n          Logger.logAction(Logger.LOG_ERROR, 'Auth.requestToken()', msg);\r\n          reject(new ErrorInfo(msg, 40170, 401));\r\n          return;\r\n        }\r\n        /* it's a token request, so make the request */\r\n        tokenRequest(tokenRequestOrDetails, function (err, tokenResponse, unpacked) {\r\n          if (err) {\r\n            Logger.logAction(\r\n              Logger.LOG_ERROR,\r\n              'Auth.requestToken()',\r\n              'token request API call returned error; err = ' + Utils.inspectError(err),\r\n            );\r\n            reject(normaliseAuthcallbackError(err));\r\n            return;\r\n          }\r\n          if (!unpacked) tokenResponse = JSON.parse(tokenResponse as string);\r\n          Logger.logAction(Logger.LOG_MINOR, 'Auth.getToken()', 'token received');\r\n          resolve(tokenResponse as API.TokenDetails);\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create and sign a token request based on the given options.\r\n   * NOTE this can only be used when the key value is available locally.\r\n   * Otherwise, signed token requests must be obtained from the key\r\n   * owner (either using the token request callback or url).\r\n   *\r\n   * @param authOptions\r\n   * an object containing the request options:\r\n   * - key:           the key to use. If not specified, a key passed in constructing\r\n   *                  the Rest interface will be used\r\n   *\r\n   * - queryTime      (optional) boolean indicating that the ably system should be\r\n   *                  queried for the current time when none is specified explicitly\r\n   *\r\n   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\r\n   *                  requestToken request\r\n   *\r\n   * @param tokenParams\r\n   * an object containing the parameters for the requested token:\r\n   * - ttl:       (optional) the requested life of the token in ms. If none is specified\r\n   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\r\n   *                  exceeding that lifetime will be rejected with an error.\r\n   *\r\n   * - capability:    (optional) the capability to associate with the access token.\r\n   *                  If none is specified, a token will be requested with all of the\r\n   *                  capabilities of the specified key.\r\n   *\r\n   * - clientId:      (optional) a client ID to associate with the token; if not\r\n   *                  specified, a clientId passed in constructing the Rest interface will be used\r\n   *\r\n   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\r\n   *                  the system will be queried for a time value to use.\r\n   */\r\n  async createTokenRequest(tokenParams: API.TokenParams | null, authOptions: any): Promise<API.TokenRequest> {\r\n    /* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */\r\n    authOptions = authOptions || this.authOptions;\r\n    tokenParams = tokenParams || Utils.copy<API.TokenParams>(this.tokenParams);\r\n\r\n    const key = authOptions.key;\r\n    if (!key) {\r\n      throw new ErrorInfo('No key specified', 40101, 403);\r\n    }\r\n    const keyParts = key.split(':'),\r\n      keyName = keyParts[0],\r\n      keySecret = keyParts[1];\r\n\r\n    if (!keySecret) {\r\n      throw new ErrorInfo('Invalid key specified', 40101, 403);\r\n    }\r\n\r\n    if (tokenParams.clientId === '') {\r\n      throw new ErrorInfo('clientId canâ€™t be an empty string', 40012, 400);\r\n    }\r\n\r\n    if ('capability' in tokenParams) {\r\n      tokenParams.capability = c14n(tokenParams.capability);\r\n    }\r\n\r\n    const request: Partial<API.TokenRequest> = Utils.mixin({ keyName: keyName }, tokenParams),\r\n      clientId = tokenParams.clientId || '',\r\n      ttl = tokenParams.ttl || '',\r\n      capability = tokenParams.capability || '';\r\n\r\n    if (!request.timestamp) {\r\n      request.timestamp = await this.getTimestamp(authOptions && authOptions.queryTime);\r\n    }\r\n\r\n    /* nonce */\r\n    /* NOTE: there is no expectation that the client\r\n     * specifies the nonce; this is done by the library\r\n     * However, this can be overridden by the client\r\n     * simply for testing purposes. */\r\n    const nonce = request.nonce || (request.nonce = random()),\r\n      timestamp = request.timestamp;\r\n\r\n    const signText =\r\n      request.keyName + '\\n' + ttl + '\\n' + capability + '\\n' + clientId + '\\n' + timestamp + '\\n' + nonce + '\\n';\r\n\r\n    /* mac */\r\n    /* NOTE: there is no expectation that the client\r\n     * specifies the mac; this is done by the library\r\n     * However, this can be overridden by the client\r\n     * simply for testing purposes. */\r\n    request.mac = request.mac || hmac(signText, keySecret);\r\n\r\n    Logger.logAction(Logger.LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');\r\n\r\n    return request as API.TokenRequest;\r\n  }\r\n\r\n  /**\r\n   * Get the auth query params to use for a websocket connection,\r\n   * based on the current auth parameters\r\n   */\r\n  async getAuthParams(): Promise<Record<string, string>> {\r\n    if (this.method == 'basic') return { key: this.key! };\r\n    else {\r\n      let tokenDetails = await this._ensureValidAuthCredentials(false);\r\n      if (!tokenDetails) {\r\n        throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\r\n      }\r\n      return { access_token: tokenDetails.token };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the authorization header to use for a REST or comet request,\r\n   * based on the current auth parameters\r\n   */\r\n  async getAuthHeaders(): Promise<Record<string, string>> {\r\n    if (this.method == 'basic') {\r\n      return { authorization: 'Basic ' + this.basicKey };\r\n    } else {\r\n      const tokenDetails = await this._ensureValidAuthCredentials(false);\r\n      if (!tokenDetails) {\r\n        throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\r\n      }\r\n      return { authorization: 'Bearer ' + Utils.toBase64(tokenDetails.token) };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the current time based on the local clock,\r\n   * or if the option queryTime is true, return the server time.\r\n   * The server time offset from the local time is stored so that\r\n   * only one request to the server to get the time is ever needed\r\n   */\r\n  async getTimestamp(queryTime: boolean): Promise<number> {\r\n    if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {\r\n      return this.client.time();\r\n    } else {\r\n      return this.getTimestampUsingOffset();\r\n    }\r\n  }\r\n\r\n  getTimestampUsingOffset() {\r\n    return Date.now() + (this.client.serverTimeOffset || 0);\r\n  }\r\n\r\n  isTimeOffsetSet() {\r\n    return this.client.serverTimeOffset !== null;\r\n  }\r\n\r\n  _saveBasicOptions(authOptions: AuthOptions) {\r\n    this.method = 'basic';\r\n    this.key = authOptions.key;\r\n    this.basicKey = Utils.toBase64(authOptions.key as string);\r\n    this.authOptions = authOptions || {};\r\n    if ('clientId' in authOptions) {\r\n      this._userSetClientId(authOptions.clientId);\r\n    }\r\n  }\r\n\r\n  _saveTokenOptions(tokenParams: API.TokenParams | null, authOptions: AuthOptions | null) {\r\n    this.method = 'token';\r\n\r\n    if (tokenParams) {\r\n      /* We temporarily persist tokenParams.timestamp in case a new token needs\r\n       * to be requested, then null it out in the callback of\r\n       * _ensureValidAuthCredentials for RSA10g compliance */\r\n      this.tokenParams = tokenParams;\r\n    }\r\n\r\n    if (authOptions) {\r\n      /* normalise */\r\n      if (authOptions.token) {\r\n        /* options.token may contain a token string or, for convenience, a TokenDetails */\r\n        authOptions.tokenDetails =\r\n          typeof authOptions.token === 'string'\r\n            ? ({ token: authOptions.token } as API.TokenDetails)\r\n            : authOptions.token;\r\n      }\r\n\r\n      if (authOptions.tokenDetails) {\r\n        this.tokenDetails = authOptions.tokenDetails;\r\n      }\r\n\r\n      if ('clientId' in authOptions) {\r\n        this._userSetClientId(authOptions.clientId);\r\n      }\r\n\r\n      this.authOptions = authOptions;\r\n    }\r\n  }\r\n\r\n  /* @param forceSupersede: force a new token request even if there's one in\r\n   * progress, making all pending callbacks wait for the new one */\r\n  async _ensureValidAuthCredentials(forceSupersede: boolean): Promise<API.TokenDetails> {\r\n    const token = this.tokenDetails;\r\n\r\n    if (token) {\r\n      if (this._tokenClientIdMismatch(token.clientId)) {\r\n        /* 403 to trigger a permanently failed client - RSA15c */\r\n        throw new ErrorInfo(\r\n          'Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')',\r\n          40102,\r\n          403,\r\n        );\r\n      }\r\n      /* RSA4b1 -- if we have a server time offset set already, we can\r\n       * automatically remove expired tokens. Else just use the cached token. If it is\r\n       * expired Ably will tell us and we'll discard it then. */\r\n      if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {\r\n        Logger.logAction(Logger.LOG_MINOR, 'Auth.getToken()', 'using cached token; expires = ' + token.expires);\r\n        return token;\r\n      }\r\n      /* expired, so remove and fallthrough to getting a new one */\r\n      Logger.logAction(Logger.LOG_MINOR, 'Auth.getToken()', 'deleting expired token');\r\n      this.tokenDetails = null;\r\n    }\r\n\r\n    const promise = (\r\n      this.waitingForTokenRequest || (this.waitingForTokenRequest = Multicaster.create())\r\n    ).createPromise();\r\n    if (this.currentTokenRequestId !== null && !forceSupersede) {\r\n      return promise;\r\n    }\r\n\r\n    /* Request a new token */\r\n    const tokenRequestId = (this.currentTokenRequestId = getTokenRequestId());\r\n\r\n    let tokenResponse: API.TokenDetails,\r\n      caughtError: ErrorInfo | null = null;\r\n    try {\r\n      tokenResponse = await this.requestToken(this.tokenParams, this.authOptions);\r\n    } catch (err) {\r\n      caughtError = err as ErrorInfo;\r\n    }\r\n\r\n    if ((this.currentTokenRequestId as number) > tokenRequestId) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'Auth._ensureValidAuthCredentials()',\r\n        'Discarding token request response; overtaken by newer one',\r\n      );\r\n      return promise;\r\n    }\r\n\r\n    this.currentTokenRequestId = null;\r\n    const multicaster = this.waitingForTokenRequest;\r\n    this.waitingForTokenRequest = null;\r\n    if (caughtError) {\r\n      multicaster?.rejectAll(caughtError);\r\n      return promise;\r\n    }\r\n    multicaster?.resolveAll((this.tokenDetails = tokenResponse!));\r\n\r\n    return promise;\r\n  }\r\n\r\n  /* User-set: check types, '*' is disallowed, throw any errors */\r\n  _userSetClientId(clientId: string | undefined) {\r\n    if (!(typeof clientId === 'string' || clientId === null)) {\r\n      throw new ErrorInfo('clientId must be either a string or null', 40012, 400);\r\n    } else if (clientId === '*') {\r\n      throw new ErrorInfo(\r\n        'Canâ€™t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)',\r\n        40012,\r\n        400,\r\n      );\r\n    } else {\r\n      const err = this._uncheckedSetClientId(clientId);\r\n      if (err) throw err;\r\n    }\r\n  }\r\n\r\n  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\r\n  _uncheckedSetClientId(clientId: string | undefined) {\r\n    if (this._tokenClientIdMismatch(clientId)) {\r\n      /* Should never happen in normal circumstances as realtime should\r\n       * recognise mismatch and return an error */\r\n      const msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;\r\n      const err = new ErrorInfo(msg, 40102, 401);\r\n      Logger.logAction(Logger.LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);\r\n      return err;\r\n    } else {\r\n      /* RSA7a4: if options.clientId is provided and is not\r\n       * null, it overrides defaultTokenParams.clientId */\r\n      this.clientId = this.tokenParams.clientId = clientId;\r\n      return null;\r\n    }\r\n  }\r\n\r\n  _tokenClientIdMismatch(tokenClientId?: string | null): boolean {\r\n    return !!(\r\n      this.clientId &&\r\n      this.clientId !== '*' &&\r\n      tokenClientId &&\r\n      tokenClientId !== '*' &&\r\n      this.clientId !== tokenClientId\r\n    );\r\n  }\r\n\r\n  static isTokenErr(error: IPartialErrorInfo) {\r\n    return error.code && error.code >= 40140 && error.code < 40150;\r\n  }\r\n\r\n  revokeTokens(\r\n    specifiers: TokenRevocationTargetSpecifier[],\r\n    options?: TokenRevocationOptions,\r\n  ): Promise<TokenRevocationResult> {\r\n    return this.client.rest.revokeTokens(specifiers, options);\r\n  }\r\n}\r\n\r\nexport default Auth;\r\n","import Defaults from 'common/lib/util/defaults';\r\nimport Platform from 'common/platform';\r\nimport BaseRealtime from 'common/lib/client/baserealtime';\r\nimport HttpMethods from '../constants/HttpMethods';\r\nimport BaseClient from '../lib/client/baseclient';\r\nimport ErrorInfo, { IPartialErrorInfo } from '../lib/types/errorinfo';\r\nimport Logger from 'common/lib/util/logger';\r\nimport * as Utils from 'common/lib/util/utils';\r\n\r\nexport type PathParameter = string | ((host: string) => string);\r\nexport type ResponseHeaders = Partial<Record<string, string | string[]>>;\r\nexport type RequestResultError = ErrnoException | IPartialErrorInfo;\r\n\r\n/**\r\n * The `body`, `headers`, `unpacked`, and `statusCode` properties of a `RequestResult` may be populated even if its `error` property is non-null.\r\n */\r\nexport type RequestResult = {\r\n  error: RequestResultError | null;\r\n  body?: unknown;\r\n  headers?: ResponseHeaders;\r\n  unpacked?: boolean;\r\n  statusCode?: number;\r\n};\r\n\r\nexport type RequestParams = Record<string, string> | null;\r\nexport type RequestBody =\r\n  | Buffer // only on Node\r\n  | ArrayBuffer // only on web\r\n  | string;\r\n\r\nexport interface IPlatformHttpStatic {\r\n  new (client?: BaseClient): IPlatformHttp;\r\n  methods: Array<HttpMethods>;\r\n  methodsWithBody: Array<HttpMethods>;\r\n  methodsWithoutBody: Array<HttpMethods>;\r\n}\r\n\r\nexport interface IPlatformHttp {\r\n  supportsAuthHeaders: boolean;\r\n  supportsLinkHeaders: boolean;\r\n\r\n  /**\r\n   * This method should not throw any errors; rather, it should communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\r\n   */\r\n  doUri(\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult>;\r\n\r\n  checkConnectivity?: () => Promise<boolean>;\r\n\r\n  /**\r\n   * @param error An error from the {@link RequestResult.error} property of a result returned by {@link doUri}.\r\n   */\r\n  shouldFallback(error: RequestResultError): boolean;\r\n}\r\n\r\nexport function paramString(params: Record<string, any> | null) {\r\n  const paramPairs = [];\r\n  if (params) {\r\n    for (const needle in params) {\r\n      paramPairs.push(needle + '=' + params[needle]);\r\n    }\r\n  }\r\n  return paramPairs.join('&');\r\n}\r\n\r\nexport function appendingParams(uri: string, params: Record<string, any> | null) {\r\n  return uri + (params ? '?' : '') + paramString(params);\r\n}\r\n\r\nfunction logResult(result: RequestResult, method: HttpMethods, uri: string, params: Record<string, string> | null) {\r\n  if (result.error) {\r\n    Logger.logActionNoStrip(\r\n      Logger.LOG_MICRO,\r\n      'Http.' + method + '()',\r\n      'Received Error; ' + appendingParams(uri, params) + '; Error: ' + Utils.inspectError(result.error),\r\n    );\r\n  } else {\r\n    Logger.logActionNoStrip(\r\n      Logger.LOG_MICRO,\r\n      'Http.' + method + '()',\r\n      'Received; ' +\r\n        appendingParams(uri, params) +\r\n        '; Headers: ' +\r\n        paramString(result.headers as Record<string, any>) +\r\n        '; StatusCode: ' +\r\n        result.statusCode +\r\n        '; Body' +\r\n        (Platform.BufferUtils.isBuffer(result.body)\r\n          ? ' (Base64): ' + Platform.BufferUtils.base64Encode(result.body)\r\n          : ': ' + result.body),\r\n    );\r\n  }\r\n}\r\n\r\nfunction logRequest(method: HttpMethods, uri: string, body: RequestBody | null, params: RequestParams) {\r\n  if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n    Logger.logActionNoStrip(\r\n      Logger.LOG_MICRO,\r\n      'Http.' + method + '()',\r\n      'Sending; ' +\r\n        appendingParams(uri, params) +\r\n        '; Body' +\r\n        (Platform.BufferUtils.isBuffer(body) ? ' (Base64): ' + Platform.BufferUtils.base64Encode(body) : ': ' + body),\r\n    );\r\n  }\r\n}\r\n\r\nexport class Http {\r\n  private readonly platformHttp: IPlatformHttp;\r\n  checkConnectivity?: () => Promise<boolean>;\r\n\r\n  constructor(private readonly client?: BaseClient) {\r\n    this.platformHttp = new Platform.Http(client);\r\n\r\n    this.checkConnectivity = this.platformHttp.checkConnectivity\r\n      ? () => this.platformHttp.checkConnectivity!()\r\n      : undefined;\r\n  }\r\n\r\n  get supportsAuthHeaders() {\r\n    return this.platformHttp.supportsAuthHeaders;\r\n  }\r\n\r\n  get supportsLinkHeaders() {\r\n    return this.platformHttp.supportsLinkHeaders;\r\n  }\r\n\r\n  _getHosts(client: BaseClient) {\r\n    /* If we're a connected realtime client, try the endpoint we're connected\r\n     * to first -- but still have fallbacks, being connected is not an absolute\r\n     * guarantee that a datacenter has free capacity to service REST requests. */\r\n    const connection = (client as BaseRealtime).connection,\r\n      connectionHost = connection && connection.connectionManager.host;\r\n\r\n    if (connectionHost) {\r\n      return [connectionHost].concat(Defaults.getFallbackHosts(client.options));\r\n    }\r\n\r\n    return Defaults.getHosts(client.options);\r\n  }\r\n\r\n  /**\r\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\r\n   */\r\n  async do(\r\n    method: HttpMethods,\r\n    path: PathParameter,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult> {\r\n    try {\r\n      /* Unlike for doUri, the presence of `this.client` here is mandatory, as it's used to generate the hosts */\r\n      const client = this.client;\r\n      if (!client) {\r\n        return { error: new ErrorInfo('http.do called without client', 50000, 500) };\r\n      }\r\n\r\n      const uriFromHost =\r\n        typeof path === 'function'\r\n          ? path\r\n          : function (host: string) {\r\n              return client.baseUri(host) + path;\r\n            };\r\n\r\n      const currentFallback = client._currentFallback;\r\n      if (currentFallback) {\r\n        if (currentFallback.validUntil > Date.now()) {\r\n          /* Use stored fallback */\r\n          const result = await this.doUri(method, uriFromHost(currentFallback.host), headers, body, params);\r\n          if (result.error && this.platformHttp.shouldFallback(result.error as ErrnoException)) {\r\n            /* unstore the fallback and start from the top with the default sequence */\r\n            client._currentFallback = null;\r\n            return this.do(method, path, headers, body, params);\r\n          }\r\n          return result;\r\n        } else {\r\n          /* Fallback expired; remove it and fallthrough to normal sequence */\r\n          client._currentFallback = null;\r\n        }\r\n      }\r\n\r\n      const hosts = this._getHosts(client);\r\n\r\n      /* see if we have one or more than one host */\r\n      if (hosts.length === 1) {\r\n        return this.doUri(method, uriFromHost(hosts[0]), headers, body, params);\r\n      }\r\n\r\n      const tryAHost = async (candidateHosts: Array<string>, persistOnSuccess?: boolean): Promise<RequestResult> => {\r\n        const host = candidateHosts.shift();\r\n        const result = await this.doUri(method, uriFromHost(host as string), headers, body, params);\r\n        if (result.error && this.platformHttp.shouldFallback(result.error as ErrnoException) && candidateHosts.length) {\r\n          return tryAHost(candidateHosts, true);\r\n        }\r\n        if (persistOnSuccess) {\r\n          /* RSC15f */\r\n          client._currentFallback = {\r\n            host: host as string,\r\n            validUntil: Date.now() + client.options.timeouts.fallbackRetryTimeout,\r\n          };\r\n        }\r\n        return result;\r\n      };\r\n      return tryAHost(hosts);\r\n    } catch (err) {\r\n      // Handle any unexpected error, to ensure we always meet our contract of not throwing any errors\r\n      return { error: new ErrorInfo(`Unexpected error in Http.do: ${Utils.inspectError(err)}`, 500, 50000) };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This method will not throw any errors; rather, it will communicate any error by populating the {@link RequestResult.error} property of the returned {@link RequestResult}.\r\n   */\r\n  async doUri(\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult> {\r\n    try {\r\n      logRequest(method, uri, body, params);\r\n\r\n      const result = await this.platformHttp.doUri(method, uri, headers, body, params);\r\n\r\n      if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n        logResult(result, method, uri, params);\r\n      }\r\n\r\n      return result;\r\n    } catch (err) {\r\n      // Handle any unexpected error, to ensure we always meet our contract of not throwing any errors\r\n      return { error: new ErrorInfo(`Unexpected error in Http.doUri: ${Utils.inspectError(err)}`, 500, 50000) };\r\n    }\r\n  }\r\n}\r\n\r\nexport interface ErrnoException extends Error {\r\n  errno?: number;\r\n  code?: string;\r\n  path?: string;\r\n  syscall?: string;\r\n  stack?: string;\r\n  statusCode: number;\r\n}\r\n","import Logger, { LoggerOptions } from '../util/logger';\r\nimport Defaults from '../util/defaults';\r\nimport Auth from './auth';\r\nimport { HttpPaginatedResponse, PaginatedResult } from './paginatedresource';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Stats from '../types/stats';\r\nimport { Http, RequestParams } from '../../types/http';\r\nimport ClientOptions, { NormalisedClientOptions } from '../../types/ClientOptions';\r\nimport * as API from '../../../../ably';\r\n\r\nimport Platform from '../../platform';\r\nimport { Rest } from './rest';\r\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\r\nimport { throwMissingPluginError } from '../util/utils';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { HTTPRequestImplementations } from 'platform/web/lib/http/http';\r\nimport { FilteredSubscriptions } from './filteredsubscriptions';\r\n\r\ntype BatchResult<T> = API.BatchResult<T>;\r\ntype BatchPublishSpec = API.BatchPublishSpec;\r\ntype BatchPublishSuccessResult = API.BatchPublishSuccessResult;\r\ntype BatchPublishFailureResult = API.BatchPublishFailureResult;\r\ntype BatchPublishResult = BatchResult<BatchPublishSuccessResult | BatchPublishFailureResult>;\r\ntype BatchPresenceSuccessResult = API.BatchPresenceSuccessResult;\r\ntype BatchPresenceFailureResult = API.BatchPresenceFailureResult;\r\ntype BatchPresenceResult = BatchResult<BatchPresenceSuccessResult | BatchPresenceFailureResult>;\r\n\r\n/**\r\n `BaseClient` acts as the base class for all of the client classes exported by the SDK. It is an implementation detail and this class is not advertised publicly.\r\n */\r\nclass BaseClient {\r\n  options: NormalisedClientOptions;\r\n  _currentFallback: null | {\r\n    host: string;\r\n    validUntil: number;\r\n  };\r\n  serverTimeOffset: number | null;\r\n  http: Http;\r\n  auth: Auth;\r\n\r\n  private readonly _rest: Rest | null;\r\n  readonly _Crypto: IUntypedCryptoStatic | null;\r\n  readonly _MsgPack: MsgPack | null;\r\n  // Extra HTTP request implementations available to this client, in addition to those in webâ€™s Http.bundledRequestImplementations\r\n  readonly _additionalHTTPRequestImplementations: HTTPRequestImplementations | null;\r\n  private readonly __FilteredSubscriptions: typeof FilteredSubscriptions | null;\r\n\r\n  constructor(options: ClientOptions) {\r\n    this._additionalHTTPRequestImplementations = options.plugins ?? null;\r\n\r\n    Logger.setLog(options.logLevel, options.logHandler);\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'BaseClient()',\r\n      'initialized with clientOptions ' + Platform.Config.inspect(options),\r\n    );\r\n\r\n    this._MsgPack = options.plugins?.MsgPack ?? null;\r\n    const normalOptions = (this.options = Defaults.normaliseOptions(options, this._MsgPack));\r\n\r\n    /* process options */\r\n    if (normalOptions.key) {\r\n      const keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\r\n      if (!keyMatch) {\r\n        const msg = 'invalid key parameter';\r\n        Logger.logAction(Logger.LOG_ERROR, 'BaseClient()', msg);\r\n        throw new ErrorInfo(msg, 40400, 404);\r\n      }\r\n      normalOptions.keyName = keyMatch[1];\r\n      normalOptions.keySecret = keyMatch[2];\r\n    }\r\n\r\n    if ('clientId' in normalOptions) {\r\n      if (!(typeof normalOptions.clientId === 'string' || normalOptions.clientId === null))\r\n        throw new ErrorInfo('clientId must be either a string or null', 40012, 400);\r\n      else if (normalOptions.clientId === '*')\r\n        throw new ErrorInfo(\r\n          'Canâ€™t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})',\r\n          40012,\r\n          400,\r\n        );\r\n    }\r\n\r\n    Logger.logAction(Logger.LOG_MINOR, 'BaseClient()', 'started; version = ' + Defaults.version);\r\n\r\n    this._currentFallback = null;\r\n\r\n    this.serverTimeOffset = null;\r\n    this.http = new Http(this);\r\n    this.auth = new Auth(this, normalOptions);\r\n\r\n    this._rest = options.plugins?.Rest ? new options.plugins.Rest(this) : null;\r\n    this._Crypto = options.plugins?.Crypto ?? null;\r\n    this.__FilteredSubscriptions = options.plugins?.MessageInteractions ?? null;\r\n  }\r\n\r\n  get rest(): Rest {\r\n    if (!this._rest) {\r\n      throwMissingPluginError('Rest');\r\n    }\r\n    return this._rest;\r\n  }\r\n\r\n  get _FilteredSubscriptions(): typeof FilteredSubscriptions {\r\n    if (!this.__FilteredSubscriptions) {\r\n      throwMissingPluginError('MessageInteractions');\r\n    }\r\n    return this.__FilteredSubscriptions;\r\n  }\r\n\r\n  get channels() {\r\n    return this.rest.channels;\r\n  }\r\n\r\n  get push() {\r\n    return this.rest.push;\r\n  }\r\n\r\n  baseUri(host: string) {\r\n    return Defaults.getHttpScheme(this.options) + host + ':' + Defaults.getPort(this.options, false);\r\n  }\r\n\r\n  async stats(params: RequestParams): Promise<PaginatedResult<Stats>> {\r\n    return this.rest.stats(params);\r\n  }\r\n\r\n  async time(params?: RequestParams): Promise<number> {\r\n    return this.rest.time(params);\r\n  }\r\n\r\n  async request(\r\n    method: string,\r\n    path: string,\r\n    version: number,\r\n    params: RequestParams,\r\n    body: unknown,\r\n    customHeaders: Record<string, string>,\r\n  ): Promise<HttpPaginatedResponse<unknown>> {\r\n    return this.rest.request(method, path, version, params, body, customHeaders);\r\n  }\r\n\r\n  batchPublish<T extends BatchPublishSpec | BatchPublishSpec[]>(\r\n    specOrSpecs: T,\r\n  ): Promise<T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[]> {\r\n    return this.rest.batchPublish(specOrSpecs);\r\n  }\r\n\r\n  batchPresence(channels: string[]): Promise<BatchPresenceResult> {\r\n    return this.rest.batchPresence(channels);\r\n  }\r\n\r\n  setLog(logOptions: LoggerOptions): void {\r\n    Logger.setLog(logOptions.level, logOptions.handler);\r\n  }\r\n\r\n  static Platform = Platform;\r\n}\r\n\r\nexport default BaseClient;\r\n","import { MsgPack } from 'common/types/msgpack';\r\nimport * as Utils from '../util/utils';\r\nimport ErrorInfo, { IConvertibleToErrorInfo } from './errorinfo';\r\n\r\nenum DeviceFormFactor {\r\n  Phone = 'phone',\r\n  Tablet = 'tablet',\r\n  Desktop = 'desktop',\r\n  TV = 'tv',\r\n  Watch = 'watch',\r\n  Car = 'car',\r\n  Embedded = 'embedded',\r\n  Other = 'other',\r\n}\r\n\r\nenum DevicePlatform {\r\n  Android = 'android',\r\n  IOS = 'ios',\r\n  Browser = 'browser',\r\n}\r\n\r\ntype DevicePushState = 'ACTIVE' | 'FAILING' | 'FAILED';\r\n\r\ntype DevicePushDetails = {\r\n  error?: ErrorInfo;\r\n  recipient?: string;\r\n  state?: DevicePushState;\r\n  metadata?: string;\r\n};\r\n\r\nclass DeviceDetails {\r\n  id?: string;\r\n  clientId?: string;\r\n  deviceSecret?: string;\r\n  formFactor?: DeviceFormFactor;\r\n  platform?: DevicePlatform;\r\n  push?: DevicePushDetails;\r\n  metadata?: string;\r\n  deviceIdentityToken?: string;\r\n\r\n  toJSON(): DeviceDetails {\r\n    return {\r\n      id: this.id,\r\n      deviceSecret: this.deviceSecret,\r\n      platform: this.platform,\r\n      formFactor: this.formFactor,\r\n      clientId: this.clientId,\r\n      metadata: this.metadata,\r\n      deviceIdentityToken: this.deviceIdentityToken,\r\n      push: {\r\n        recipient: this.push?.recipient,\r\n        state: this.push?.state,\r\n        error: this.push?.error,\r\n      },\r\n    } as DeviceDetails;\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[DeviceDetails';\r\n    if (this.id) result += '; id=' + this.id;\r\n    if (this.platform) result += '; platform=' + this.platform;\r\n    if (this.formFactor) result += '; formFactor=' + this.formFactor;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    if (this.metadata) result += '; metadata=' + this.metadata;\r\n    if (this.deviceIdentityToken) result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);\r\n    if (this.push?.recipient) result += '; push.recipient=' + JSON.stringify(this.push.recipient);\r\n    if (this.push?.state) result += '; push.state=' + this.push.state;\r\n    if (this.push?.error) result += '; push.error=' + JSON.stringify(this.push.error);\r\n    if (this.push?.metadata) result += '; push.metadata=' + this.push.metadata;\r\n    result += ']';\r\n    return result;\r\n  }\r\n\r\n  static toRequestBody(body: unknown, MsgPack: MsgPack | null, format?: Utils.Format) {\r\n    return Utils.encodeBody(body, MsgPack, format);\r\n  }\r\n\r\n  static fromResponseBody(\r\n    body: Array<Record<string, unknown>> | Record<string, unknown>,\r\n    MsgPack: MsgPack | null,\r\n    format?: Utils.Format,\r\n  ): DeviceDetails | DeviceDetails[] {\r\n    if (format) {\r\n      body = Utils.decodeBody(body, MsgPack, format);\r\n    }\r\n\r\n    if (Array.isArray(body)) {\r\n      return DeviceDetails.fromValuesArray(body);\r\n    } else {\r\n      return DeviceDetails.fromValues(body);\r\n    }\r\n  }\r\n\r\n  static fromValues(values: Record<string, unknown>): DeviceDetails {\r\n    values.error = values.error && ErrorInfo.fromValues(values.error as IConvertibleToErrorInfo);\r\n    return Object.assign(new DeviceDetails(), values);\r\n  }\r\n\r\n  static fromValuesArray(values: Array<Record<string, unknown>>): DeviceDetails[] {\r\n    const count = values.length,\r\n      result = new Array(count);\r\n    for (let i = 0; i < count; i++) result[i] = DeviceDetails.fromValues(values[i]);\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default DeviceDetails;\r\n","import Platform from '../../platform';\r\nimport * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport Auth from './auth';\r\nimport HttpMethods from '../../constants/HttpMethods';\r\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from '../types/errorinfo';\r\nimport BaseClient from './baseclient';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { RequestBody, ResponseHeaders, appendingParams as urlFromPathAndParams, paramString } from 'common/types/http';\r\nimport httpStatusCodes from '../../constants/HttpStatusCodes';\r\n\r\nasync function withAuthDetails<T>(\r\n  client: BaseClient,\r\n  headers: ResponseHeaders | undefined,\r\n  params: Record<string, any>,\r\n  opCallback: Function,\r\n): Promise<ResourceResult<T>> {\r\n  if (client.http.supportsAuthHeaders) {\r\n    const authHeaders = await client.auth.getAuthHeaders();\r\n    return opCallback(Utils.mixin(authHeaders!, headers), params);\r\n  } else {\r\n    const authParams = await client.auth.getAuthParams();\r\n    return opCallback(headers, Utils.mixin(authParams!, params));\r\n  }\r\n}\r\n\r\nfunction unenvelope<T>(\r\n  result: ResourceResult<T>,\r\n  MsgPack: MsgPack | null,\r\n  format: Utils.Format | null,\r\n): ResourceResult<T> {\r\n  if (result.err && !result.body) {\r\n    return { err: result.err };\r\n  }\r\n\r\n  if (result.statusCode === httpStatusCodes.NoContent) {\r\n    return { ...result, body: [] as any, unpacked: true };\r\n  }\r\n\r\n  let body = result.body;\r\n\r\n  if (!result.unpacked) {\r\n    try {\r\n      body = Utils.decodeBody(body, MsgPack, format);\r\n    } catch (e) {\r\n      if (Utils.isErrorInfoOrPartialErrorInfo(e)) {\r\n        return { err: e };\r\n      } else {\r\n        return { err: new PartialErrorInfo(Utils.inspectError(e), null) };\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!body) {\r\n    return { err: new PartialErrorInfo('unenvelope(): Response body is missing', null) };\r\n  }\r\n\r\n  const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body as Record<string, any>;\r\n\r\n  if (wrappedStatusCode === undefined) {\r\n    /* Envelope already unwrapped by the transport */\r\n    return { ...result, body, unpacked: true };\r\n  }\r\n\r\n  if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\r\n    /* handle wrapped errors */\r\n    let wrappedErr = (response && response.error) || result.err;\r\n    if (!wrappedErr) {\r\n      wrappedErr = new Error('Error in unenveloping ' + body);\r\n      wrappedErr.statusCode = wrappedStatusCode;\r\n    }\r\n    return { err: wrappedErr, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\r\n  }\r\n\r\n  return { err: result.err, body: response, headers: wrappedHeaders, unpacked: true, statusCode: wrappedStatusCode };\r\n}\r\n\r\nfunction logResult<T>(result: ResourceResult<T>, method: HttpMethods, path: string, params: Record<string, string>) {\r\n  if (result.err) {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'Resource.' + method + '()',\r\n      'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + Utils.inspectError(result.err),\r\n    );\r\n  } else {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'Resource.' + method + '()',\r\n      'Received; ' +\r\n        urlFromPathAndParams(path, params) +\r\n        '; Headers: ' +\r\n        paramString(result.headers as Record<string, any>) +\r\n        '; StatusCode: ' +\r\n        result.statusCode +\r\n        '; Body: ' +\r\n        (Platform.BufferUtils.isBuffer(result.body)\r\n          ? ' (Base64): ' + Platform.BufferUtils.base64Encode(result.body)\r\n          : ': ' + Platform.Config.inspect(result.body)),\r\n    );\r\n  }\r\n}\r\n\r\nexport interface ResourceResponse<T> {\r\n  body?: T;\r\n  headers?: ResponseHeaders;\r\n  unpacked?: boolean;\r\n  statusCode?: number;\r\n}\r\n\r\nexport interface ResourceResult<T> extends ResourceResponse<T> {\r\n  /**\r\n   * Any error returned by the underlying HTTP client.\r\n   */\r\n  err: IPartialErrorInfo | null;\r\n}\r\n\r\nclass Resource {\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async get<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async get<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async get<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Get, client, path, null, headers, params, envelope, throwError ?? false);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async delete<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async delete<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async delete<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Delete, client, path, null, headers, params, envelope, throwError);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async post<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async post<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async post<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Post, client, path, body, headers, params, envelope, throwError);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async patch<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async patch<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async patch<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Patch, client, path, body, headers, params, envelope, throwError);\r\n  }\r\n\r\n  /**\r\n   * @param throwError Whether to throw any error returned by the underlying HTTP client.\r\n   *\r\n   * If you specify `true`, then this method will return a `ResourceResponse<T>`, and if the underlying HTTP client returns an error, this method call will throw that error. If you specify `false`, then it will return a `ResourceResult<T>`, whose `err` property contains any error that was returned by the underlying HTTP client.\r\n   */\r\n  static async put<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: true,\r\n  ): Promise<ResourceResponse<T>>;\r\n  static async put<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: false,\r\n  ): Promise<ResourceResult<T>>;\r\n  static async put<T = unknown>(\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    return Resource.do(HttpMethods.Put, client, path, body, headers, params, envelope, throwError);\r\n  }\r\n\r\n  static async do<T>(\r\n    method: HttpMethods,\r\n    client: BaseClient,\r\n    path: string,\r\n    body: RequestBody | null,\r\n    headers: Record<string, string>,\r\n    params: Record<string, any>,\r\n    envelope: Utils.Format | null,\r\n    throwError: boolean,\r\n  ): Promise<ResourceResponse<T> | ResourceResult<T>> {\r\n    if (envelope) {\r\n      (params = params || {})['envelope'] = envelope;\r\n    }\r\n\r\n    async function doRequest(\r\n      this: any,\r\n      headers: Record<string, string>,\r\n      params: Record<string, any>,\r\n    ): Promise<ResourceResult<T>> {\r\n      if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n        let decodedBody = body;\r\n        if (headers['content-type']?.indexOf('msgpack') > 0) {\r\n          try {\r\n            if (!client._MsgPack) {\r\n              Utils.throwMissingPluginError('MsgPack');\r\n            }\r\n            decodedBody = client._MsgPack.decode(body as Buffer);\r\n          } catch (decodeErr) {\r\n            Logger.logAction(\r\n              Logger.LOG_MICRO,\r\n              'Resource.' + method + '()',\r\n              'Sending MsgPack Decoding Error: ' + Utils.inspectError(decodeErr),\r\n            );\r\n          }\r\n        }\r\n        Logger.logAction(\r\n          Logger.LOG_MICRO,\r\n          'Resource.' + method + '()',\r\n          'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody,\r\n        );\r\n      }\r\n\r\n      const httpResult = await client.http.do(method, path, headers, body, params);\r\n\r\n      if (httpResult.error && Auth.isTokenErr(httpResult.error as ErrorInfo)) {\r\n        /* token has expired, so get a new one */\r\n        await client.auth.authorize(null, null);\r\n        /* retry ... */\r\n        return withAuthDetails(client, headers, params, doRequest);\r\n      }\r\n\r\n      return {\r\n        err: httpResult.error as ErrorInfo,\r\n        body: httpResult.body as T | undefined,\r\n        headers: httpResult.headers,\r\n        unpacked: httpResult.unpacked,\r\n        statusCode: httpResult.statusCode,\r\n      };\r\n    }\r\n\r\n    let result = await withAuthDetails<T>(client, headers, params, doRequest);\r\n\r\n    if (envelope) {\r\n      result = unenvelope(result, client._MsgPack, envelope);\r\n    }\r\n\r\n    if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n      logResult(result, method, path, params);\r\n    }\r\n\r\n    if (throwError) {\r\n      if (result.err) {\r\n        throw result.err;\r\n      } else {\r\n        const response: Omit<ResourceResult<T>, 'err'> & Pick<Partial<ResourceResult<T>>, 'err'> = { ...result };\r\n        delete response.err;\r\n        return response;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default Resource;\r\n","import * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport Resource, { ResourceResult } from './resource';\r\nimport { IPartialErrorInfo } from '../types/errorinfo';\r\nimport BaseClient from './baseclient';\r\nimport { RequestBody, ResponseHeaders } from 'common/types/http';\r\nimport HttpStatusCodes from '../../constants/HttpStatusCodes';\r\n\r\nexport type BodyHandler = (body: unknown, headers: ResponseHeaders, unpacked?: boolean) => Promise<any>;\r\n\r\nfunction getRelParams(linkUrl: string) {\r\n  const urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\r\n  return urlMatch && urlMatch[2] && Utils.parseQueryString(urlMatch[2]);\r\n}\r\n\r\nfunction parseRelLinks(linkHeader: string | Array<string>) {\r\n  if (typeof linkHeader == 'string') linkHeader = linkHeader.split(',');\r\n\r\n  const relParams: Record<string, Record<string, string>> = {};\r\n  for (let i = 0; i < linkHeader.length; i++) {\r\n    const linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\r\n    if (linkMatch) {\r\n      const params = getRelParams(linkMatch[1]);\r\n      if (params) relParams[linkMatch[2]] = params;\r\n    }\r\n  }\r\n  return relParams;\r\n}\r\n\r\nfunction returnErrOnly(err: IPartialErrorInfo, body: unknown, useHPR?: boolean) {\r\n  /* If using httpPaginatedResponse, errors from Ably are returned as part of\r\n   * the HPR, only throw `err` for network errors etc. which don't\r\n   * return a body and/or have no ably-originated error code (non-numeric\r\n   * error codes originate from node) */\r\n  return !(useHPR && (body || typeof err.code === 'number'));\r\n}\r\n\r\nclass PaginatedResource {\r\n  client: BaseClient;\r\n  path: string;\r\n  headers: Record<string, string>;\r\n  envelope: Utils.Format | null;\r\n  bodyHandler: BodyHandler;\r\n  useHttpPaginatedResponse: boolean;\r\n\r\n  constructor(\r\n    client: BaseClient,\r\n    path: string,\r\n    headers: Record<string, string>,\r\n    envelope: Utils.Format | undefined,\r\n    bodyHandler: BodyHandler,\r\n    useHttpPaginatedResponse?: boolean,\r\n  ) {\r\n    this.client = client;\r\n    this.path = path;\r\n    this.headers = headers;\r\n    this.envelope = envelope ?? null;\r\n    this.bodyHandler = bodyHandler;\r\n    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\r\n  }\r\n\r\n  async get<T1, T2>(params: Record<string, T2>): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.get<T1>(this.client, this.path, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async delete<T1, T2>(params: Record<string, T2>): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.delete<T1>(this.client, this.path, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async post<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.post<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async put<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.put<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async patch<T1, T2>(params: Record<string, T2>, body: RequestBody | null): Promise<PaginatedResult<T1>> {\r\n    const result = await Resource.patch<T1>(this.client, this.path, body, this.headers, params, this.envelope, false);\r\n    return this.handlePage(result);\r\n  }\r\n\r\n  async handlePage<T>(result: ResourceResult<T>): Promise<PaginatedResult<T>> {\r\n    if (result.err && returnErrOnly(result.err, result.body, this.useHttpPaginatedResponse)) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'PaginatedResource.handlePage()',\r\n        'Unexpected error getting resource: err = ' + Utils.inspectError(result.err),\r\n      );\r\n      throw result.err;\r\n    }\r\n\r\n    let items, linkHeader, relParams;\r\n\r\n    try {\r\n      items =\r\n        result.statusCode == HttpStatusCodes.NoContent\r\n          ? []\r\n          : await this.bodyHandler(result.body, result.headers || {}, result.unpacked);\r\n    } catch (e) {\r\n      /* If we got an error, the failure to parse the body is almost certainly\r\n       * due to that, so throw that in preference over the parse error */\r\n      throw result.err || e;\r\n    }\r\n\r\n    if (result.headers && (linkHeader = result.headers['Link'] || result.headers['link'])) {\r\n      relParams = parseRelLinks(linkHeader);\r\n    }\r\n\r\n    if (this.useHttpPaginatedResponse) {\r\n      return new HttpPaginatedResponse(\r\n        this,\r\n        items,\r\n        result.headers || {},\r\n        result.statusCode as number,\r\n        relParams,\r\n        result.err,\r\n      );\r\n    } else {\r\n      return new PaginatedResult(this, items, relParams);\r\n    }\r\n  }\r\n}\r\n\r\nexport class PaginatedResult<T> {\r\n  resource: PaginatedResource;\r\n  items: T[];\r\n  first?: () => Promise<PaginatedResult<T>>;\r\n  next?: () => Promise<PaginatedResult<T> | null>;\r\n  current?: () => Promise<PaginatedResult<T>>;\r\n  hasNext?: () => boolean;\r\n  isLast?: () => boolean;\r\n\r\n  constructor(resource: PaginatedResource, items: T[], relParams?: Record<string, any>) {\r\n    this.resource = resource;\r\n    this.items = items;\r\n\r\n    const self = this;\r\n    if (relParams) {\r\n      if ('first' in relParams) {\r\n        this.first = async function () {\r\n          return self.get(relParams.first);\r\n        };\r\n      }\r\n      if ('current' in relParams) {\r\n        this.current = async function () {\r\n          return self.get(relParams.current);\r\n        };\r\n      }\r\n      this.next = async function () {\r\n        if ('next' in relParams) {\r\n          return self.get(relParams.next);\r\n        } else {\r\n          return null;\r\n        }\r\n      };\r\n\r\n      this.hasNext = function () {\r\n        return 'next' in relParams;\r\n      };\r\n      this.isLast = () => {\r\n        return !this.hasNext?.();\r\n      };\r\n    }\r\n  }\r\n\r\n  /* We assume that only the initial request can be a POST, and that accessing\r\n   * the rest of a multipage set of results can always be done with GET */\r\n  async get(params: any): Promise<PaginatedResult<T>> {\r\n    const res = this.resource;\r\n    const result = await Resource.get<T>(res.client, res.path, res.headers, params, res.envelope, false);\r\n    return res.handlePage(result);\r\n  }\r\n}\r\n\r\nexport class HttpPaginatedResponse<T> extends PaginatedResult<T> {\r\n  statusCode: number;\r\n  success: boolean;\r\n  headers: ResponseHeaders;\r\n  errorCode?: number | null;\r\n  errorMessage?: string | null;\r\n\r\n  constructor(\r\n    resource: PaginatedResource,\r\n    items: T[],\r\n    headers: ResponseHeaders,\r\n    statusCode: number,\r\n    relParams: any,\r\n    err: IPartialErrorInfo | null,\r\n  ) {\r\n    super(resource, items, relParams);\r\n    this.statusCode = statusCode;\r\n    this.success = statusCode < 300 && statusCode >= 200;\r\n    this.headers = headers;\r\n    this.errorCode = err && err.code;\r\n    this.errorMessage = err && err.message;\r\n  }\r\n\r\n  toJSON() {\r\n    return {\r\n      items: this.items,\r\n      statusCode: this.statusCode,\r\n      success: this.success,\r\n      headers: this.headers,\r\n      errorCode: this.errorCode,\r\n      errorMessage: this.errorMessage,\r\n    };\r\n  }\r\n}\r\n\r\nexport default PaginatedResource;\r\n","import { MsgPack } from 'common/types/msgpack';\r\nimport * as Utils from '../util/utils';\r\n\r\ntype PushChannelSubscriptionObject = {\r\n  channel?: string;\r\n  deviceId?: string;\r\n  clientId?: string;\r\n};\r\n\r\nclass PushChannelSubscription {\r\n  channel?: string;\r\n  deviceId?: string;\r\n  clientId?: string;\r\n\r\n  /**\r\n   * Overload toJSON() to intercept JSON.stringify()\r\n   * @return {*}\r\n   */\r\n  toJSON(): PushChannelSubscriptionObject {\r\n    return {\r\n      channel: this.channel,\r\n      deviceId: this.deviceId,\r\n      clientId: this.clientId,\r\n    };\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[PushChannelSubscription';\r\n    if (this.channel) result += '; channel=' + this.channel;\r\n    if (this.deviceId) result += '; deviceId=' + this.deviceId;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    result += ']';\r\n    return result;\r\n  }\r\n\r\n  static toRequestBody = Utils.encodeBody;\r\n\r\n  static fromResponseBody(\r\n    body: Array<Record<string, unknown>> | Record<string, unknown>,\r\n    MsgPack: MsgPack | null,\r\n    format?: Utils.Format,\r\n  ): PushChannelSubscription | PushChannelSubscription[] {\r\n    if (format) {\r\n      body = Utils.decodeBody(body, MsgPack, format) as Record<string, unknown>;\r\n    }\r\n\r\n    if (Array.isArray(body)) {\r\n      return PushChannelSubscription.fromValuesArray(body);\r\n    } else {\r\n      return PushChannelSubscription.fromValues(body);\r\n    }\r\n  }\r\n\r\n  static fromValues(values: Record<string, unknown>): PushChannelSubscription {\r\n    return Object.assign(new PushChannelSubscription(), values);\r\n  }\r\n\r\n  static fromValuesArray(values: Array<Record<string, unknown>>): PushChannelSubscription[] {\r\n    const count = values.length,\r\n      result = new Array(count);\r\n    for (let i = 0; i < count; i++) result[i] = PushChannelSubscription.fromValues(values[i]);\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default PushChannelSubscription;\r\n","import * as Utils from '../util/utils';\r\nimport DeviceDetails from '../types/devicedetails';\r\nimport Resource from './resource';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport PushChannelSubscription from '../types/pushchannelsubscription';\r\nimport BaseClient from './baseclient';\r\nimport Defaults from '../util/defaults';\r\n\r\nclass Push {\r\n  client: BaseClient;\r\n  admin: Admin;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.admin = new Admin(client);\r\n  }\r\n}\r\n\r\nclass Admin {\r\n  client: BaseClient;\r\n  deviceRegistrations: DeviceRegistrations;\r\n  channelSubscriptions: ChannelSubscriptions;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.deviceRegistrations = new DeviceRegistrations(client);\r\n    this.channelSubscriptions = new ChannelSubscriptions(client);\r\n  }\r\n\r\n  async publish(recipient: any, payload: any): Promise<void> {\r\n    const client = this.client;\r\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\r\n      params = {};\r\n    const body = Utils.mixin({ recipient: recipient }, payload);\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\r\n    await Resource.post(client, '/push/publish', requestBody, headers, params, null, true);\r\n  }\r\n}\r\n\r\nclass DeviceRegistrations {\r\n  client: BaseClient;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n  }\r\n\r\n  async save(device: any): Promise<DeviceDetails> {\r\n    const client = this.client;\r\n    const body = DeviceDetails.fromValues(device);\r\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\r\n      params = {};\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\r\n    const response = await Resource.put(\r\n      client,\r\n      '/push/deviceRegistrations/' + encodeURIComponent(device.id),\r\n      requestBody,\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return DeviceDetails.fromResponseBody(\r\n      response.body as Record<string, unknown>,\r\n      client._MsgPack,\r\n      response.unpacked ? undefined : format,\r\n    ) as DeviceDetails;\r\n  }\r\n\r\n  async get(deviceIdOrDetails: any): Promise<DeviceDetails> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format }),\r\n      deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\r\n\r\n    if (typeof deviceId !== 'string' || !deviceId.length) {\r\n      throw new ErrorInfo(\r\n        'First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails',\r\n        40000,\r\n        400,\r\n      );\r\n    }\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const response = await Resource.get(\r\n      client,\r\n      '/push/deviceRegistrations/' + encodeURIComponent(deviceId),\r\n      headers,\r\n      {},\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return DeviceDetails.fromResponseBody(\r\n      response.body as Record<string, unknown>,\r\n      client._MsgPack,\r\n      response.unpacked ? undefined : format,\r\n    ) as DeviceDetails;\r\n  }\r\n\r\n  async list(params: any): Promise<PaginatedResult<unknown>> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    return new PaginatedResource(client, '/push/deviceRegistrations', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return DeviceDetails.fromResponseBody(\r\n        body as Record<string, unknown>[],\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params);\r\n  }\r\n\r\n  async remove(deviceIdOrDetails: any): Promise<void> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format }),\r\n      params = {},\r\n      deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\r\n\r\n    if (typeof deviceId !== 'string' || !deviceId.length) {\r\n      throw new ErrorInfo(\r\n        'First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails',\r\n        40000,\r\n        400,\r\n      );\r\n    }\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    await Resource['delete'](\r\n      client,\r\n      '/push/deviceRegistrations/' + encodeURIComponent(deviceId),\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n  }\r\n\r\n  async removeWhere(params: any): Promise<void> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    await Resource['delete'](client, '/push/deviceRegistrations', headers, params, null, true);\r\n  }\r\n}\r\n\r\nclass ChannelSubscriptions {\r\n  client: BaseClient;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n  }\r\n\r\n  async save(subscription: Record<string, unknown>): Promise<PushChannelSubscription> {\r\n    const client = this.client;\r\n    const body = PushChannelSubscription.fromValues(subscription);\r\n    const format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format }),\r\n      params = {};\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    const requestBody = Utils.encodeBody(body, client._MsgPack, format);\r\n    const response = await Resource.post(\r\n      client,\r\n      '/push/channelSubscriptions',\r\n      requestBody,\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return PushChannelSubscription.fromResponseBody(\r\n      response.body as Record<string, any>,\r\n      client._MsgPack,\r\n      response.unpacked ? undefined : format,\r\n    ) as PushChannelSubscription;\r\n  }\r\n\r\n  async list(params: any): Promise<PaginatedResult<unknown>> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    return new PaginatedResource(client, '/push/channelSubscriptions', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return PushChannelSubscription.fromResponseBody(\r\n        body as Record<string, unknown>[],\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params);\r\n  }\r\n\r\n  async removeWhere(params: any): Promise<void> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    await Resource['delete'](client, '/push/channelSubscriptions', headers, params, null, true);\r\n  }\r\n\r\n  /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\r\n  remove = ChannelSubscriptions.prototype.removeWhere;\r\n\r\n  async listChannels(params: any): Promise<PaginatedResult<unknown>> {\r\n    const client = this.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    if (client.options.pushFullWait) Utils.mixin(params, { fullWait: 'true' });\r\n\r\n    return new PaginatedResource(client, '/push/channels', headers, envelope, async function (body, headers, unpacked) {\r\n      const parsedBody = (\r\n        !unpacked && format ? Utils.decodeBody(body, client._MsgPack, format) : body\r\n      ) as Array<string>;\r\n\r\n      for (let i = 0; i < parsedBody.length; i++) {\r\n        parsedBody[i] = String(parsedBody[i]);\r\n      }\r\n      return parsedBody;\r\n    }).get(params);\r\n  }\r\n}\r\n\r\nexport default Push;\r\n","import Platform from 'common/platform';\r\nimport Logger from '../util/logger';\r\nimport ErrorInfo from './errorinfo';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport PresenceMessage from './presencemessage';\r\nimport * as Utils from '../util/utils';\r\nimport { Bufferlike as BrowserBufferlike } from '../../../platform/web/lib/util/bufferutils';\r\nimport * as API from '../../../../ably';\r\nimport { IUntypedCryptoStatic } from 'common/types/ICryptoStatic';\r\nimport { MsgPack } from 'common/types/msgpack';\r\n\r\nexport type CipherOptions = {\r\n  channelCipher: {\r\n    encrypt: Function;\r\n    algorithm: 'aes';\r\n  };\r\n  cipher?: {\r\n    channelCipher: {\r\n      encrypt: Function;\r\n      algorithm: 'aes';\r\n    };\r\n  };\r\n};\r\n\r\nexport type EncodingDecodingContext = {\r\n  channelOptions: ChannelOptions;\r\n  plugins: {\r\n    vcdiff?: {\r\n      decode: (delta: Uint8Array, source: Uint8Array) => Uint8Array;\r\n    };\r\n  };\r\n  baseEncodedPreviousPayload?: Buffer | BrowserBufferlike;\r\n};\r\n\r\nfunction normaliseContext(context: CipherOptions | EncodingDecodingContext | ChannelOptions): EncodingDecodingContext {\r\n  if (!context || !(context as EncodingDecodingContext).channelOptions) {\r\n    return {\r\n      channelOptions: context as ChannelOptions,\r\n      plugins: {},\r\n      baseEncodedPreviousPayload: undefined,\r\n    };\r\n  }\r\n  return context as EncodingDecodingContext;\r\n}\r\n\r\nfunction normalizeCipherOptions(\r\n  Crypto: IUntypedCryptoStatic | null,\r\n  options: API.ChannelOptions | null,\r\n): ChannelOptions {\r\n  if (options && options.cipher) {\r\n    if (!Crypto) Utils.throwMissingPluginError('Crypto');\r\n    const cipher = Crypto.getCipher(options.cipher);\r\n    return {\r\n      cipher: cipher.cipherParams,\r\n      channelCipher: cipher.cipher,\r\n    };\r\n  }\r\n  return options ?? {};\r\n}\r\n\r\nfunction getMessageSize(msg: Message) {\r\n  let size = 0;\r\n  if (msg.name) {\r\n    size += msg.name.length;\r\n  }\r\n  if (msg.clientId) {\r\n    size += msg.clientId.length;\r\n  }\r\n  if (msg.extras) {\r\n    size += JSON.stringify(msg.extras).length;\r\n  }\r\n  if (msg.data) {\r\n    size += Utils.dataSizeBytes(msg.data);\r\n  }\r\n  return size;\r\n}\r\n\r\nexport async function fromEncoded(\r\n  Crypto: IUntypedCryptoStatic | null,\r\n  encoded: unknown,\r\n  inputOptions?: API.ChannelOptions,\r\n): Promise<Message> {\r\n  const msg = fromValues(encoded);\r\n  const options = normalizeCipherOptions(Crypto, inputOptions ?? null);\r\n  /* if decoding fails at any point, catch and return the message decoded to\r\n   * the fullest extent possible */\r\n  try {\r\n    await decode(msg, options);\r\n  } catch (e) {\r\n    Logger.logAction(Logger.LOG_ERROR, 'Message.fromEncoded()', (e as Error).toString());\r\n  }\r\n  return msg;\r\n}\r\n\r\nexport async function fromEncodedArray(\r\n  Crypto: IUntypedCryptoStatic | null,\r\n  encodedArray: Array<unknown>,\r\n  options?: API.ChannelOptions,\r\n): Promise<Message[]> {\r\n  return Promise.all(\r\n    encodedArray.map(function (encoded) {\r\n      return fromEncoded(Crypto, encoded, options);\r\n    }),\r\n  );\r\n}\r\n\r\nasync function encrypt<T extends Message | PresenceMessage>(msg: T, options: CipherOptions): Promise<T> {\r\n  let data = msg.data,\r\n    encoding = msg.encoding,\r\n    cipher = options.channelCipher;\r\n\r\n  encoding = encoding ? encoding + '/' : '';\r\n  if (!Platform.BufferUtils.isBuffer(data)) {\r\n    data = Platform.BufferUtils.utf8Encode(String(data));\r\n    encoding = encoding + 'utf-8/';\r\n  }\r\n  const ciphertext = await cipher.encrypt(data);\r\n  msg.data = ciphertext;\r\n  msg.encoding = encoding + 'cipher+' + cipher.algorithm;\r\n  return msg;\r\n}\r\n\r\nexport async function encode<T extends Message | PresenceMessage>(msg: T, options: CipherOptions): Promise<T> {\r\n  const data = msg.data;\r\n  const nativeDataType =\r\n    typeof data == 'string' || Platform.BufferUtils.isBuffer(data) || data === null || data === undefined;\r\n\r\n  if (!nativeDataType) {\r\n    if (Utils.isObject(data) || Array.isArray(data)) {\r\n      msg.data = JSON.stringify(data);\r\n      msg.encoding = msg.encoding ? msg.encoding + '/json' : 'json';\r\n    } else {\r\n      throw new ErrorInfo('Data type is unsupported', 40013, 400);\r\n    }\r\n  }\r\n\r\n  if (options != null && options.cipher) {\r\n    return encrypt(msg, options);\r\n  } else {\r\n    return msg;\r\n  }\r\n}\r\n\r\nexport async function encodeArray(messages: Array<Message>, options: CipherOptions): Promise<Array<Message>> {\r\n  return Promise.all(messages.map((message) => encode(message, options)));\r\n}\r\n\r\nexport const serialize = Utils.encodeBody;\r\n\r\nexport async function decode(\r\n  message: Message | PresenceMessage,\r\n  inputContext: CipherOptions | EncodingDecodingContext | ChannelOptions,\r\n): Promise<void> {\r\n  const context = normaliseContext(inputContext);\r\n\r\n  let lastPayload = message.data;\r\n  const encoding = message.encoding;\r\n  if (encoding) {\r\n    const xforms = encoding.split('/');\r\n    let lastProcessedEncodingIndex,\r\n      encodingsToProcess = xforms.length,\r\n      data = message.data;\r\n\r\n    let xform = '';\r\n    try {\r\n      while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\r\n        // eslint-disable-next-line security/detect-unsafe-regex\r\n        const match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\r\n        if (!match) break;\r\n        xform = match[1];\r\n        switch (xform) {\r\n          case 'base64':\r\n            data = Platform.BufferUtils.base64Decode(String(data));\r\n            if (lastProcessedEncodingIndex == xforms.length) {\r\n              lastPayload = data;\r\n            }\r\n            continue;\r\n          case 'utf-8':\r\n            data = Platform.BufferUtils.utf8Decode(data);\r\n            continue;\r\n          case 'json':\r\n            data = JSON.parse(data);\r\n            continue;\r\n          case 'cipher':\r\n            if (\r\n              context.channelOptions != null &&\r\n              context.channelOptions.cipher &&\r\n              context.channelOptions.channelCipher\r\n            ) {\r\n              const xformAlgorithm = match[3],\r\n                cipher = context.channelOptions.channelCipher;\r\n              /* don't attempt to decrypt unless the cipher params are compatible */\r\n              if (xformAlgorithm != cipher.algorithm) {\r\n                throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');\r\n              }\r\n              data = await cipher.decrypt(data);\r\n              continue;\r\n            } else {\r\n              throw new Error('Unable to decrypt message; not an encrypted channel');\r\n            }\r\n          case 'vcdiff':\r\n            if (!context.plugins || !context.plugins.vcdiff) {\r\n              throw new ErrorInfo('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);\r\n            }\r\n            if (typeof Uint8Array === 'undefined') {\r\n              throw new ErrorInfo(\r\n                'Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)',\r\n                40020,\r\n                400,\r\n              );\r\n            }\r\n            try {\r\n              let deltaBase = context.baseEncodedPreviousPayload;\r\n              if (typeof deltaBase === 'string') {\r\n                deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);\r\n              }\r\n\r\n              // vcdiff expects Uint8Arrays, can't copy with ArrayBuffers.\r\n              const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase as Buffer);\r\n              data = Platform.BufferUtils.toBuffer(data);\r\n\r\n              data = Platform.BufferUtils.arrayBufferViewToBuffer(context.plugins.vcdiff.decode(data, deltaBaseBuffer));\r\n              lastPayload = data;\r\n            } catch (e) {\r\n              throw new ErrorInfo('Vcdiff delta decode failed with ' + e, 40018, 400);\r\n            }\r\n            continue;\r\n          default:\r\n            throw new Error('Unknown encoding');\r\n        }\r\n      }\r\n    } catch (e) {\r\n      const err = e as ErrorInfo;\r\n      throw new ErrorInfo(\r\n        'Error processing the ' + xform + ' encoding, decoder returned â€˜' + err.message + 'â€™',\r\n        err.code || 40013,\r\n        400,\r\n      );\r\n    } finally {\r\n      message.encoding =\r\n        (lastProcessedEncodingIndex as number) <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');\r\n      message.data = data;\r\n    }\r\n  }\r\n  context.baseEncodedPreviousPayload = lastPayload;\r\n}\r\n\r\nexport async function fromResponseBody(\r\n  body: Array<Message>,\r\n  options: ChannelOptions | EncodingDecodingContext,\r\n  MsgPack: MsgPack | null,\r\n  format?: Utils.Format,\r\n): Promise<Message[]> {\r\n  if (format) {\r\n    body = Utils.decodeBody(body, MsgPack, format);\r\n  }\r\n\r\n  for (let i = 0; i < body.length; i++) {\r\n    const msg = (body[i] = fromValues(body[i]));\r\n    try {\r\n      await decode(msg, options);\r\n    } catch (e) {\r\n      Logger.logAction(Logger.LOG_ERROR, 'Message.fromResponseBody()', (e as Error).toString());\r\n    }\r\n  }\r\n  return body;\r\n}\r\n\r\nexport function fromValues(values: unknown): Message {\r\n  return Object.assign(new Message(), values);\r\n}\r\n\r\nexport function fromValuesArray(values: unknown[]): Message[] {\r\n  const count = values.length,\r\n    result = new Array(count);\r\n  for (let i = 0; i < count; i++) result[i] = fromValues(values[i]);\r\n  return result;\r\n}\r\n\r\n/* This should be called on encode()d (and encrypt()d) Messages (as it\r\n * assumes the data is a string or buffer) */\r\nexport function getMessagesSize(messages: Message[]): number {\r\n  let msg,\r\n    total = 0;\r\n  for (let i = 0; i < messages.length; i++) {\r\n    msg = messages[i];\r\n    total += msg.size || (msg.size = getMessageSize(msg));\r\n  }\r\n  return total;\r\n}\r\n\r\nclass Message {\r\n  name?: string;\r\n  id?: string;\r\n  timestamp?: number;\r\n  clientId?: string;\r\n  connectionId?: string;\r\n  connectionKey?: string;\r\n  data?: any;\r\n  encoding?: string | null;\r\n  extras?: any;\r\n  size?: number;\r\n\r\n  /**\r\n   * Overload toJSON() to intercept JSON.stringify()\r\n   * @return {*}\r\n   */\r\n  toJSON() {\r\n    /* encode data to base64 if present and we're returning real JSON;\r\n     * although msgpack calls toJSON(), we know it is a stringify()\r\n     * call if it has a non-empty arguments list */\r\n    let encoding = this.encoding;\r\n    let data = this.data;\r\n    if (data && Platform.BufferUtils.isBuffer(data)) {\r\n      if (arguments.length > 0) {\r\n        /* stringify call */\r\n        encoding = encoding ? encoding + '/base64' : 'base64';\r\n        data = Platform.BufferUtils.base64Encode(data);\r\n      } else {\r\n        /* Called by msgpack. toBuffer returns a datatype understandable by\r\n         * that platform's msgpack implementation (Buffer in node, Uint8Array\r\n         * in browsers) */\r\n        data = Platform.BufferUtils.toBuffer(data);\r\n      }\r\n    }\r\n    return {\r\n      name: this.name,\r\n      id: this.id,\r\n      clientId: this.clientId,\r\n      connectionId: this.connectionId,\r\n      connectionKey: this.connectionKey,\r\n      extras: this.extras,\r\n      encoding,\r\n      data,\r\n    };\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[Message';\r\n    if (this.name) result += '; name=' + this.name;\r\n    if (this.id) result += '; id=' + this.id;\r\n    if (this.timestamp) result += '; timestamp=' + this.timestamp;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    if (this.connectionId) result += '; connectionId=' + this.connectionId;\r\n    if (this.encoding) result += '; encoding=' + this.encoding;\r\n    if (this.extras) result += '; extras =' + JSON.stringify(this.extras);\r\n    if (this.data) {\r\n      if (typeof this.data == 'string') result += '; data=' + this.data;\r\n      else if (Platform.BufferUtils.isBuffer(this.data))\r\n        result += '; data (buffer)=' + Platform.BufferUtils.base64Encode(this.data);\r\n      else result += '; data (json)=' + JSON.stringify(this.data);\r\n    }\r\n    if (this.extras) result += '; extras=' + JSON.stringify(this.extras);\r\n    result += ']';\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default Message;\r\n","import Logger from '../util/logger';\r\nimport Platform from 'common/platform';\r\nimport { encode as encodeMessage, decode as decodeMessage, getMessagesSize, CipherOptions } from './message';\r\nimport * as Utils from '../util/utils';\r\nimport * as API from '../../../../ably';\r\nimport { MsgPack } from 'common/types/msgpack';\r\n\r\nconst actions = ['absent', 'present', 'enter', 'leave', 'update'];\r\n\r\nfunction toActionValue(actionString: string) {\r\n  return actions.indexOf(actionString);\r\n}\r\n\r\nexport async function fromEncoded(encoded: unknown, options?: API.ChannelOptions): Promise<PresenceMessage> {\r\n  const msg = fromValues(encoded as PresenceMessage | Record<string, unknown>, true);\r\n  /* if decoding fails at any point, catch and return the message decoded to\r\n   * the fullest extent possible */\r\n  try {\r\n    await decode(msg, options ?? {});\r\n  } catch (e) {\r\n    Logger.logAction(Logger.LOG_ERROR, 'PresenceMessage.fromEncoded()', (e as Error).toString());\r\n  }\r\n  return msg;\r\n}\r\n\r\nexport async function fromEncodedArray(\r\n  encodedArray: unknown[],\r\n  options?: API.ChannelOptions,\r\n): Promise<PresenceMessage[]> {\r\n  return Promise.all(\r\n    encodedArray.map(function (encoded) {\r\n      return fromEncoded(encoded, options);\r\n    }),\r\n  );\r\n}\r\n\r\nexport function fromValues(\r\n  values: PresenceMessage | Record<string, unknown>,\r\n  stringifyAction?: boolean,\r\n): PresenceMessage {\r\n  if (stringifyAction) {\r\n    values.action = actions[values.action as number];\r\n  }\r\n  return Object.assign(new PresenceMessage(), values);\r\n}\r\n\r\nexport { encodeMessage as encode };\r\nexport const decode = decodeMessage;\r\n\r\nexport async function fromResponseBody(\r\n  body: Record<string, unknown>[],\r\n  options: CipherOptions,\r\n  MsgPack: MsgPack | null,\r\n  format?: Utils.Format,\r\n): Promise<PresenceMessage[]> {\r\n  const messages: PresenceMessage[] = [];\r\n  if (format) {\r\n    body = Utils.decodeBody(body, MsgPack, format);\r\n  }\r\n\r\n  for (let i = 0; i < body.length; i++) {\r\n    const msg = (messages[i] = fromValues(body[i], true));\r\n    try {\r\n      await decode(msg, options);\r\n    } catch (e) {\r\n      Logger.logAction(Logger.LOG_ERROR, 'PresenceMessage.fromResponseBody()', (e as Error).toString());\r\n    }\r\n  }\r\n  return messages;\r\n}\r\n\r\nexport function fromValuesArray(values: unknown[]): PresenceMessage[] {\r\n  const count = values.length,\r\n    result = new Array(count);\r\n  for (let i = 0; i < count; i++) result[i] = fromValues(values[i] as Record<string, unknown>);\r\n  return result;\r\n}\r\n\r\nexport function fromData(data: unknown): PresenceMessage {\r\n  if (data instanceof PresenceMessage) {\r\n    return data;\r\n  }\r\n  return fromValues({\r\n    data,\r\n  });\r\n}\r\n\r\nexport { getMessagesSize };\r\n\r\nclass PresenceMessage {\r\n  action?: string | number;\r\n  id?: string;\r\n  timestamp?: number;\r\n  clientId?: string;\r\n  connectionId?: string;\r\n  data?: string | Buffer | Uint8Array;\r\n  encoding?: string;\r\n  extras?: any;\r\n  size?: number;\r\n\r\n  /* Returns whether this presenceMessage is synthesized, i.e. was not actually\r\n   * sent by the connection (usually means a leave event sent 15s after a\r\n   * disconnection). This is useful because synthesized messages cannot be\r\n   * compared for newness by id lexicographically - RTP2b1\r\n   */\r\n  isSynthesized(): boolean {\r\n    if (!this.id || !this.connectionId) {\r\n      return true;\r\n    }\r\n    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\r\n  }\r\n\r\n  /* RTP2b2 */\r\n  parseId(): { connectionId: string; msgSerial: number; index: number } {\r\n    if (!this.id) throw new Error('parseId(): Presence message does not contain an id');\r\n    const parts = this.id.split(':');\r\n    return {\r\n      connectionId: parts[0],\r\n      msgSerial: parseInt(parts[1], 10),\r\n      index: parseInt(parts[2], 10),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Overload toJSON() to intercept JSON.stringify()\r\n   * @return {*}\r\n   */\r\n  toJSON(): {\r\n    id?: string;\r\n    clientId?: string;\r\n    action: number;\r\n    data: string | Buffer | Uint8Array;\r\n    encoding?: string;\r\n    extras?: any;\r\n  } {\r\n    /* encode data to base64 if present and we're returning real JSON;\r\n     * although msgpack calls toJSON(), we know it is a stringify()\r\n     * call if it has a non-empty arguments list */\r\n    let data = this.data as string | Buffer | Uint8Array;\r\n    let encoding = this.encoding;\r\n    if (data && Platform.BufferUtils.isBuffer(data)) {\r\n      if (arguments.length > 0) {\r\n        /* stringify call */\r\n        encoding = encoding ? encoding + '/base64' : 'base64';\r\n        data = Platform.BufferUtils.base64Encode(data);\r\n      } else {\r\n        /* Called by msgpack. toBuffer returns a datatype understandable by\r\n         * that platform's msgpack implementation (Buffer in node, Uint8Array\r\n         * in browsers) */\r\n        data = Platform.BufferUtils.toBuffer(data);\r\n      }\r\n    }\r\n    return {\r\n      id: this.id,\r\n      clientId: this.clientId,\r\n      /* Convert presence action back to an int for sending to Ably */\r\n      action: toActionValue(this.action as string),\r\n      data: data,\r\n      encoding: encoding,\r\n      extras: this.extras,\r\n    };\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[PresenceMessage';\r\n    result += '; action=' + this.action;\r\n    if (this.id) result += '; id=' + this.id;\r\n    if (this.timestamp) result += '; timestamp=' + this.timestamp;\r\n    if (this.clientId) result += '; clientId=' + this.clientId;\r\n    if (this.connectionId) result += '; connectionId=' + this.connectionId;\r\n    if (this.encoding) result += '; encoding=' + this.encoding;\r\n    if (this.data) {\r\n      if (typeof this.data == 'string') result += '; data=' + this.data;\r\n      else if (Platform.BufferUtils.isBuffer(this.data))\r\n        result += '; data (buffer)=' + Platform.BufferUtils.base64Encode(this.data);\r\n      else result += '; data (json)=' + JSON.stringify(this.data);\r\n    }\r\n    if (this.extras) {\r\n      result += '; extras=' + JSON.stringify(this.extras);\r\n    }\r\n    result += ']';\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default PresenceMessage;\r\n","import * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport PresenceMessage, { fromResponseBody as presenceMessageFromResponseBody } from '../types/presencemessage';\r\nimport { CipherOptions } from '../types/message';\r\nimport RestChannel from './restchannel';\r\nimport Defaults from '../util/defaults';\r\n\r\nclass RestPresence {\r\n  channel: RestChannel;\r\n\r\n  constructor(channel: RestChannel) {\r\n    this.channel = channel;\r\n  }\r\n\r\n  async get(params: any): Promise<PaginatedResult<PresenceMessage>> {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RestPresence.get()', 'channel = ' + this.channel.name);\r\n    const client = this.channel.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.channel.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const options = this.channel.channelOptions;\r\n    return new PaginatedResource(\r\n      client,\r\n      this.channel.client.rest.presenceMixin.basePath(this),\r\n      headers,\r\n      envelope,\r\n      async function (body, headers, unpacked) {\r\n        return await presenceMessageFromResponseBody(\r\n          body as Record<string, unknown>[],\r\n          options as CipherOptions,\r\n          client._MsgPack,\r\n          unpacked ? undefined : format,\r\n        );\r\n      },\r\n    ).get(params);\r\n  }\r\n\r\n  async history(params: any): Promise<PaginatedResult<PresenceMessage>> {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RestPresence.history()', 'channel = ' + this.channel.name);\r\n    return this.channel.client.rest.presenceMixin.history(this, params);\r\n  }\r\n}\r\n\r\nexport default RestPresence;\r\n","import * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport RestPresence from './restpresence';\r\nimport Message, {\r\n  fromValues as messageFromValues,\r\n  fromValuesArray as messagesFromValuesArray,\r\n  encodeArray as encodeMessagesArray,\r\n  serialize as serializeMessage,\r\n  getMessagesSize,\r\n  CipherOptions,\r\n} from '../types/message';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport { PaginatedResult } from './paginatedresource';\r\nimport Resource from './resource';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport BaseRest from './baseclient';\r\nimport * as API from '../../../../ably';\r\nimport Defaults, { normaliseChannelOptions } from '../util/defaults';\r\nimport { RestHistoryParams } from './restchannelmixin';\r\nimport { RequestBody } from 'common/types/http';\r\n\r\nconst MSG_ID_ENTROPY_BYTES = 9;\r\n\r\nfunction allEmptyIds(messages: Array<Message>) {\r\n  return messages.every(function (message: Message) {\r\n    return !message.id;\r\n  });\r\n}\r\n\r\nclass RestChannel {\r\n  client: BaseRest;\r\n  name: string;\r\n  presence: RestPresence;\r\n  channelOptions: ChannelOptions;\r\n\r\n  constructor(client: BaseRest, name: string, channelOptions?: ChannelOptions) {\r\n    Logger.logAction(Logger.LOG_MINOR, 'RestChannel()', 'started; name = ' + name);\r\n    this.name = name;\r\n    this.client = client;\r\n    this.presence = new RestPresence(this);\r\n    this.channelOptions = normaliseChannelOptions(client._Crypto ?? null, channelOptions);\r\n  }\r\n\r\n  setOptions(options?: ChannelOptions): void {\r\n    this.channelOptions = normaliseChannelOptions(this.client._Crypto ?? null, options);\r\n  }\r\n\r\n  async history(params: RestHistoryParams | null): Promise<PaginatedResult<Message>> {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RestChannel.history()', 'channel = ' + this.name);\r\n    return this.client.rest.channelMixin.history(this, params);\r\n  }\r\n\r\n  async publish(...args: any[]): Promise<void> {\r\n    const first = args[0],\r\n      second = args[1];\r\n    let messages: Array<Message>;\r\n    let params: any;\r\n\r\n    if (typeof first === 'string' || first === null) {\r\n      /* (name, data, ...) */\r\n      messages = [messageFromValues({ name: first, data: second })];\r\n      params = args[2];\r\n    } else if (Utils.isObject(first)) {\r\n      messages = [messageFromValues(first)];\r\n      params = args[1];\r\n    } else if (Array.isArray(first)) {\r\n      messages = messagesFromValuesArray(first);\r\n      params = args[1];\r\n    } else {\r\n      throw new ErrorInfo(\r\n        'The single-argument form of publish() expects a message object or an array of message objects',\r\n        40013,\r\n        400,\r\n      );\r\n    }\r\n\r\n    if (!params) {\r\n      /* No params supplied */\r\n      params = {};\r\n    }\r\n\r\n    const client = this.client,\r\n      options = client.options,\r\n      format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      idempotentRestPublishing = client.options.idempotentRestPublishing,\r\n      headers = Defaults.defaultPostHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, options.headers);\r\n\r\n    if (idempotentRestPublishing && allEmptyIds(messages)) {\r\n      const msgIdBase = await Utils.randomString(MSG_ID_ENTROPY_BYTES);\r\n      messages.forEach(function (message, index) {\r\n        message.id = msgIdBase + ':' + index.toString();\r\n      });\r\n    }\r\n\r\n    await encodeMessagesArray(messages, this.channelOptions as CipherOptions);\r\n\r\n    /* RSL1i */\r\n    const size = getMessagesSize(messages),\r\n      maxMessageSize = options.maxMessageSize;\r\n    if (size > maxMessageSize) {\r\n      throw new ErrorInfo(\r\n        'Maximum size of messages that can be published at once exceeded ( was ' +\r\n          size +\r\n          ' bytes; limit is ' +\r\n          maxMessageSize +\r\n          ' bytes)',\r\n        40009,\r\n        400,\r\n      );\r\n    }\r\n\r\n    await this._publish(serializeMessage(messages, client._MsgPack, format), headers, params);\r\n  }\r\n\r\n  async _publish(requestBody: RequestBody | null, headers: Record<string, string>, params: any): Promise<void> {\r\n    await Resource.post(\r\n      this.client,\r\n      this.client.rest.channelMixin.basePath(this) + '/messages',\r\n      requestBody,\r\n      headers,\r\n      params,\r\n      null,\r\n      true,\r\n    );\r\n  }\r\n\r\n  async status(): Promise<API.ChannelDetails> {\r\n    return this.client.rest.channelMixin.status(this);\r\n  }\r\n}\r\n\r\nexport default RestChannel;\r\n","type StatsValues = {\r\n  entries?: Partial<Record<string, number>>;\r\n  schema?: string;\r\n  appId?: string;\r\n  inProgress?: never;\r\n  unit?: never;\r\n  intervalId?: never;\r\n};\r\n\r\nclass Stats {\r\n  entries?: Partial<Record<string, number>>;\r\n  schema?: string;\r\n  appId?: string;\r\n  inProgress?: never;\r\n  unit?: never;\r\n  intervalId?: never;\r\n\r\n  constructor(values?: StatsValues) {\r\n    this.entries = (values && values.entries) || undefined;\r\n    this.schema = (values && values.schema) || undefined;\r\n    this.appId = (values && values.appId) || undefined;\r\n    this.inProgress = (values && values.inProgress) || undefined;\r\n    this.unit = (values && values.unit) || undefined;\r\n    this.intervalId = (values && values.intervalId) || undefined;\r\n  }\r\n\r\n  static fromValues(values: StatsValues): Stats {\r\n    return new Stats(values);\r\n  }\r\n}\r\n\r\nexport default Stats;\r\n","import * as API from '../../../../ably';\r\nimport RestChannel from './restchannel';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport * as Utils from '../util/utils';\r\nimport Message, { fromResponseBody as messageFromResponseBody } from '../types/message';\r\nimport Defaults from '../util/defaults';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport Resource from './resource';\r\n\r\nexport interface RestHistoryParams {\r\n  start?: number;\r\n  end?: number;\r\n  direction?: string;\r\n  limit?: number;\r\n}\r\n\r\nexport class RestChannelMixin {\r\n  static basePath(channel: RestChannel | RealtimeChannel) {\r\n    return '/channels/' + encodeURIComponent(channel.name);\r\n  }\r\n\r\n  static history(\r\n    channel: RestChannel | RealtimeChannel,\r\n    params: RestHistoryParams | null,\r\n  ): Promise<PaginatedResult<Message>> {\r\n    const client = channel.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = channel.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const options = channel.channelOptions;\r\n    return new PaginatedResource(client, this.basePath(channel) + '/messages', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return await messageFromResponseBody(body as Message[], options, client._MsgPack, unpacked ? undefined : format);\r\n    }).get(params as Record<string, unknown>);\r\n  }\r\n\r\n  static async status(channel: RestChannel | RealtimeChannel): Promise<API.ChannelDetails> {\r\n    const format = channel.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;\r\n    const headers = Defaults.defaultPostHeaders(channel.client.options, { format });\r\n\r\n    const response = await Resource.get<API.ChannelDetails>(\r\n      channel.client,\r\n      this.basePath(channel),\r\n      headers,\r\n      {},\r\n      format,\r\n      true,\r\n    );\r\n\r\n    return response.body!;\r\n  }\r\n}\r\n","import RestPresence from './restpresence';\r\nimport RealtimePresence from './realtimepresence';\r\nimport * as Utils from '../util/utils';\r\nimport Defaults from '../util/defaults';\r\nimport PaginatedResource, { PaginatedResult } from './paginatedresource';\r\nimport PresenceMessage, { fromResponseBody as presenceMessageFromResponseBody } from '../types/presencemessage';\r\nimport { CipherOptions } from '../types/message';\r\nimport { RestChannelMixin } from './restchannelmixin';\r\n\r\nexport class RestPresenceMixin {\r\n  static basePath(presence: RestPresence | RealtimePresence) {\r\n    return RestChannelMixin.basePath(presence.channel) + '/presence';\r\n  }\r\n\r\n  static async history(\r\n    presence: RestPresence | RealtimePresence,\r\n    params: any,\r\n  ): Promise<PaginatedResult<PresenceMessage>> {\r\n    const client = presence.channel.client,\r\n      format = client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = presence.channel.client.http.supportsLinkHeaders ? undefined : format,\r\n      headers = Defaults.defaultGetHeaders(client.options, { format });\r\n\r\n    Utils.mixin(headers, client.options.headers);\r\n\r\n    const options = presence.channel.channelOptions;\r\n    return new PaginatedResource(client, this.basePath(presence) + '/history', headers, envelope, async function (\r\n      body,\r\n      headers,\r\n      unpacked,\r\n    ) {\r\n      return await presenceMessageFromResponseBody(\r\n        body as Record<string, unknown>[],\r\n        options as CipherOptions,\r\n        client._MsgPack,\r\n        unpacked ? undefined : format,\r\n      );\r\n    }).get(params);\r\n  }\r\n}\r\n","import * as Utils from '../util/utils';\r\nimport Logger, { LoggerOptions } from '../util/logger';\r\nimport Defaults from '../util/defaults';\r\nimport Push from './push';\r\nimport PaginatedResource, { HttpPaginatedResponse, PaginatedResult } from './paginatedresource';\r\nimport RestChannel from './restchannel';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Stats from '../types/stats';\r\nimport HttpMethods from '../../constants/HttpMethods';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport { RequestBody, RequestParams } from '../../types/http';\r\nimport * as API from '../../../../ably';\r\nimport Resource from './resource';\r\n\r\nimport Platform from '../../platform';\r\nimport BaseClient from './baseclient';\r\nimport { useTokenAuth } from './auth';\r\nimport { RestChannelMixin } from './restchannelmixin';\r\nimport { RestPresenceMixin } from './restpresencemixin';\r\n\r\ntype BatchResult<T> = API.BatchResult<T>;\r\n\r\ntype BatchPublishSpec = API.BatchPublishSpec;\r\ntype BatchPublishSuccessResult = API.BatchPublishSuccessResult;\r\ntype BatchPublishFailureResult = API.BatchPublishFailureResult;\r\ntype BatchPublishResult = BatchResult<BatchPublishSuccessResult | BatchPublishFailureResult>;\r\ntype BatchPresenceSuccessResult = API.BatchPresenceSuccessResult;\r\ntype BatchPresenceFailureResult = API.BatchPresenceFailureResult;\r\ntype BatchPresenceResult = BatchResult<BatchPresenceSuccessResult | BatchPresenceFailureResult>;\r\n\r\ntype TokenRevocationTargetSpecifier = API.TokenRevocationTargetSpecifier;\r\ntype TokenRevocationOptions = API.TokenRevocationOptions;\r\ntype TokenRevocationSuccessResult = API.TokenRevocationSuccessResult;\r\ntype TokenRevocationFailureResult = API.TokenRevocationFailureResult;\r\ntype TokenRevocationResult = BatchResult<TokenRevocationSuccessResult | TokenRevocationFailureResult>;\r\n\r\nexport class Rest {\r\n  private readonly client: BaseClient;\r\n  readonly channels: Channels;\r\n  readonly push: Push;\r\n\r\n  readonly channelMixin = RestChannelMixin;\r\n  readonly presenceMixin = RestPresenceMixin;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.channels = new Channels(this.client);\r\n    this.push = new Push(this.client);\r\n  }\r\n\r\n  async stats(params: RequestParams): Promise<PaginatedResult<Stats>> {\r\n    const headers = Defaults.defaultGetHeaders(this.client.options),\r\n      format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      envelope = this.client.http.supportsLinkHeaders ? undefined : format;\r\n\r\n    Utils.mixin(headers, this.client.options.headers);\r\n\r\n    return new PaginatedResource(this.client, '/stats', headers, envelope, function (body, headers, unpacked) {\r\n      const statsValues = unpacked ? body : JSON.parse(body as string);\r\n      for (let i = 0; i < statsValues.length; i++) statsValues[i] = Stats.fromValues(statsValues[i]);\r\n      return statsValues;\r\n    }).get(params as Record<string, string>);\r\n  }\r\n\r\n  async time(params?: RequestParams): Promise<number> {\r\n    const headers = Defaults.defaultGetHeaders(this.client.options);\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n    const timeUri = (host: string) => {\r\n      return this.client.baseUri(host) + '/time';\r\n    };\r\n\r\n    let { error, body, unpacked } = await this.client.http.do(\r\n      HttpMethods.Get,\r\n      timeUri,\r\n      headers,\r\n      null,\r\n      params as RequestParams,\r\n    );\r\n\r\n    if (error) {\r\n      throw error;\r\n    }\r\n    if (!unpacked) body = JSON.parse(body as string);\r\n    const time = (body as number[])[0];\r\n    if (!time) {\r\n      throw new ErrorInfo('Internal error (unexpected result type from GET /time)', 50000, 500);\r\n    }\r\n    /* calculate time offset only once for this device by adding to the prototype */\r\n    this.client.serverTimeOffset = time - Date.now();\r\n    return time;\r\n  }\r\n\r\n  async request(\r\n    method: string,\r\n    path: string,\r\n    version: number,\r\n    params: RequestParams,\r\n    body: unknown,\r\n    customHeaders: Record<string, string>,\r\n  ): Promise<HttpPaginatedResponse<unknown>> {\r\n    const [encoder, decoder, format] = (() => {\r\n      if (this.client.options.useBinaryProtocol) {\r\n        if (!this.client._MsgPack) {\r\n          Utils.throwMissingPluginError('MsgPack');\r\n        }\r\n        return [this.client._MsgPack.encode, this.client._MsgPack.decode, Utils.Format.msgpack];\r\n      } else {\r\n        return [JSON.stringify, JSON.parse, Utils.Format.json];\r\n      }\r\n    })();\r\n    const envelope = this.client.http.supportsLinkHeaders ? undefined : format;\r\n    params = params || {};\r\n    const _method = method.toLowerCase() as HttpMethods;\r\n    const headers =\r\n      _method == 'get'\r\n        ? Defaults.defaultGetHeaders(this.client.options, { format, protocolVersion: version })\r\n        : Defaults.defaultPostHeaders(this.client.options, { format, protocolVersion: version });\r\n\r\n    if (typeof body !== 'string') {\r\n      body = encoder(body) ?? null;\r\n    }\r\n    Utils.mixin(headers, this.client.options.headers);\r\n    if (customHeaders) {\r\n      Utils.mixin(headers, customHeaders);\r\n    }\r\n    const paginatedResource = new PaginatedResource(\r\n      this.client,\r\n      path,\r\n      headers,\r\n      envelope,\r\n      async function (resbody, headers, unpacked) {\r\n        return Utils.ensureArray(unpacked ? resbody : decoder(resbody as string & Buffer));\r\n      },\r\n      /* useHttpPaginatedResponse: */ true,\r\n    );\r\n\r\n    if (!Platform.Http.methods.includes(_method)) {\r\n      throw new ErrorInfo('Unsupported method ' + _method, 40500, 405);\r\n    }\r\n\r\n    if (Platform.Http.methodsWithBody.includes(_method)) {\r\n      return paginatedResource[_method as HttpMethods.Post](params, body as RequestBody) as Promise<\r\n        HttpPaginatedResponse<unknown>\r\n      >;\r\n    } else {\r\n      return paginatedResource[_method as HttpMethods.Get | HttpMethods.Delete](params) as Promise<\r\n        HttpPaginatedResponse<unknown>\r\n      >;\r\n    }\r\n  }\r\n\r\n  async batchPublish<T extends BatchPublishSpec | BatchPublishSpec[]>(\r\n    specOrSpecs: T,\r\n  ): Promise<T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[]> {\r\n    let requestBodyDTO: BatchPublishSpec[];\r\n    let singleSpecMode: boolean;\r\n    if (Array.isArray(specOrSpecs)) {\r\n      requestBodyDTO = specOrSpecs;\r\n      singleSpecMode = false;\r\n    } else {\r\n      requestBodyDTO = [specOrSpecs];\r\n      singleSpecMode = true;\r\n    }\r\n\r\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\r\n\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n\r\n    const requestBody = Utils.encodeBody(requestBodyDTO, this.client._MsgPack, format);\r\n\r\n    const response = await Resource.post(this.client, '/messages', requestBody, headers, {}, null, true);\r\n\r\n    const batchResults = (\r\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\r\n    ) as BatchPublishResult[];\r\n\r\n    // I don't love the below type assertions but not sure how to avoid them\r\n    if (singleSpecMode) {\r\n      return batchResults[0] as T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[];\r\n    } else {\r\n      return batchResults as T extends BatchPublishSpec ? BatchPublishResult : BatchPublishResult[];\r\n    }\r\n  }\r\n\r\n  async batchPresence(channels: string[]): Promise<BatchPresenceResult> {\r\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\r\n\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n\r\n    const channelsParam = channels.join(',');\r\n\r\n    const response = await Resource.get(this.client, '/presence', headers, { channels: channelsParam }, null, true);\r\n\r\n    return (\r\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\r\n    ) as BatchPresenceResult;\r\n  }\r\n\r\n  async revokeTokens(\r\n    specifiers: TokenRevocationTargetSpecifier[],\r\n    options?: TokenRevocationOptions,\r\n  ): Promise<TokenRevocationResult> {\r\n    if (useTokenAuth(this.client.options)) {\r\n      throw new ErrorInfo('Cannot revoke tokens when using token auth', 40162, 401);\r\n    }\r\n\r\n    const keyName = this.client.options.keyName!;\r\n\r\n    let resolvedOptions = options ?? {};\r\n\r\n    const requestBodyDTO = {\r\n      targets: specifiers.map((specifier) => `${specifier.type}:${specifier.value}`),\r\n      ...resolvedOptions,\r\n    };\r\n\r\n    const format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json,\r\n      headers = Defaults.defaultPostHeaders(this.client.options, { format });\r\n\r\n    if (this.client.options.headers) Utils.mixin(headers, this.client.options.headers);\r\n\r\n    const requestBody = Utils.encodeBody(requestBodyDTO, this.client._MsgPack, format);\r\n\r\n    const response = await Resource.post(\r\n      this.client,\r\n      `/keys/${keyName}/revokeTokens`,\r\n      requestBody,\r\n      headers,\r\n      {},\r\n      null,\r\n      true,\r\n    );\r\n\r\n    return (\r\n      response.unpacked ? response.body : Utils.decodeBody(response.body, this.client._MsgPack, format)\r\n    ) as TokenRevocationResult;\r\n  }\r\n\r\n  setLog(logOptions: LoggerOptions): void {\r\n    Logger.setLog(logOptions.level, logOptions.handler);\r\n  }\r\n}\r\n\r\nclass Channels {\r\n  client: BaseClient;\r\n  all: Record<string, RestChannel>;\r\n\r\n  constructor(client: BaseClient) {\r\n    this.client = client;\r\n    this.all = Object.create(null);\r\n  }\r\n\r\n  get(name: string, channelOptions?: ChannelOptions) {\r\n    name = String(name);\r\n    let channel = this.all[name];\r\n    if (!channel) {\r\n      this.all[name] = channel = new RestChannel(this.client, name, channelOptions);\r\n    } else if (channelOptions) {\r\n      channel.setOptions(channelOptions);\r\n    }\r\n\r\n    return channel;\r\n  }\r\n\r\n  /* Included to support certain niche use-cases; most users should ignore this.\r\n   * Please do not use this unless you know what you're doing */\r\n  release(name: string) {\r\n    delete this.all[String(name)];\r\n  }\r\n}\r\n","import BaseClient from './baseclient';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport { Rest } from './rest';\r\nimport Defaults from '../util/defaults';\r\n\r\n/**\r\n `BaseRest` is an export of the tree-shakable version of the SDK, and acts as the base class for the `DefaultRest` class exported by the non tree-shakable version.\r\n\r\n It always includes the `Rest` plugin.\r\n */\r\nexport class BaseRest extends BaseClient {\r\n  /*\r\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\r\n   *\r\n   * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\r\n   * 2. passes no argument at all\r\n   *\r\n   * tell the compiler that these cases are possible so that it forces us to handle them.\r\n   */\r\n  constructor(options?: ClientOptions | string) {\r\n    super(Defaults.objectifyOptions(options, false, 'BaseRest', { Rest }));\r\n  }\r\n}\r\n","import { Rest } from './rest';\r\nimport { IUntypedCryptoStatic } from '../../types/ICryptoStatic';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport RealtimePresence from './realtimepresence';\r\nimport XHRRequest from 'platform/web/lib/http/request/xhrrequest';\r\nimport fetchRequest from 'platform/web/lib/http/request/fetchrequest';\r\nimport { FilteredSubscriptions } from './filteredsubscriptions';\r\nimport {\r\n  fromValues as presenceMessageFromValues,\r\n  fromValuesArray as presenceMessagesFromValuesArray,\r\n} from '../types/presencemessage';\r\nimport { TransportCtor } from '../transport/transport';\r\n\r\nexport interface PresenceMessagePlugin {\r\n  presenceMessageFromValues: typeof presenceMessageFromValues;\r\n  presenceMessagesFromValuesArray: typeof presenceMessagesFromValuesArray;\r\n}\r\n\r\nexport type RealtimePresencePlugin = PresenceMessagePlugin & {\r\n  RealtimePresence: typeof RealtimePresence;\r\n};\r\n\r\nexport interface ModularPlugins {\r\n  Rest?: typeof Rest;\r\n  Crypto?: IUntypedCryptoStatic;\r\n  MsgPack?: MsgPack;\r\n  RealtimePresence?: RealtimePresencePlugin;\r\n  WebSocketTransport?: TransportCtor;\r\n  XHRPolling?: TransportCtor;\r\n  XHRRequest?: typeof XHRRequest;\r\n  FetchRequest?: typeof fetchRequest;\r\n  MessageInteractions?: typeof FilteredSubscriptions;\r\n}\r\n\r\nexport const allCommonModularPlugins: ModularPlugins = { Rest };\r\n","import Message, {\r\n  CipherOptions,\r\n  fromEncoded,\r\n  fromEncodedArray,\r\n  encode,\r\n  decode,\r\n  EncodingDecodingContext,\r\n} from './message';\r\nimport * as API from '../../../../ably';\r\nimport Platform from 'common/platform';\r\nimport PresenceMessage from './presencemessage';\r\nimport { ChannelOptions } from 'common/types/channel';\r\n\r\n/**\r\n `DefaultMessage` is the class returned by `DefaultRest` and `DefaultRealtime`â€™s `Message` static property. It introduces the static methods described in the `MessageStatic` interface of the public API of the non tree-shakable version of the library.\r\n */\r\nexport class DefaultMessage extends Message {\r\n  static async fromEncoded(encoded: unknown, inputOptions?: API.ChannelOptions): Promise<Message> {\r\n    return fromEncoded(Platform.Crypto, encoded, inputOptions);\r\n  }\r\n\r\n  static async fromEncodedArray(encodedArray: Array<unknown>, options?: API.ChannelOptions): Promise<Message[]> {\r\n    return fromEncodedArray(Platform.Crypto, encodedArray, options);\r\n  }\r\n\r\n  // Used by tests\r\n  static fromValues(values: unknown): Message {\r\n    return Object.assign(new Message(), values);\r\n  }\r\n\r\n  // Used by tests\r\n  static async encode<T extends Message | PresenceMessage>(msg: T, options: CipherOptions): Promise<T> {\r\n    return encode(msg, options);\r\n  }\r\n\r\n  // Used by tests\r\n  static async decode(\r\n    message: Message | PresenceMessage,\r\n    inputContext: CipherOptions | EncodingDecodingContext | ChannelOptions,\r\n  ): Promise<void> {\r\n    return decode(message, inputContext);\r\n  }\r\n}\r\n","import * as API from '../../../../ably';\r\nimport PresenceMessage, { fromEncoded, fromEncodedArray, fromValues } from './presencemessage';\r\n\r\n/**\r\n `DefaultPresenceMessage` is the class returned by `DefaultRest` and `DefaultRealtime`â€™s `PresenceMessage` static property. It introduces the static methods described in the `PresenceMessageStatic` interface of the public API of the non tree-shakable version of the library.\r\n */\r\nexport class DefaultPresenceMessage extends PresenceMessage {\r\n  static async fromEncoded(encoded: unknown, inputOptions?: API.ChannelOptions): Promise<PresenceMessage> {\r\n    return fromEncoded(encoded, inputOptions);\r\n  }\r\n\r\n  static async fromEncodedArray(\r\n    encodedArray: Array<unknown>,\r\n    options?: API.ChannelOptions,\r\n  ): Promise<PresenceMessage[]> {\r\n    return fromEncodedArray(encodedArray, options);\r\n  }\r\n\r\n  static fromValues(values: PresenceMessage | Record<string, unknown>, stringifyAction?: boolean): PresenceMessage {\r\n    return fromValues(values, stringifyAction);\r\n  }\r\n}\r\n","import { BaseRest } from './baserest';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport { allCommonModularPlugins } from './modularplugins';\r\nimport Platform from 'common/platform';\r\nimport { DefaultMessage } from '../types/defaultmessage';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport { DefaultPresenceMessage } from '../types/defaultpresencemessage';\r\nimport { Http } from 'common/types/http';\r\nimport Defaults from '../util/defaults';\r\n\r\n/**\r\n `DefaultRest` is the class that the non tree-shakable version of the SDK exports as `Rest`. It ensures that this version of the SDK includes all of the functionality which is optionally available in the tree-shakable version.\r\n */\r\nexport class DefaultRest extends BaseRest {\r\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\r\n  constructor(options?: ClientOptions | string) {\r\n    const MsgPack = DefaultRest._MsgPack;\r\n    if (!MsgPack) {\r\n      throw new Error('Expected DefaultRest._MsgPack to have been set');\r\n    }\r\n\r\n    super(\r\n      Defaults.objectifyOptions(options, true, 'Rest', {\r\n        ...allCommonModularPlugins,\r\n        Crypto: DefaultRest.Crypto ?? undefined,\r\n        MsgPack: DefaultRest._MsgPack ?? undefined,\r\n      }),\r\n    );\r\n  }\r\n\r\n  private static _Crypto: typeof Platform.Crypto = null;\r\n  static get Crypto() {\r\n    if (this._Crypto === null) {\r\n      throw new Error('Encryption not enabled; use ably.encryption.js instead');\r\n    }\r\n\r\n    return this._Crypto;\r\n  }\r\n  static set Crypto(newValue: typeof Platform.Crypto) {\r\n    this._Crypto = newValue;\r\n  }\r\n\r\n  static Message = DefaultMessage;\r\n  static PresenceMessage = DefaultPresenceMessage;\r\n\r\n  static _MsgPack: MsgPack | null = null;\r\n\r\n  // Used by tests\r\n  static _Http = Http;\r\n}\r\n","import * as Utils from './utils';\r\nimport Logger from './logger';\r\nimport Platform from 'common/platform';\r\n\r\n/* Call the listener, catch any exceptions and log, but continue operation*/\r\nfunction callListener(eventThis: { event: string }, listener: Function, args: unknown[]) {\r\n  try {\r\n    listener.apply(eventThis, args);\r\n  } catch (e) {\r\n    Logger.logAction(\r\n      Logger.LOG_ERROR,\r\n      'EventEmitter.emit()',\r\n      'Unexpected listener exception: ' + e + '; stack = ' + (e && (e as Error).stack),\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Remove listeners that match listener\r\n * @param targetListeners is an array of listener arrays or event objects with arrays of listeners\r\n * @param listener the listener callback to remove\r\n * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event\r\n */\r\nfunction removeListener(targetListeners: any, listener: Function, eventFilter?: string) {\r\n  let listeners: Record<string, unknown>;\r\n  let index;\r\n  let eventName;\r\n\r\n  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\r\n    listeners = targetListeners[targetListenersIndex];\r\n    if (eventFilter) {\r\n      listeners = listeners[eventFilter] as Record<string, unknown>;\r\n    }\r\n\r\n    if (Array.isArray(listeners)) {\r\n      while ((index = listeners.indexOf(listener)) !== -1) {\r\n        listeners.splice(index, 1);\r\n      }\r\n      /* If events object has an event name key with no listeners then\r\n\t\t\t\t\tremove the key to stop the list growing indefinitely */\r\n      if (eventFilter && listeners.length === 0) {\r\n        delete targetListeners[targetListenersIndex][eventFilter];\r\n      }\r\n    } else if (Utils.isObject(listeners)) {\r\n      /* events */\r\n      for (eventName in listeners) {\r\n        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Array.isArray(listeners[eventName])) {\r\n          removeListener([listeners], listener, eventName);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass EventEmitter {\r\n  any: Array<Function>;\r\n  events: Record<string, Array<Function>>;\r\n  anyOnce: Array<Function>;\r\n  eventsOnce: Record<string, Array<Function>>;\r\n\r\n  constructor() {\r\n    this.any = [];\r\n    this.events = Object.create(null);\r\n    this.anyOnce = [];\r\n    this.eventsOnce = Object.create(null);\r\n  }\r\n\r\n  /**\r\n   * Add an event listener\r\n   * @param listener the listener to be called\r\n   */\r\n  on(listener: Function): void;\r\n\r\n  /**\r\n   * Add an event listener\r\n   * @param event (optional) the name of the event to listen to\r\n   * @param listener the listener to be called\r\n   */\r\n  on(event: null | string | string[], listener: Function): void;\r\n\r\n  on(...args: unknown[]) {\r\n    if (args.length === 1) {\r\n      const listener = args[0];\r\n      if (typeof listener === 'function') {\r\n        this.any.push(listener);\r\n      } else {\r\n        throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\r\n      }\r\n    }\r\n    if (args.length === 2) {\r\n      const [event, listener] = args;\r\n      if (typeof listener !== 'function') {\r\n        throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\r\n      }\r\n      if (Utils.isNil(event)) {\r\n        this.any.push(listener);\r\n      } else if (Array.isArray(event)) {\r\n        event.forEach((eventName) => {\r\n          this.on(eventName, listener);\r\n        });\r\n      } else {\r\n        if (typeof event !== 'string') {\r\n          throw new Error('EventListener.on(): Invalid arguments: ' + Platform.Config.inspect(args));\r\n        }\r\n        const listeners = this.events[event] || (this.events[event] = []);\r\n        listeners.push(listener);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove one or more event listeners\r\n   * @param listener (optional) the listener to remove. If not\r\n   *        supplied, all listeners are removed.\r\n   */\r\n  off(listener?: Function): void;\r\n\r\n  /**\r\n   * Remove one or more event listeners\r\n   * @param event (optional) the name of the event whose listener\r\n   *        is to be removed. If not supplied, the listener is\r\n   *        treated as an 'any' listener\r\n   * @param listener (optional) the listener to remove. If not\r\n   *        supplied, all listeners are removed.\r\n   */\r\n  off(event: string | string[] | null, listener?: Function | null): void;\r\n\r\n  off(...args: unknown[]) {\r\n    if (args.length == 0 || (Utils.isNil(args[0]) && Utils.isNil(args[1]))) {\r\n      this.any = [];\r\n      this.events = Object.create(null);\r\n      this.anyOnce = [];\r\n      this.eventsOnce = Object.create(null);\r\n      return;\r\n    }\r\n    const [firstArg, secondArg] = args;\r\n    let listener: Function | null = null;\r\n    let event: unknown = null;\r\n    if (args.length === 1 || !secondArg) {\r\n      if (typeof firstArg === 'function') {\r\n        /* we take this to be the listener and treat the event as \"any\" .. */\r\n        listener = firstArg;\r\n      } else {\r\n        event = firstArg;\r\n      }\r\n      /* ... or we take event to be the actual event name and listener to be all */\r\n    } else {\r\n      if (typeof secondArg !== 'function') {\r\n        throw new Error('EventEmitter.off(): invalid arguments:' + Platform.Config.inspect(args));\r\n      }\r\n      [event, listener] = [firstArg, secondArg];\r\n    }\r\n\r\n    if (listener && Utils.isNil(event)) {\r\n      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\r\n      return;\r\n    }\r\n\r\n    if (Array.isArray(event)) {\r\n      event.forEach((eventName) => {\r\n        this.off(eventName, listener);\r\n      });\r\n      return;\r\n    }\r\n\r\n    /* \"normal\" case where event is an actual event */\r\n    if (typeof event !== 'string') {\r\n      throw new Error('EventEmitter.off(): invalid arguments:' + Platform.Config.inspect(args));\r\n    }\r\n    if (listener) {\r\n      removeListener([this.events, this.eventsOnce], listener, event);\r\n    } else {\r\n      delete this.events[event];\r\n      delete this.eventsOnce[event];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the array of listeners for a given event; excludes once events\r\n   * @param event (optional) the name of the event, or none for 'any'\r\n   * @return array of events, or null if none\r\n   */\r\n  listeners(event: string) {\r\n    if (event) {\r\n      const listeners = this.events[event] || [];\r\n      if (this.eventsOnce[event]) Array.prototype.push.apply(listeners, this.eventsOnce[event]);\r\n      return listeners.length ? listeners : null;\r\n    }\r\n    return this.any.length ? this.any : null;\r\n  }\r\n\r\n  /**\r\n   * Emit an event\r\n   * @param event the event name\r\n   * @param args the arguments to pass to the listener\r\n   */\r\n  emit(event: string, ...args: unknown[] /* , args... */) {\r\n    const eventThis = { event };\r\n    const listeners: Function[] = [];\r\n\r\n    if (this.anyOnce.length) {\r\n      Array.prototype.push.apply(listeners, this.anyOnce);\r\n      this.anyOnce = [];\r\n    }\r\n    if (this.any.length) {\r\n      Array.prototype.push.apply(listeners, this.any);\r\n    }\r\n    const eventsOnceListeners = this.eventsOnce[event];\r\n    if (eventsOnceListeners) {\r\n      Array.prototype.push.apply(listeners, eventsOnceListeners);\r\n      delete this.eventsOnce[event];\r\n    }\r\n    const eventsListeners = this.events[event];\r\n    if (eventsListeners) {\r\n      Array.prototype.push.apply(listeners, eventsListeners);\r\n    }\r\n\r\n    listeners.forEach(function (listener) {\r\n      callListener(eventThis, listener, args);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Listen for a single occurrence of an event\r\n   * @param event the name of the event to listen to\r\n   */\r\n  once(event: string): Promise<void>;\r\n\r\n  /**\r\n   * Listen for a single occurrence of any event\r\n   * @param listener the listener to be called\r\n   */\r\n  once(listener: Function): void;\r\n\r\n  /**\r\n   * Listen for a single occurrence of an event\r\n   * @param event the name of the event to listen to\r\n   * @param listener the listener to be called\r\n   */\r\n  once(event?: string | string[] | null, listener?: Function): void;\r\n\r\n  once(...args: unknown[]): void | Promise<void> {\r\n    const argCount = args.length;\r\n    if (argCount === 0 || (argCount === 1 && typeof args[0] !== 'function')) {\r\n      const event = args[0];\r\n      return new Promise((resolve) => {\r\n        this.once(event as string | string[] | null, resolve);\r\n      });\r\n    }\r\n\r\n    const [firstArg, secondArg] = args;\r\n    if (args.length === 1 && typeof firstArg === 'function') {\r\n      this.anyOnce.push(firstArg);\r\n    } else if (Utils.isNil(firstArg)) {\r\n      if (typeof secondArg !== 'function') {\r\n        throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n      }\r\n      this.anyOnce.push(secondArg);\r\n    } else if (Array.isArray(firstArg)) {\r\n      const self = this;\r\n      const listenerWrapper = function (this: any) {\r\n        const innerArgs = Array.prototype.slice.call(arguments);\r\n        firstArg.forEach(function (eventName) {\r\n          self.off(eventName, listenerWrapper);\r\n        });\r\n        if (typeof secondArg !== 'function') {\r\n          throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n        }\r\n        secondArg.apply(this, innerArgs);\r\n      };\r\n      firstArg.forEach(function (eventName) {\r\n        self.on(eventName, listenerWrapper);\r\n      });\r\n    } else {\r\n      if (typeof firstArg !== 'string') {\r\n        throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n      }\r\n      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\r\n      if (secondArg) {\r\n        if (typeof secondArg !== 'function') {\r\n          throw new Error('EventEmitter.once(): Invalid arguments:' + Platform.Config.inspect(args));\r\n        }\r\n        listeners.push(secondArg);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\r\n   * @param targetState the name of the state event to listen to\r\n   * @param currentState the name of the current state of this object\r\n   */\r\n  async whenState(targetState: string, currentState: string) {\r\n    if (typeof targetState !== 'string' || typeof currentState !== 'string') {\r\n      throw new Error('whenState requires a valid state String argument');\r\n    }\r\n    if (targetState === currentState) {\r\n      return null;\r\n    } else {\r\n      return this.once(targetState);\r\n    }\r\n  }\r\n}\r\n\r\nexport default EventEmitter;\r\n","import { MsgPack } from 'common/types/msgpack';\r\nimport * as API from '../../../../ably';\r\nimport { PresenceMessagePlugin } from '../client/modularplugins';\r\nimport * as Utils from '../util/utils';\r\nimport ErrorInfo from './errorinfo';\r\nimport Message, { fromValues as messageFromValues, fromValuesArray as messagesFromValuesArray } from './message';\r\nimport PresenceMessage, {\r\n  fromValues as presenceMessageFromValues,\r\n  fromValuesArray as presenceMessagesFromValuesArray,\r\n} from './presencemessage';\r\n\r\nexport const actions = {\r\n  HEARTBEAT: 0,\r\n  ACK: 1,\r\n  NACK: 2,\r\n  CONNECT: 3,\r\n  CONNECTED: 4,\r\n  DISCONNECT: 5,\r\n  DISCONNECTED: 6,\r\n  CLOSE: 7,\r\n  CLOSED: 8,\r\n  ERROR: 9,\r\n  ATTACH: 10,\r\n  ATTACHED: 11,\r\n  DETACH: 12,\r\n  DETACHED: 13,\r\n  PRESENCE: 14,\r\n  MESSAGE: 15,\r\n  SYNC: 16,\r\n  AUTH: 17,\r\n  ACTIVATE: 18,\r\n};\r\n\r\nexport const ActionName: string[] = [];\r\nObject.keys(actions).forEach(function (name) {\r\n  ActionName[(actions as { [key: string]: number })[name]] = name;\r\n});\r\n\r\nconst flags: { [key: string]: number } = {\r\n  /* Channel attach state flags */\r\n  HAS_PRESENCE: 1 << 0,\r\n  HAS_BACKLOG: 1 << 1,\r\n  RESUMED: 1 << 2,\r\n  TRANSIENT: 1 << 4,\r\n  ATTACH_RESUME: 1 << 5,\r\n  /* Channel mode flags */\r\n  PRESENCE: 1 << 16,\r\n  PUBLISH: 1 << 17,\r\n  SUBSCRIBE: 1 << 18,\r\n  PRESENCE_SUBSCRIBE: 1 << 19,\r\n};\r\nconst flagNames = Object.keys(flags);\r\nflags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;\r\n\r\nfunction toStringArray(array?: any[]): string {\r\n  const result = [];\r\n  if (array) {\r\n    for (let i = 0; i < array.length; i++) {\r\n      result.push(array[i].toString());\r\n    }\r\n  }\r\n  return '[ ' + result.join(', ') + ' ]';\r\n}\r\n\r\nexport const channelModes = ['PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE'];\r\n\r\nexport const serialize = Utils.encodeBody;\r\n\r\nexport function deserialize(\r\n  serialized: unknown,\r\n  MsgPack: MsgPack | null,\r\n  presenceMessagePlugin: PresenceMessagePlugin | null,\r\n  format?: Utils.Format,\r\n): ProtocolMessage {\r\n  const deserialized = Utils.decodeBody<Record<string, unknown>>(serialized, MsgPack, format);\r\n  return fromDeserialized(deserialized, presenceMessagePlugin);\r\n}\r\n\r\nexport function fromDeserialized(\r\n  deserialized: Record<string, unknown>,\r\n  presenceMessagePlugin: PresenceMessagePlugin | null,\r\n): ProtocolMessage {\r\n  const error = deserialized.error;\r\n  if (error) deserialized.error = ErrorInfo.fromValues(error as ErrorInfo);\r\n  const messages = deserialized.messages as Message[];\r\n  if (messages) for (let i = 0; i < messages.length; i++) messages[i] = messageFromValues(messages[i]);\r\n\r\n  const presence = presenceMessagePlugin ? (deserialized.presence as PresenceMessage[]) : undefined;\r\n  if (presenceMessagePlugin) {\r\n    if (presence && presenceMessagePlugin)\r\n      for (let i = 0; i < presence.length; i++)\r\n        presence[i] = presenceMessagePlugin.presenceMessageFromValues(presence[i], true);\r\n  }\r\n  return Object.assign(new ProtocolMessage(), { ...deserialized, presence });\r\n}\r\n\r\n/**\r\n * Used by the tests.\r\n */\r\nexport function fromDeserializedIncludingDependencies(deserialized: Record<string, unknown>): ProtocolMessage {\r\n  return fromDeserialized(deserialized, { presenceMessageFromValues, presenceMessagesFromValuesArray });\r\n}\r\n\r\nexport function fromValues(values: unknown): ProtocolMessage {\r\n  return Object.assign(new ProtocolMessage(), values);\r\n}\r\n\r\nexport function stringify(msg: any, presenceMessagePlugin: PresenceMessagePlugin | null): string {\r\n  let result = '[ProtocolMessage';\r\n  if (msg.action !== undefined) result += '; action=' + ActionName[msg.action] || msg.action;\r\n\r\n  const simpleAttributes = ['id', 'channel', 'channelSerial', 'connectionId', 'count', 'msgSerial', 'timestamp'];\r\n  let attribute;\r\n  for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\r\n    attribute = simpleAttributes[attribIndex];\r\n    if (msg[attribute] !== undefined) result += '; ' + attribute + '=' + msg[attribute];\r\n  }\r\n\r\n  if (msg.messages) result += '; messages=' + toStringArray(messagesFromValuesArray(msg.messages));\r\n  if (msg.presence && presenceMessagePlugin)\r\n    result += '; presence=' + toStringArray(presenceMessagePlugin.presenceMessagesFromValuesArray(msg.presence));\r\n  if (msg.error) result += '; error=' + ErrorInfo.fromValues(msg.error).toString();\r\n  if (msg.auth && msg.auth.accessToken) result += '; token=' + msg.auth.accessToken;\r\n  if (msg.flags) result += '; flags=' + flagNames.filter(msg.hasFlag).join(',');\r\n  if (msg.params) {\r\n    let stringifiedParams = '';\r\n    Utils.forInOwnNonNullProperties(msg.params, function (prop: string) {\r\n      if (stringifiedParams.length > 0) {\r\n        stringifiedParams += '; ';\r\n      }\r\n      stringifiedParams += prop + '=' + msg.params[prop];\r\n    });\r\n    if (stringifiedParams.length > 0) {\r\n      result += '; params=[' + stringifiedParams + ']';\r\n    }\r\n  }\r\n  result += ']';\r\n  return result;\r\n}\r\n\r\nclass ProtocolMessage {\r\n  action?: number;\r\n  flags?: number;\r\n  id?: string;\r\n  timestamp?: number;\r\n  count?: number;\r\n  error?: ErrorInfo;\r\n  connectionId?: string;\r\n  channel?: string;\r\n  channelSerial?: string | null;\r\n  msgSerial?: number;\r\n  messages?: Message[];\r\n  // This will be undefined if we skipped decoding this property due to user not requesting presence functionality â€” see `fromDeserialized`\r\n  presence?: PresenceMessage[];\r\n  auth?: unknown;\r\n  connectionDetails?: Record<string, unknown>;\r\n\r\n  hasFlag = (flag: string): boolean => {\r\n    return ((this.flags as number) & flags[flag]) > 0;\r\n  };\r\n\r\n  setFlag(flag: API.ChannelMode): number {\r\n    return (this.flags = (this.flags as number) | flags[flag]);\r\n  }\r\n\r\n  getMode(): number | undefined {\r\n    return this.flags && this.flags & flags.MODE_ALL;\r\n  }\r\n\r\n  encodeModesToFlags(modes: API.ChannelMode[]): void {\r\n    modes.forEach((mode) => this.setFlag(mode));\r\n  }\r\n\r\n  decodeModesFromFlags(): string[] | undefined {\r\n    const modes: string[] = [];\r\n    channelModes.forEach((mode) => {\r\n      if (this.hasFlag(mode)) {\r\n        modes.push(mode);\r\n      }\r\n    });\r\n    return modes.length > 0 ? modes : undefined;\r\n  }\r\n}\r\n\r\nexport default ProtocolMessage;\r\n","import ErrorInfo from '../types/errorinfo';\nimport EventEmitter from '../util/eventemitter';\nimport Logger from '../util/logger';\nimport { PendingMessage } from './protocol';\n\nclass MessageQueue extends EventEmitter {\n  messages: Array<PendingMessage>;\n\n  constructor() {\n    super();\n    this.messages = [];\n  }\n\n  count(): number {\n    return this.messages.length;\n  }\n\n  push(message: PendingMessage): void {\n    this.messages.push(message);\n  }\n\n  shift(): PendingMessage | undefined {\n    return this.messages.shift();\n  }\n\n  last(): PendingMessage {\n    return this.messages[this.messages.length - 1];\n  }\n\n  copyAll(): PendingMessage[] {\n    return this.messages.slice();\n  }\n\n  append(messages: Array<PendingMessage>): void {\n    this.messages.push.apply(this.messages, messages);\n  }\n\n  prepend(messages: Array<PendingMessage>): void {\n    this.messages.unshift.apply(this.messages, messages);\n  }\n\n  completeMessages(serial: number, count: number, err?: ErrorInfo | null): void {\n    Logger.logAction(Logger.LOG_MICRO, 'MessageQueue.completeMessages()', 'serial = ' + serial + '; count = ' + count);\n    err = err || null;\n    const messages = this.messages;\n    if (messages.length === 0) {\n      throw new Error('MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue');\n    }\n    const first = messages[0];\n    if (first) {\n      const startSerial = first.message.msgSerial as number;\n      const endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */\n      if (endSerial > startSerial) {\n        const completeMessages = messages.splice(0, endSerial - startSerial);\n        for (const message of completeMessages) {\n          (message.callback as Function)(err);\n        }\n      }\n      if (messages.length == 0) this.emit('idle');\n    }\n  }\n\n  completeAllMessages(err: ErrorInfo): void {\n    this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);\n  }\n\n  resetSendAttempted(): void {\n    for (let msg of this.messages) {\n      msg.sendAttempted = false;\n    }\n  }\n\n  clear(): void {\n    Logger.logAction(Logger.LOG_MICRO, 'MessageQueue.clear()', 'clearing ' + this.messages.length + ' messages');\n    this.messages = [];\n    this.emit('idle');\n  }\n}\n\nexport default MessageQueue;\n","import ProtocolMessage, { actions, stringify as stringifyProtocolMessage } from '../types/protocolmessage';\r\nimport * as Utils from '../util/utils';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport MessageQueue from './messagequeue';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Transport from './transport';\r\nimport { ErrCallback } from '../../types/utils';\r\n\r\nexport class PendingMessage {\r\n  message: ProtocolMessage;\r\n  callback?: ErrCallback;\r\n  merged: boolean;\r\n  sendAttempted: boolean;\r\n  ackRequired: boolean;\r\n\r\n  constructor(message: ProtocolMessage, callback?: ErrCallback) {\r\n    this.message = message;\r\n    this.callback = callback;\r\n    this.merged = false;\r\n    const action = message.action;\r\n    this.sendAttempted = false;\r\n    this.ackRequired = action == actions.MESSAGE || action == actions.PRESENCE;\r\n  }\r\n}\r\n\r\nclass Protocol extends EventEmitter {\r\n  transport: Transport;\r\n  messageQueue: MessageQueue;\r\n\r\n  constructor(transport: Transport) {\r\n    super();\r\n    this.transport = transport;\r\n    this.messageQueue = new MessageQueue();\r\n    transport.on('ack', (serial: number, count: number) => {\r\n      this.onAck(serial, count);\r\n    });\r\n    transport.on('nack', (serial: number, count: number, err: ErrorInfo) => {\r\n      this.onNack(serial, count, err);\r\n    });\r\n  }\r\n\r\n  onAck(serial: number, count: number): void {\r\n    Logger.logAction(Logger.LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);\r\n    this.messageQueue.completeMessages(serial, count);\r\n  }\r\n\r\n  onNack(serial: number, count: number, err: ErrorInfo): void {\r\n    Logger.logAction(\r\n      Logger.LOG_ERROR,\r\n      'Protocol.onNack()',\r\n      'serial = ' + serial + '; count = ' + count + '; err = ' + Utils.inspectError(err),\r\n    );\r\n    if (!err) {\r\n      err = new ErrorInfo('Unable to send message; channel not responding', 50001, 500);\r\n    }\r\n    this.messageQueue.completeMessages(serial, count, err);\r\n  }\r\n\r\n  onceIdle(listener: ErrCallback): void {\r\n    const messageQueue = this.messageQueue;\r\n    if (messageQueue.count() === 0) {\r\n      listener();\r\n      return;\r\n    }\r\n    messageQueue.once('idle', listener);\r\n  }\r\n\r\n  send(pendingMessage: PendingMessage): void {\r\n    if (pendingMessage.ackRequired) {\r\n      this.messageQueue.push(pendingMessage);\r\n    }\r\n    if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n      Logger.logActionNoStrip(\r\n        Logger.LOG_MICRO,\r\n        'Protocol.send()',\r\n        'sending msg; ' +\r\n          stringifyProtocolMessage(pendingMessage.message, this.transport.connectionManager.realtime._RealtimePresence),\r\n      );\r\n    }\r\n    pendingMessage.sendAttempted = true;\r\n    this.transport.send(pendingMessage.message);\r\n  }\r\n\r\n  getTransport(): Transport {\r\n    return this.transport;\r\n  }\r\n\r\n  getPendingMessages(): PendingMessage[] {\r\n    return this.messageQueue.copyAll();\r\n  }\r\n\r\n  clearPendingMessages(): void {\r\n    return this.messageQueue.clear();\r\n  }\r\n\r\n  finish(): void {\r\n    const transport = this.transport;\r\n    this.onceIdle(function () {\r\n      transport.disconnect();\r\n    });\r\n  }\r\n}\r\n\r\nexport default Protocol;\r\n","import { IPartialErrorInfo } from '../types/errorinfo';\n\nclass ConnectionStateChange {\n  previous?: string;\n  current?: string;\n  retryIn?: number;\n  reason?: IPartialErrorInfo;\n\n  constructor(previous?: string, current?: string, retryIn?: number | null, reason?: IPartialErrorInfo) {\n    this.previous = previous;\n    this.current = current;\n    if (retryIn) this.retryIn = retryIn;\n    if (reason) this.reason = reason;\n  }\n}\n\nexport default ConnectionStateChange;\n","import ErrorInfo from '../types/errorinfo';\n\nconst ConnectionErrorCodes = {\n  DISCONNECTED: 80003,\n  SUSPENDED: 80002,\n  FAILED: 80000,\n  CLOSING: 80017,\n  CLOSED: 80017,\n  UNKNOWN_CONNECTION_ERR: 50002,\n  UNKNOWN_CHANNEL_ERR: 50001,\n};\n\nconst ConnectionErrors = {\n  disconnected: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.DISCONNECTED,\n      message: 'Connection to server temporarily unavailable',\n    }),\n  suspended: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.SUSPENDED,\n      message: 'Connection to server unavailable',\n    }),\n  failed: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.FAILED,\n      message: 'Connection failed or disconnected by server',\n    }),\n  closing: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.CLOSING,\n      message: 'Connection closing',\n    }),\n  closed: () =>\n    ErrorInfo.fromValues({\n      statusCode: 400,\n      code: ConnectionErrorCodes.CLOSED,\n      message: 'Connection closed',\n    }),\n  unknownConnectionErr: () =>\n    ErrorInfo.fromValues({\n      statusCode: 500,\n      code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n      message: 'Internal connection error',\n    }),\n  unknownChannelErr: () =>\n    ErrorInfo.fromValues({\n      statusCode: 500,\n      code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n      message: 'Internal channel error',\n    }),\n};\n\nexport function isRetriable(err: ErrorInfo) {\n  if (!err.statusCode || !err.code || err.statusCode >= 500) {\n    return true;\n  }\n  return Object.values(ConnectionErrorCodes).includes(err.code);\n}\n\nexport default ConnectionErrors;\n","import ProtocolMessage, {\r\n  actions,\r\n  fromValues as protocolMessageFromValues,\r\n  stringify as stringifyProtocolMessage,\r\n} from '../types/protocolmessage';\r\nimport * as Utils from '../util/utils';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport ConnectionErrors from './connectionerrors';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport Auth from '../client/auth';\r\nimport * as API from '../../../../ably';\r\nimport ConnectionManager, { TransportParams } from './connectionmanager';\r\nimport Platform from 'common/platform';\r\nimport TransportName from 'common/constants/TransportName';\r\n\r\nexport type TryConnectCallback = (\r\n  wrappedErr: { error: ErrorInfo; event: string } | null,\r\n  transport?: Transport,\r\n) => void;\r\n\r\nexport interface TransportCtor {\r\n  new (\r\n    connectionManager: ConnectionManager,\r\n    auth: Auth,\r\n    params: TransportParams,\r\n    forceJsonProtocol?: boolean,\r\n  ): Transport;\r\n\r\n  isAvailable(): boolean;\r\n}\r\n\r\nconst closeMessage = protocolMessageFromValues({ action: actions.CLOSE });\r\nconst disconnectMessage = protocolMessageFromValues({ action: actions.DISCONNECT });\r\n\r\n/*\r\n * Transport instances inherit from EventEmitter and emit the following events:\r\n *\r\n * event name       data\r\n * closed           error\r\n * failed           error\r\n * disposed\r\n * connected        null error, connectionSerial, connectionId, connectionDetails\r\n * event            channel message object\r\n */\r\n\r\nabstract class Transport extends EventEmitter {\r\n  connectionManager: ConnectionManager;\r\n  auth: Auth;\r\n  params: TransportParams;\r\n  timeouts: Record<string, number>;\r\n  format?: Utils.Format;\r\n  isConnected: boolean;\r\n  isFinished: boolean;\r\n  isDisposed: boolean;\r\n  maxIdleInterval: number | null;\r\n  idleTimer: NodeJS.Timeout | number | null;\r\n  lastActivity: number | null;\r\n\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams, forceJsonProtocol?: boolean) {\r\n    super();\r\n    if (forceJsonProtocol) {\r\n      params.format = undefined;\r\n      params.heartbeats = true;\r\n    }\r\n    this.connectionManager = connectionManager;\r\n    this.auth = auth;\r\n    this.params = params;\r\n    this.timeouts = params.options.timeouts;\r\n    this.format = params.format;\r\n    this.isConnected = false;\r\n    this.isFinished = false;\r\n    this.isDisposed = false;\r\n    this.maxIdleInterval = null;\r\n    this.idleTimer = null;\r\n    this.lastActivity = null;\r\n  }\r\n\r\n  abstract shortName: TransportName;\r\n  abstract send(message: ProtocolMessage): void;\r\n\r\n  connect(): void {}\r\n\r\n  close(): void {\r\n    if (this.isConnected) {\r\n      this.requestClose();\r\n    }\r\n    this.finish('closed', ConnectionErrors.closed());\r\n  }\r\n\r\n  disconnect(err?: Error | ErrorInfo): void {\r\n    /* Used for network/transport issues that need to result in the transport\r\n     * being disconnected, but should not transition the connection to 'failed' */\r\n    if (this.isConnected) {\r\n      this.requestDisconnect();\r\n    }\r\n    this.finish('disconnected', err || ConnectionErrors.disconnected());\r\n  }\r\n\r\n  fail(err: ErrorInfo): void {\r\n    /* Used for client-side-detected fatal connection issues */\r\n    if (this.isConnected) {\r\n      this.requestDisconnect();\r\n    }\r\n    this.finish('failed', err || ConnectionErrors.failed());\r\n  }\r\n\r\n  finish(event: string, err?: Error | ErrorInfo): void {\r\n    if (this.isFinished) {\r\n      return;\r\n    }\r\n\r\n    this.isFinished = true;\r\n    this.isConnected = false;\r\n    this.maxIdleInterval = null;\r\n    clearTimeout(this.idleTimer ?? undefined);\r\n    this.idleTimer = null;\r\n    this.emit(event, err);\r\n    this.dispose();\r\n  }\r\n\r\n  onProtocolMessage(message: ProtocolMessage): void {\r\n    if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n      Logger.logActionNoStrip(\r\n        Logger.LOG_MICRO,\r\n        'Transport.onProtocolMessage()',\r\n        'received on ' +\r\n          this.shortName +\r\n          ': ' +\r\n          stringifyProtocolMessage(message, this.connectionManager.realtime._RealtimePresence) +\r\n          '; connectionId = ' +\r\n          this.connectionManager.connectionId,\r\n      );\r\n    }\r\n    this.onActivity();\r\n\r\n    switch (message.action) {\r\n      case actions.HEARTBEAT:\r\n        Logger.logActionNoStrip(\r\n          Logger.LOG_MICRO,\r\n          'Transport.onProtocolMessage()',\r\n          this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId,\r\n        );\r\n        this.emit('heartbeat', message.id);\r\n        break;\r\n      case actions.CONNECTED:\r\n        this.onConnect(message);\r\n        this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);\r\n        break;\r\n      case actions.CLOSED:\r\n        this.onClose(message);\r\n        break;\r\n      case actions.DISCONNECTED:\r\n        this.onDisconnect(message);\r\n        break;\r\n      case actions.ACK:\r\n        this.emit('ack', message.msgSerial, message.count);\r\n        break;\r\n      case actions.NACK:\r\n        this.emit('nack', message.msgSerial, message.count, message.error);\r\n        break;\r\n      case actions.SYNC:\r\n        this.connectionManager.onChannelMessage(message, this);\r\n        break;\r\n      case actions.ACTIVATE:\r\n        // Ignored.\r\n        break;\r\n      case actions.AUTH:\r\n        Utils.whenPromiseSettles(this.auth.authorize(), function (err: ErrorInfo | null) {\r\n          if (err) {\r\n            Logger.logAction(\r\n              Logger.LOG_ERROR,\r\n              'Transport.onProtocolMessage()',\r\n              'Ably requested re-authentication, but unable to obtain a new token: ' + Utils.inspectError(err),\r\n            );\r\n          }\r\n        });\r\n        break;\r\n      case actions.ERROR:\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'Transport.onProtocolMessage()',\r\n          'received error action; connectionId = ' +\r\n            this.connectionManager.connectionId +\r\n            '; err = ' +\r\n            Platform.Config.inspect(message.error) +\r\n            (message.channel ? ', channel: ' + message.channel : ''),\r\n        );\r\n        if (message.channel === undefined) {\r\n          this.onFatalError(message);\r\n          break;\r\n        }\r\n        /* otherwise it's a channel-specific error, so handle it in the channel */\r\n        this.connectionManager.onChannelMessage(message, this);\r\n        break;\r\n      default:\r\n        /* all other actions are channel-specific */\r\n        this.connectionManager.onChannelMessage(message, this);\r\n    }\r\n  }\r\n\r\n  onConnect(message: ProtocolMessage): void {\r\n    this.isConnected = true;\r\n    if (!message.connectionDetails) {\r\n      throw new Error('Transport.onConnect(): Connect message recieved without connectionDetails');\r\n    }\r\n    const maxPromisedIdle = message.connectionDetails.maxIdleInterval as number;\r\n    if (maxPromisedIdle) {\r\n      this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\r\n      this.onActivity();\r\n    }\r\n    /* else Realtime declines to guarantee any maximum idle interval - CD2h */\r\n  }\r\n\r\n  onDisconnect(message: ProtocolMessage): void {\r\n    /* Used for when the server has disconnected the client (usually with a\r\n     * DISCONNECTED action) */\r\n    const err = message && message.error;\r\n    Logger.logAction(Logger.LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + Utils.inspectError(err));\r\n    this.finish('disconnected', err);\r\n  }\r\n\r\n  onFatalError(message: ProtocolMessage): void {\r\n    /* On receipt of a fatal connection error, we can assume that the server\r\n     * will close the connection and the transport, and do not need to request\r\n     * a disconnection - RTN15i */\r\n    const err = message && message.error;\r\n    Logger.logAction(Logger.LOG_MINOR, 'Transport.onFatalError()', 'err = ' + Utils.inspectError(err));\r\n    this.finish('failed', err);\r\n  }\r\n\r\n  onClose(message: ProtocolMessage): void {\r\n    const err = message && message.error;\r\n    Logger.logAction(Logger.LOG_MINOR, 'Transport.onClose()', 'err = ' + Utils.inspectError(err));\r\n    this.finish('closed', err);\r\n  }\r\n\r\n  requestClose(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Transport.requestClose()', '');\r\n    this.send(closeMessage);\r\n  }\r\n\r\n  requestDisconnect(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Transport.requestDisconnect()', '');\r\n    this.send(disconnectMessage);\r\n  }\r\n\r\n  ping(id: string): void {\r\n    const msg: Record<string, number | string> = { action: actions.HEARTBEAT };\r\n    if (id) msg.id = id;\r\n    this.send(protocolMessageFromValues(msg));\r\n  }\r\n\r\n  dispose(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Transport.dispose()', '');\r\n    this.isDisposed = true;\r\n    this.off();\r\n  }\r\n\r\n  onActivity(): void {\r\n    if (!this.maxIdleInterval) {\r\n      return;\r\n    }\r\n    this.lastActivity = this.connectionManager.lastActivity = Date.now();\r\n    this.setIdleTimer(this.maxIdleInterval + 100);\r\n  }\r\n\r\n  setIdleTimer(timeout: number): void {\r\n    if (!this.idleTimer) {\r\n      this.idleTimer = setTimeout(() => {\r\n        this.onIdleTimerExpire();\r\n      }, timeout);\r\n    }\r\n  }\r\n\r\n  onIdleTimerExpire(): void {\r\n    if (!this.lastActivity || !this.maxIdleInterval) {\r\n      throw new Error('Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set');\r\n    }\r\n    this.idleTimer = null;\r\n    const sinceLast = Date.now() - this.lastActivity;\r\n    const timeRemaining = this.maxIdleInterval - sinceLast;\r\n    if (timeRemaining <= 0) {\r\n      const msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';\r\n      Logger.logAction(Logger.LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);\r\n      this.disconnect(new ErrorInfo(msg, 80003, 408));\r\n    } else {\r\n      this.setIdleTimer(timeRemaining + 100);\r\n    }\r\n  }\r\n\r\n  static tryConnect(\r\n    transportCtor: TransportCtor,\r\n    connectionManager: ConnectionManager,\r\n    auth: Auth,\r\n    transportParams: TransportParams,\r\n    callback: TryConnectCallback,\r\n  ): Transport {\r\n    const transport = new transportCtor(connectionManager, auth, transportParams);\r\n\r\n    let transportAttemptTimer: NodeJS.Timeout | number;\r\n\r\n    const errorCb = function (this: { event: string }, err: ErrorInfo) {\r\n      clearTimeout(transportAttemptTimer);\r\n      callback({ event: this.event, error: err });\r\n    };\r\n\r\n    const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\r\n    transportAttemptTimer = setTimeout(() => {\r\n      transport.off(['preconnect', 'disconnected', 'failed']);\r\n      transport.dispose();\r\n      errorCb.call(\r\n        { event: 'disconnected' },\r\n        new ErrorInfo('Timeout waiting for transport to indicate itself viable', 50000, 500),\r\n      );\r\n    }, realtimeRequestTimeout);\r\n\r\n    transport.on(['failed', 'disconnected'], errorCb);\r\n    transport.on('preconnect', function () {\r\n      Logger.logAction(Logger.LOG_MINOR, 'Transport.tryConnect()', 'viable transport ' + transport);\r\n      clearTimeout(transportAttemptTimer);\r\n      transport.off(['failed', 'disconnected'], errorCb);\r\n      callback(null, transport);\r\n    });\r\n    transport.connect();\r\n    return transport;\r\n  }\r\n\r\n  onAuthUpdated?: (tokenDetails: API.TokenDetails) => void;\r\n\r\n  static isAvailable(): boolean {\r\n    throw new ErrorInfo('isAvailable not implemented for transport', 50000, 500);\r\n  }\r\n}\r\n\r\nexport default Transport;\r\n","export namespace TransportNames {\r\n  export const WebSocket = 'web_socket' as const;\r\n  export const Comet = 'comet' as const;\r\n  export const XhrPolling = 'xhr_polling' as const;\r\n}\r\n\r\ntype TransportName = typeof TransportNames.WebSocket | typeof TransportNames.Comet | typeof TransportNames.XhrPolling;\r\n\r\nexport default TransportName;\r\n","import ProtocolMessage, {\r\n  actions,\r\n  stringify as stringifyProtocolMessage,\r\n  fromValues as protocolMessageFromValues,\r\n} from 'common/lib/types/protocolmessage';\r\nimport * as Utils from 'common/lib/util/utils';\r\nimport Protocol, { PendingMessage } from './protocol';\r\nimport Defaults, { getAgentString } from 'common/lib/util/defaults';\r\nimport Platform, { TransportImplementations } from 'common/platform';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport MessageQueue from './messagequeue';\r\nimport Logger from '../util/logger';\r\nimport ConnectionStateChange from 'common/lib/client/connectionstatechange';\r\nimport ConnectionErrors, { isRetriable } from './connectionerrors';\r\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport Auth from 'common/lib/client/auth';\r\nimport Message, { getMessagesSize } from 'common/lib/types/message';\r\nimport Multicaster, { MulticasterInstance } from 'common/lib/util/multicaster';\r\nimport Transport, { TransportCtor } from './transport';\r\nimport * as API from '../../../../ably';\r\nimport { ErrCallback } from 'common/types/utils';\r\nimport HttpStatusCodes from 'common/constants/HttpStatusCodes';\r\nimport BaseRealtime from '../client/baserealtime';\r\nimport { NormalisedClientOptions } from 'common/types/ClientOptions';\r\nimport TransportName, { TransportNames } from 'common/constants/TransportName';\r\n\r\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\r\n\r\nconst haveWebStorage = () => typeof Platform.WebStorage !== 'undefined' && Platform.WebStorage?.localSupported;\r\nconst haveSessionStorage = () => typeof Platform.WebStorage !== 'undefined' && Platform.WebStorage?.sessionSupported;\r\nconst noop = function () {};\r\nconst transportPreferenceName = 'ably-transport-preference';\r\n\r\nconst sessionRecoveryName = 'ably-connection-recovery';\r\nfunction getSessionRecoverData() {\r\n  return haveSessionStorage() && Platform.WebStorage?.getSession?.(sessionRecoveryName);\r\n}\r\nfunction setSessionRecoverData(value: any) {\r\n  return haveSessionStorage() && Platform.WebStorage?.setSession?.(sessionRecoveryName, value);\r\n}\r\nfunction clearSessionRecoverData() {\r\n  return haveSessionStorage() && Platform.WebStorage?.removeSession?.(sessionRecoveryName);\r\n}\r\n\r\nfunction bundleWith(dest: ProtocolMessage, src: ProtocolMessage, maxSize: number) {\r\n  let action;\r\n  if (dest.channel !== src.channel) {\r\n    /* RTL6d3 */\r\n    return false;\r\n  }\r\n  if ((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {\r\n    /* RTL6d - can only bundle messages or presence */\r\n    return false;\r\n  }\r\n  if (action !== src.action) {\r\n    /* RTL6d4 */\r\n    return false;\r\n  }\r\n  const kind = action === actions.PRESENCE ? 'presence' : 'messages',\r\n    proposed = (dest as Record<string, any>)[kind].concat((src as Record<string, any>)[kind]),\r\n    size = getMessagesSize(proposed);\r\n  if (size > maxSize) {\r\n    /* RTL6d1 */\r\n    return false;\r\n  }\r\n  if (!Utils.allSame(proposed, 'clientId')) {\r\n    /* RTL6d2 */\r\n    return false;\r\n  }\r\n  if (\r\n    !proposed.every(function (msg: Message) {\r\n      return !msg.id;\r\n    })\r\n  ) {\r\n    /* RTL6d7 */\r\n    return false;\r\n  }\r\n  /* we're good to go! */\r\n  (dest as Record<string, any>)[kind] = proposed;\r\n  return true;\r\n}\r\n\r\ntype RecoveryContext = {\r\n  connectionKey: string;\r\n  msgSerial: number;\r\n  channelSerials: { [name: string]: string };\r\n};\r\n\r\nfunction decodeRecoveryKey(recoveryKey: NormalisedClientOptions['recover']): RecoveryContext | null {\r\n  try {\r\n    return JSON.parse(recoveryKey as string);\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport class TransportParams {\r\n  options: NormalisedClientOptions;\r\n  host: string | null;\r\n  mode: string;\r\n  format?: Utils.Format;\r\n  connectionKey?: string;\r\n  stream?: any;\r\n  heartbeats?: boolean;\r\n\r\n  constructor(options: NormalisedClientOptions, host: string | null, mode: string, connectionKey?: string) {\r\n    this.options = options;\r\n    this.host = host;\r\n    this.mode = mode;\r\n    this.connectionKey = connectionKey;\r\n    this.format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;\r\n  }\r\n\r\n  getConnectParams(authParams: Record<string, unknown>): Record<string, string> {\r\n    const params = authParams ? Utils.copy(authParams) : {};\r\n    const options = this.options;\r\n    switch (this.mode) {\r\n      case 'resume':\r\n        params.resume = this.connectionKey as string;\r\n        break;\r\n      case 'recover': {\r\n        const recoveryContext = decodeRecoveryKey(options.recover);\r\n        if (recoveryContext) {\r\n          params.recover = recoveryContext.connectionKey;\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n    }\r\n    if (options.clientId !== undefined) {\r\n      params.clientId = options.clientId;\r\n    }\r\n    if (options.echoMessages === false) {\r\n      params.echo = 'false';\r\n    }\r\n    if (this.format !== undefined) {\r\n      params.format = this.format;\r\n    }\r\n    if (this.stream !== undefined) {\r\n      params.stream = this.stream;\r\n    }\r\n    if (this.heartbeats !== undefined) {\r\n      params.heartbeats = this.heartbeats;\r\n    }\r\n    params.v = Defaults.protocolVersion;\r\n    params.agent = getAgentString(this.options);\r\n    if (options.transportParams !== undefined) {\r\n      Utils.mixin(params, options.transportParams);\r\n    }\r\n    return params as Record<string, string>;\r\n  }\r\n\r\n  toString(): string {\r\n    let result = '[mode=' + this.mode;\r\n    if (this.host) {\r\n      result += ',host=' + this.host;\r\n    }\r\n    if (this.connectionKey) {\r\n      result += ',connectionKey=' + this.connectionKey;\r\n    }\r\n    if (this.format) {\r\n      result += ',format=' + this.format;\r\n    }\r\n    result += ']';\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\ntype ConnectionState = {\r\n  state: string;\r\n  terminal?: boolean;\r\n  queueEvents?: boolean;\r\n  sendEvents?: boolean;\r\n  failState?: string;\r\n  retryDelay?: number;\r\n  retryImmediately?: boolean;\r\n  error?: IPartialErrorInfo;\r\n};\r\n\r\nclass ConnectionManager extends EventEmitter {\r\n  supportedTransports: Partial<Record<TransportName, TransportCtor>> = {};\r\n  realtime: BaseRealtime;\r\n  options: NormalisedClientOptions;\r\n  states: Record<string, ConnectionState>;\r\n  state: ConnectionState;\r\n  errorReason: IPartialErrorInfo | string | null;\r\n  queuedMessages: MessageQueue;\r\n  msgSerial: number;\r\n  connectionDetails?: Record<string, any>;\r\n  connectionId?: string;\r\n  connectionKey?: string;\r\n  connectionStateTtl: number;\r\n  maxIdleInterval: number | null;\r\n  transports: TransportName[];\r\n  baseTransport?: TransportName;\r\n  webSocketTransportAvailable?: true;\r\n  transportPreference: string | null;\r\n  httpHosts: string[];\r\n  wsHosts: string[];\r\n  activeProtocol: null | Protocol;\r\n  pendingTransport?: Transport;\r\n  proposedTransport?: Transport;\r\n  host: string | null;\r\n  lastAutoReconnectAttempt: number | null;\r\n  lastActivity: number | null;\r\n  forceFallbackHost: boolean;\r\n  transitionTimer?: number | NodeJS.Timeout | null;\r\n  suspendTimer?: number | NodeJS.Timeout | null;\r\n  retryTimer?: number | NodeJS.Timeout | null;\r\n  disconnectedRetryCount: number = 0;\r\n  pendingChannelMessagesState: {\r\n    // Whether a message is currently being processed\r\n    isProcessing: boolean;\r\n    // The messages remaining to be processed (excluding any message currently being processed)\r\n    queue: { message: ProtocolMessage; transport: Transport }[];\r\n  } = { isProcessing: false, queue: [] };\r\n  webSocketSlowTimer: NodeJS.Timeout | null;\r\n  wsCheckResult: boolean | null;\r\n  webSocketGiveUpTimer: NodeJS.Timeout | null;\r\n  abandonedWebSocket: boolean;\r\n  connectCounter: number;\r\n\r\n  constructor(realtime: BaseRealtime, options: NormalisedClientOptions) {\r\n    super();\r\n    this.realtime = realtime;\r\n    this.initTransports();\r\n    this.options = options;\r\n    const timeouts = options.timeouts;\r\n    /* connectingTimeout: leave webSocketConnectTimeout (~6s) to try the\r\n     * websocket transport, then realtimeRequestTimeout (~10s) to establish\r\n     * the base transport in case that fails */\r\n    const connectingTimeout = timeouts.webSocketConnectTimeout + timeouts.realtimeRequestTimeout;\r\n    this.states = {\r\n      initialized: {\r\n        state: 'initialized',\r\n        terminal: false,\r\n        queueEvents: true,\r\n        sendEvents: false,\r\n        failState: 'disconnected',\r\n      },\r\n      connecting: {\r\n        state: 'connecting',\r\n        terminal: false,\r\n        queueEvents: true,\r\n        sendEvents: false,\r\n        retryDelay: connectingTimeout,\r\n        failState: 'disconnected',\r\n      },\r\n      connected: {\r\n        state: 'connected',\r\n        terminal: false,\r\n        queueEvents: false,\r\n        sendEvents: true,\r\n        failState: 'disconnected',\r\n      },\r\n      disconnected: {\r\n        state: 'disconnected',\r\n        terminal: false,\r\n        queueEvents: true,\r\n        sendEvents: false,\r\n        retryDelay: timeouts.disconnectedRetryTimeout,\r\n        failState: 'disconnected',\r\n      },\r\n      suspended: {\r\n        state: 'suspended',\r\n        terminal: false,\r\n        queueEvents: false,\r\n        sendEvents: false,\r\n        retryDelay: timeouts.suspendedRetryTimeout,\r\n        failState: 'suspended',\r\n      },\r\n      closing: {\r\n        state: 'closing',\r\n        terminal: false,\r\n        queueEvents: false,\r\n        sendEvents: false,\r\n        retryDelay: timeouts.realtimeRequestTimeout,\r\n        failState: 'closed',\r\n      },\r\n      closed: { state: 'closed', terminal: true, queueEvents: false, sendEvents: false, failState: 'closed' },\r\n      failed: { state: 'failed', terminal: true, queueEvents: false, sendEvents: false, failState: 'failed' },\r\n    };\r\n    this.state = this.states.initialized;\r\n    this.errorReason = null;\r\n\r\n    this.queuedMessages = new MessageQueue();\r\n    this.msgSerial = 0;\r\n    this.connectionDetails = undefined;\r\n    this.connectionId = undefined;\r\n    this.connectionKey = undefined;\r\n    this.connectionStateTtl = timeouts.connectionStateTtl;\r\n    this.maxIdleInterval = null;\r\n\r\n    this.transports = Utils.intersect(options.transports || Defaults.defaultTransports, this.supportedTransports);\r\n    this.transportPreference = null;\r\n\r\n    if (this.transports.includes(TransportNames.WebSocket)) {\r\n      this.webSocketTransportAvailable = true;\r\n    }\r\n    if (this.transports.includes(TransportNames.XhrPolling)) {\r\n      this.baseTransport = TransportNames.XhrPolling;\r\n    } else if (this.transports.includes(TransportNames.Comet)) {\r\n      this.baseTransport = TransportNames.Comet;\r\n    }\r\n\r\n    this.httpHosts = Defaults.getHosts(options);\r\n    this.wsHosts = Defaults.getHosts(options, true);\r\n    this.activeProtocol = null;\r\n    this.host = null;\r\n    this.lastAutoReconnectAttempt = null;\r\n    this.lastActivity = null;\r\n    this.forceFallbackHost = false;\r\n    this.connectCounter = 0;\r\n    this.wsCheckResult = null;\r\n    this.webSocketSlowTimer = null;\r\n    this.webSocketGiveUpTimer = null;\r\n    this.abandonedWebSocket = false;\r\n\r\n    Logger.logAction(Logger.LOG_MINOR, 'Realtime.ConnectionManager()', 'started');\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'Realtime.ConnectionManager()',\r\n      'requested transports = [' + (options.transports || Defaults.defaultTransports) + ']',\r\n    );\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'Realtime.ConnectionManager()',\r\n      'available transports = [' + this.transports + ']',\r\n    );\r\n    Logger.logAction(Logger.LOG_MICRO, 'Realtime.ConnectionManager()', 'http hosts = [' + this.httpHosts + ']');\r\n\r\n    if (!this.transports.length) {\r\n      const msg = 'no requested transports available';\r\n      Logger.logAction(Logger.LOG_ERROR, 'realtime.ConnectionManager()', msg);\r\n      throw new Error(msg);\r\n    }\r\n\r\n    const addEventListener = Platform.Config.addEventListener;\r\n    if (addEventListener) {\r\n      /* intercept close event in browser to persist connection id if requested */\r\n      if (haveSessionStorage() && typeof options.recover === 'function') {\r\n        addEventListener('beforeunload', this.persistConnection.bind(this));\r\n      }\r\n\r\n      if (options.closeOnUnload === true) {\r\n        addEventListener('beforeunload', () => {\r\n          Logger.logAction(\r\n            Logger.LOG_MAJOR,\r\n            'Realtime.ConnectionManager()',\r\n            'beforeunload event has triggered the connection to close as closeOnUnload is true',\r\n          );\r\n          this.requestState({ state: 'closing' });\r\n        });\r\n      }\r\n\r\n      /* Listen for online and offline events */\r\n      addEventListener('online', () => {\r\n        if (this.state == this.states.disconnected || this.state == this.states.suspended) {\r\n          Logger.logAction(\r\n            Logger.LOG_MINOR,\r\n            'ConnectionManager caught browser â€˜onlineâ€™ event',\r\n            'reattempting connection',\r\n          );\r\n          this.requestState({ state: 'connecting' });\r\n        } else if (this.state == this.states.connecting) {\r\n          // RTN20c: if 'online' event recieved while CONNECTING, abandon connection attempt and retry\r\n          this.pendingTransport?.off();\r\n          this.disconnectAllTransports();\r\n\r\n          this.startConnect();\r\n        }\r\n      });\r\n\r\n      addEventListener('offline', () => {\r\n        if (this.state == this.states.connected) {\r\n          Logger.logAction(\r\n            Logger.LOG_MINOR,\r\n            'ConnectionManager caught browser â€˜offlineâ€™ event',\r\n            'disconnecting active transport',\r\n          );\r\n          // Not sufficient to just go to the 'disconnected' state, want to\r\n          // force all transports to reattempt the connection. Will immediately\r\n          // retry.\r\n          this.disconnectAllTransports();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /*********************\r\n   * transport management\r\n   *********************/\r\n\r\n  // Used by tests\r\n  static supportedTransports(additionalImplementations: TransportImplementations) {\r\n    const storage: TransportStorage = { supportedTransports: {} };\r\n    this.initTransports(additionalImplementations, storage);\r\n    return storage.supportedTransports;\r\n  }\r\n\r\n  private static initTransports(additionalImplementations: TransportImplementations, storage: TransportStorage) {\r\n    const implementations = { ...Platform.Transports.bundledImplementations, ...additionalImplementations };\r\n\r\n    [TransportNames.WebSocket, ...Platform.Transports.order].forEach((transportName) => {\r\n      const transport = implementations[transportName];\r\n      if (transport && transport.isAvailable()) {\r\n        storage.supportedTransports[transportName] = transport;\r\n      }\r\n    });\r\n  }\r\n\r\n  initTransports() {\r\n    ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);\r\n  }\r\n\r\n  createTransportParams(host: string | null, mode: string): TransportParams {\r\n    return new TransportParams(this.options, host, mode, this.connectionKey);\r\n  }\r\n\r\n  getTransportParams(callback: Function): void {\r\n    const decideMode = (modeCb: Function) => {\r\n      if (this.connectionKey) {\r\n        modeCb('resume');\r\n        return;\r\n      }\r\n\r\n      if (typeof this.options.recover === 'string') {\r\n        modeCb('recover');\r\n        return;\r\n      }\r\n\r\n      const recoverFn = this.options.recover,\r\n        lastSessionData = getSessionRecoverData();\r\n      if (lastSessionData && typeof recoverFn === 'function') {\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager.getTransportParams()',\r\n          'Calling clientOptions-provided recover function with last session data',\r\n        );\r\n        recoverFn(lastSessionData, (shouldRecover?: boolean) => {\r\n          if (shouldRecover) {\r\n            this.options.recover = lastSessionData.recoveryKey;\r\n            modeCb('recover');\r\n          } else {\r\n            modeCb('clean');\r\n          }\r\n        });\r\n        return;\r\n      }\r\n      modeCb('clean');\r\n    };\r\n\r\n    decideMode((mode: string) => {\r\n      const transportParams = this.createTransportParams(null, mode);\r\n      if (mode === 'recover') {\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager.getTransportParams()',\r\n          'Transport recovery mode = recover; recoveryKey = ' + this.options.recover,\r\n        );\r\n        const recoveryContext = decodeRecoveryKey(this.options.recover);\r\n        if (recoveryContext) {\r\n          this.msgSerial = recoveryContext.msgSerial;\r\n        }\r\n      } else {\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager.getTransportParams()',\r\n          'Transport params = ' + transportParams.toString(),\r\n        );\r\n      }\r\n      callback(transportParams);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Attempt to connect using a given transport\r\n   * @param transportParams\r\n   * @param candidate, the transport to try\r\n   * @param callback\r\n   */\r\n  tryATransport(transportParams: TransportParams, candidate: TransportName, callback: Function): void {\r\n    Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);\r\n\r\n    this.proposedTransport = Transport.tryConnect(\r\n      this.supportedTransports[candidate]!,\r\n      this,\r\n      this.realtime.auth,\r\n      transportParams,\r\n      (wrappedErr: { error: ErrorInfo; event: string } | null, transport?: Transport) => {\r\n        const state = this.state;\r\n        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {\r\n          if (transport) {\r\n            Logger.logAction(\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager.tryATransport()',\r\n              'connection ' + state.state + ' while we were attempting the transport; closing ' + transport,\r\n            );\r\n            transport.close();\r\n          }\r\n          callback(true);\r\n          return;\r\n        }\r\n\r\n        if (wrappedErr) {\r\n          Logger.logAction(\r\n            Logger.LOG_MINOR,\r\n            'ConnectionManager.tryATransport()',\r\n            'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString(),\r\n          );\r\n\r\n          /* Comet transport onconnect token errors can be dealt with here.\r\n           * Websocket ones only happen after the transport claims to be viable,\r\n           * so are dealt with as non-onconnect token errors */\r\n          if (\r\n            Auth.isTokenErr(wrappedErr.error) &&\r\n            !(this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo))\r\n          ) {\r\n            this.errorReason = wrappedErr.error;\r\n            /* re-get a token and try again */\r\n            Utils.whenPromiseSettles(this.realtime.auth._forceNewToken(null, null), (err: ErrorInfo | null) => {\r\n              if (err) {\r\n                this.actOnErrorFromAuthorize(err);\r\n                return;\r\n              }\r\n              this.tryATransport(transportParams, candidate, callback);\r\n            });\r\n          } else if (wrappedErr.event === 'failed') {\r\n            /* Error that's fatal to the connection */\r\n            this.notifyState({ state: 'failed', error: wrappedErr.error });\r\n            callback(true);\r\n          } else if (wrappedErr.event === 'disconnected') {\r\n            if (!isRetriable(wrappedErr.error)) {\r\n              /* Error received from the server that does not call for trying a fallback host, eg a rate limit */\r\n              this.notifyState({ state: this.states.connecting.failState as string, error: wrappedErr.error });\r\n              callback(true);\r\n            } else {\r\n              /* Error with that transport only; continue trying other fallback hosts */\r\n              callback(false);\r\n            }\r\n          }\r\n          return;\r\n        }\r\n\r\n        Logger.logAction(\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.tryATransport()',\r\n          'viable transport ' + candidate + '; setting pending',\r\n        );\r\n        this.setTransportPending(transport as Transport, transportParams);\r\n        callback(null, transport);\r\n      },\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Called when a transport is indicated to be viable, and the ConnectionManager\r\n   * expects to activate this transport as soon as it is connected.\r\n   * @param transport\r\n   * @param transportParams\r\n   */\r\n  setTransportPending(transport: Transport, transportParams: TransportParams): void {\r\n    const mode = transportParams.mode;\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.setTransportPending()',\r\n      'transport = ' + transport + '; mode = ' + mode,\r\n    );\r\n\r\n    this.pendingTransport = transport;\r\n\r\n    this.cancelWebSocketSlowTimer();\r\n    this.cancelWebSocketGiveUpTimer();\r\n\r\n    transport.once('connected', (error: ErrorInfo, connectionId: string, connectionDetails: Record<string, any>) => {\r\n      this.activateTransport(error, transport, connectionId, connectionDetails);\r\n\r\n      if (mode === 'recover' && this.options.recover) {\r\n        /* After a successful recovery, we unpersist, as a recovery key cannot\r\n         * be used more than once */\r\n        delete this.options.recover;\r\n        this.unpersistConnection();\r\n      }\r\n    });\r\n\r\n    const self = this;\r\n    transport.on(['disconnected', 'closed', 'failed'], function (this: { event: string }, error: ErrorInfo) {\r\n      self.deactivateTransport(transport, this.event, error);\r\n    });\r\n\r\n    this.emit('transport.pending', transport);\r\n  }\r\n\r\n  /**\r\n   * Called when a transport is connected, and the connectionmanager decides that\r\n   * it will now be the active transport. Returns whether or not it activated\r\n   * the transport (if the connection is closing/closed it will choose not to).\r\n   * @param transport the transport instance\r\n   * @param connectionId the id of the new active connection\r\n   * @param connectionDetails the details of the new active connection\r\n   */\r\n  activateTransport(\r\n    error: ErrorInfo,\r\n    transport: Transport,\r\n    connectionId: string,\r\n    connectionDetails: Record<string, any>,\r\n  ): boolean {\r\n    Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.activateTransport()', 'transport = ' + transport);\r\n    if (error) {\r\n      Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);\r\n    }\r\n    if (connectionId) {\r\n      Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionId =  ' + connectionId);\r\n    }\r\n    if (connectionDetails) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.activateTransport()',\r\n        'connectionDetails =  ' + JSON.stringify(connectionDetails),\r\n      );\r\n    }\r\n\r\n    this.persistTransportPreference(transport);\r\n\r\n    /* if the connectionmanager moved to the closing/closed state before this\r\n     * connection event, then we won't activate this transport */\r\n    const existingState = this.state,\r\n      connectedState = this.states.connected.state;\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.activateTransport()',\r\n      'current state = ' + existingState.state,\r\n    );\r\n    if (\r\n      existingState.state == this.states.closing.state ||\r\n      existingState.state == this.states.closed.state ||\r\n      existingState.state == this.states.failed.state\r\n    ) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.activateTransport()',\r\n        'Disconnecting transport and abandoning',\r\n      );\r\n      transport.disconnect();\r\n      return false;\r\n    }\r\n\r\n    delete this.pendingTransport;\r\n\r\n    /* if the transport is not connected then don't activate it */\r\n    if (!transport.isConnected) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.activateTransport()',\r\n        'Declining to activate transport ' + transport + ' since it appears to no longer be connected',\r\n      );\r\n      return false;\r\n    }\r\n\r\n    /* the given transport is connected; this will immediately\r\n     * take over as the active transport */\r\n    const existingActiveProtocol = this.activeProtocol;\r\n    this.activeProtocol = new Protocol(transport);\r\n    this.host = transport.params.host;\r\n\r\n    const connectionKey = connectionDetails.connectionKey;\r\n    if (connectionKey && this.connectionKey != connectionKey) {\r\n      this.setConnection(connectionId, connectionDetails, !!error);\r\n    }\r\n\r\n    /* Rebroadcast any new connectionDetails from the active transport, which\r\n     * can come at any time (eg following a reauth), and emit an RTN24 UPDATE\r\n     * event. (Listener added on nextTick because we're in a transport.on('connected')\r\n     * callback at the moment; if we add it now we'll be adding it to the end\r\n     * of the listeners array and it'll be called immediately) */\r\n    this.onConnectionDetailsUpdate(connectionDetails, transport);\r\n    Platform.Config.nextTick(() => {\r\n      transport.on(\r\n        'connected',\r\n        (connectedErr: ErrorInfo, _connectionId: string, connectionDetails: Record<string, any>) => {\r\n          this.onConnectionDetailsUpdate(connectionDetails, transport);\r\n          this.emit('update', new ConnectionStateChange(connectedState, connectedState, null, connectedErr));\r\n        },\r\n      );\r\n    });\r\n\r\n    /* If previously not connected, notify the state change (including any\r\n     * error). */\r\n    if (existingState.state === this.states.connected.state) {\r\n      if (error) {\r\n        this.errorReason = this.realtime.connection.errorReason = error;\r\n        this.emit('update', new ConnectionStateChange(connectedState, connectedState, null, error));\r\n      }\r\n    } else {\r\n      this.notifyState({ state: 'connected', error: error });\r\n      this.errorReason = this.realtime.connection.errorReason = error || null;\r\n    }\r\n\r\n    /* Send after the connection state update, as Channels hooks into this to\r\n     * resend attaches on a new transport if necessary */\r\n    this.emit('transport.active', transport);\r\n\r\n    /* Gracefully terminate existing protocol */\r\n    if (existingActiveProtocol) {\r\n      if (existingActiveProtocol.messageQueue.count() > 0) {\r\n        /* We could just requeue pending messages on the new transport, but\r\n         * actually this should never happen: transports should only take over\r\n         * from other active transports when upgrading, and upgrading waits for\r\n         * the old transport to be idle. So log an error. */\r\n        Logger.logAction(\r\n          Logger.LOG_ERROR,\r\n          'ConnectionManager.activateTransport()',\r\n          'Previous active protocol (for transport ' +\r\n            existingActiveProtocol.transport.shortName +\r\n            ', new one is ' +\r\n            transport.shortName +\r\n            ') finishing with ' +\r\n            existingActiveProtocol.messageQueue.count() +\r\n            ' messages still pending',\r\n        );\r\n      }\r\n      if (existingActiveProtocol.transport === transport) {\r\n        const msg =\r\n          'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' +\r\n          transport.shortName +\r\n          '; stack = ' +\r\n          new Error().stack;\r\n        Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.activateTransport()', msg);\r\n      } else {\r\n        existingActiveProtocol.finish();\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Called when a transport is no longer the active transport. This can occur\r\n   * in any transport connection state.\r\n   * @param transport\r\n   */\r\n  deactivateTransport(transport: Transport, state: string, error: ErrorInfo): void {\r\n    const currentProtocol = this.activeProtocol,\r\n      wasActive = currentProtocol && currentProtocol.getTransport() === transport,\r\n      wasPending = transport === this.pendingTransport,\r\n      noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\r\n\r\n    Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'transport = ' + transport);\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.deactivateTransport()',\r\n      'state = ' +\r\n        state +\r\n        (wasActive ? '; was active' : wasPending ? '; was pending' : '') +\r\n        (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'),\r\n    );\r\n    if (error && error.message)\r\n      Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'reason =  ' + error.message);\r\n\r\n    if (wasActive) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.deactivateTransport()',\r\n        'Getting, clearing, and requeuing ' +\r\n          (this.activeProtocol as Protocol).messageQueue.count() +\r\n          ' pending messages',\r\n      );\r\n      this.queuePendingMessages((currentProtocol as Protocol).getPendingMessages());\r\n      /* Clear any messages we requeue to allow the protocol to become idle.*/\r\n      (currentProtocol as Protocol).clearPendingMessages();\r\n      this.activeProtocol = this.host = null;\r\n    }\r\n\r\n    this.emit('transport.inactive', transport);\r\n\r\n    /* this transport state change is a state change for the connectionmanager if\r\n     * - the transport was the active transport and there are no transports\r\n     *   which are connected and scheduled for activation, just waiting for the\r\n     *   active transport to finish what its doing; or\r\n     * - the transport was the active transport and the error was fatal (so\r\n     *   unhealable by another transport); or\r\n     * - there is no active transport, and this is the last remaining\r\n     *   pending transport (so we were in the connecting state)\r\n     */\r\n    if (\r\n      (wasActive && noTransportsScheduledForActivation) ||\r\n      (wasActive && state === 'failed') ||\r\n      state === 'closed' ||\r\n      (currentProtocol === null && wasPending)\r\n    ) {\r\n      /* If we're disconnected with a 5xx we need to try fallback hosts\r\n       * (RTN14d), but (a) due to how the upgrade sequence works, the\r\n       * host/transport selection sequence only cares about getting to\r\n       * `preconnect` (eg establishing a websocket) getting a `disconnected`\r\n       * protocol message afterwards is too late; and (b) host retry only\r\n       * applies to connectBase unless the stored preference transport doesn't\r\n       * work. We solve this by unpersisting the transport preference and\r\n       * setting an instance variable to force fallback hosts to be used (if\r\n       * any) here. Bit of a kludge, but no real better alternatives without\r\n       * rewriting the entire thing */\r\n      if (state === 'disconnected' && error && (error.statusCode as number) > 500 && this.httpHosts.length > 1) {\r\n        this.unpersistTransportPreference();\r\n        this.forceFallbackHost = true;\r\n        /* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */\r\n        this.notifyState({ state: state, error: error, retryImmediately: true });\r\n        return;\r\n      }\r\n\r\n      /* TODO remove below line once realtime sends token errors as DISCONNECTEDs */\r\n      const newConnectionState = state === 'failed' && Auth.isTokenErr(error) ? 'disconnected' : state;\r\n      this.notifyState({ state: newConnectionState, error: error });\r\n      return;\r\n    }\r\n  }\r\n\r\n  /* Helper that returns true if there are no transports which are pending,\r\n   * have been connected, and are just waiting for onceNoPending to fire before\r\n   * being activated */\r\n  noTransportsScheduledForActivation(): boolean {\r\n    return !this.pendingTransport || !this.pendingTransport.isConnected;\r\n  }\r\n\r\n  setConnection(connectionId: string, connectionDetails: Record<string, any>, hasConnectionError?: boolean): void {\r\n    /* if connectionKey changes but connectionId stays the same, then just a\r\n     * transport change on the same connection. If connectionId changes, we're\r\n     * on a new connection, with implications for msgSerial and channel state */\r\n    /* If no previous connectionId, don't reset the msgSerial as it may have\r\n     * been set by recover data (unless the recover failed) */\r\n    const prevConnId = this.connectionId,\r\n      connIdChanged = prevConnId && prevConnId !== connectionId,\r\n      recoverFailure = !prevConnId && hasConnectionError;\r\n    if (connIdChanged || recoverFailure) {\r\n      Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');\r\n      this.msgSerial = 0;\r\n      // RTN19a2: In the event of a new connectionId, previous msgSerials are\r\n      // meaningless.\r\n      this.queuedMessages.resetSendAttempted();\r\n    }\r\n    if (this.connectionId !== connectionId) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.setConnection()',\r\n        'New connectionId; reattaching any attached channels',\r\n      );\r\n    }\r\n    this.realtime.connection.id = this.connectionId = connectionId;\r\n    this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\r\n  }\r\n\r\n  clearConnection(): void {\r\n    this.realtime.connection.id = this.connectionId = undefined;\r\n    this.realtime.connection.key = this.connectionKey = undefined;\r\n    this.msgSerial = 0;\r\n    this.unpersistConnection();\r\n  }\r\n\r\n  createRecoveryKey(): string | null {\r\n    // RTN16g2.\r\n    if (!this.connectionKey) {\r\n      return null;\r\n    }\r\n\r\n    return JSON.stringify({\r\n      connectionKey: this.connectionKey,\r\n      msgSerial: this.msgSerial,\r\n      channelSerials: this.realtime.channels.channelSerials(),\r\n    });\r\n  }\r\n\r\n  checkConnectionStateFreshness(): void {\r\n    if (!this.lastActivity || !this.connectionId) {\r\n      return;\r\n    }\r\n\r\n    const sinceLast = Date.now() - this.lastActivity;\r\n    if (sinceLast > this.connectionStateTtl + (this.maxIdleInterval as number)) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.checkConnectionStateFreshness()',\r\n        'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state',\r\n      );\r\n      this.clearConnection();\r\n      this.states.connecting.failState = 'suspended';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the connectionmanager wants to persist transport\r\n   * state for later recovery. Only applicable in the browser context.\r\n   */\r\n  persistConnection(): void {\r\n    if (haveSessionStorage()) {\r\n      const recoveryKey = this.createRecoveryKey();\r\n      if (recoveryKey) {\r\n        setSessionRecoverData({\r\n          recoveryKey: recoveryKey,\r\n          disconnectedAt: Date.now(),\r\n          location: globalObject.location,\r\n          clientId: this.realtime.auth.clientId,\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called when the connectionmanager wants to persist transport\r\n   * state for later recovery. Only applicable in the browser context.\r\n   */\r\n  unpersistConnection(): void {\r\n    clearSessionRecoverData();\r\n  }\r\n\r\n  /*********************\r\n   * state management\r\n   *********************/\r\n\r\n  getError(): IPartialErrorInfo | string {\r\n    return this.errorReason || this.getStateError();\r\n  }\r\n\r\n  getStateError(): ErrorInfo {\r\n    return (ConnectionErrors as Record<string, () => ErrorInfo>)[this.state.state]?.();\r\n  }\r\n\r\n  activeState(): boolean | void {\r\n    return this.state.queueEvents || this.state.sendEvents;\r\n  }\r\n\r\n  enactStateChange(stateChange: ConnectionStateChange): void {\r\n    const action = 'Connection state';\r\n    const message = stateChange.current + (stateChange.reason ? '; reason: ' + stateChange.reason : '');\r\n    if (stateChange.current === 'failed') {\r\n      Logger.logAction(Logger.LOG_ERROR, action, message);\r\n    } else {\r\n      Logger.logAction(Logger.LOG_MAJOR, action, message);\r\n    }\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.enactStateChange',\r\n      'setting new state: ' +\r\n        stateChange.current +\r\n        '; reason = ' +\r\n        (stateChange.reason && (stateChange.reason as ErrorInfo).message),\r\n    );\r\n    const newState = (this.state = this.states[stateChange.current as string]);\r\n    if (stateChange.reason) {\r\n      this.errorReason = stateChange.reason;\r\n      // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405\r\n      this.realtime.connection.errorReason = stateChange.reason as ErrorInfo;\r\n    }\r\n    if (newState.terminal || newState.state === 'suspended') {\r\n      /* suspended is nonterminal, but once in the suspended state, realtime\r\n       * will have discarded our connection state, so futher connection\r\n       * attempts should start from scratch */\r\n      this.clearConnection();\r\n    }\r\n    this.emit('connectionstate', stateChange);\r\n  }\r\n\r\n  /****************************************\r\n   * ConnectionManager connection lifecycle\r\n   ****************************************/\r\n\r\n  startTransitionTimer(transitionState: ConnectionState): void {\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.startTransitionTimer()',\r\n      'transitionState: ' + transitionState.state,\r\n    );\r\n\r\n    if (this.transitionTimer) {\r\n      Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'clearing already-running timer');\r\n      clearTimeout(this.transitionTimer as number);\r\n    }\r\n\r\n    this.transitionTimer = setTimeout(() => {\r\n      if (this.transitionTimer) {\r\n        this.transitionTimer = null;\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager ' + transitionState.state + ' timer expired',\r\n          'requesting new state: ' + transitionState.failState,\r\n        );\r\n        this.notifyState({ state: transitionState.failState as string });\r\n      }\r\n    }, transitionState.retryDelay);\r\n  }\r\n\r\n  cancelTransitionTimer(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');\r\n    if (this.transitionTimer) {\r\n      clearTimeout(this.transitionTimer as number);\r\n      this.transitionTimer = null;\r\n    }\r\n  }\r\n\r\n  startSuspendTimer(): void {\r\n    if (this.suspendTimer) return;\r\n    this.suspendTimer = setTimeout(() => {\r\n      if (this.suspendTimer) {\r\n        this.suspendTimer = null;\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager suspend timer expired',\r\n          'requesting new state: suspended',\r\n        );\r\n        this.states.connecting.failState = 'suspended';\r\n        this.notifyState({ state: 'suspended' });\r\n      }\r\n    }, this.connectionStateTtl);\r\n  }\r\n\r\n  checkSuspendTimer(state: string): void {\r\n    if (state !== 'disconnected' && state !== 'suspended' && state !== 'connecting') this.cancelSuspendTimer();\r\n  }\r\n\r\n  cancelSuspendTimer(): void {\r\n    this.states.connecting.failState = 'disconnected';\r\n    if (this.suspendTimer) {\r\n      clearTimeout(this.suspendTimer as number);\r\n      this.suspendTimer = null;\r\n    }\r\n  }\r\n\r\n  startRetryTimer(interval: number): void {\r\n    this.retryTimer = setTimeout(() => {\r\n      Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');\r\n      this.retryTimer = null;\r\n      this.requestState({ state: 'connecting' });\r\n    }, interval);\r\n  }\r\n\r\n  cancelRetryTimer(): void {\r\n    if (this.retryTimer) {\r\n      clearTimeout(this.retryTimer as NodeJS.Timeout);\r\n      this.retryTimer = null;\r\n    }\r\n  }\r\n\r\n  startWebSocketSlowTimer() {\r\n    this.webSocketSlowTimer = setTimeout(() => {\r\n      Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager WebSocket slow timer', 'checking connectivity');\r\n      if (this.wsCheckResult === null) {\r\n        this.checkWsConnectivity()\r\n          .then(() => {\r\n            Logger.logAction(\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'ws connectivity check succeeded',\r\n            );\r\n            this.wsCheckResult = true;\r\n          })\r\n          .catch(() => {\r\n            Logger.logAction(\r\n              Logger.LOG_MAJOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'ws connectivity check failed',\r\n            );\r\n            this.wsCheckResult = false;\r\n          });\r\n      }\r\n      if (this.realtime.http.checkConnectivity) {\r\n        Utils.whenPromiseSettles(this.realtime.http.checkConnectivity(), (err, connectivity) => {\r\n          if (err || !connectivity) {\r\n            Logger.logAction(\r\n              Logger.LOG_MAJOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'http connectivity check failed',\r\n            );\r\n            this.cancelWebSocketGiveUpTimer();\r\n            this.notifyState({\r\n              state: 'disconnected',\r\n              error: new ErrorInfo(\"new ErrorInfo('Unable to connect (network unreachable)'\", 80003, 404),\r\n            });\r\n          } else {\r\n            Logger.logAction(\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager WebSocket slow timer',\r\n              'http connectivity check succeeded',\r\n            );\r\n          }\r\n        });\r\n      }\r\n    }, this.options.timeouts.webSocketSlowTimeout);\r\n  }\r\n\r\n  cancelWebSocketSlowTimer() {\r\n    if (this.webSocketSlowTimer) {\r\n      clearTimeout(this.webSocketSlowTimer);\r\n      this.webSocketSlowTimer = null;\r\n    }\r\n  }\r\n\r\n  startWebSocketGiveUpTimer(transportParams: TransportParams) {\r\n    this.webSocketGiveUpTimer = setTimeout(() => {\r\n      if (!this.wsCheckResult) {\r\n        Logger.logAction(\r\n          Logger.LOG_MINOR,\r\n          'ConnectionManager WebSocket give up timer',\r\n          'websocket connection took more than 10s; ' + (this.baseTransport ? 'trying base transport' : ''),\r\n        );\r\n        if (this.baseTransport) {\r\n          this.abandonedWebSocket = true;\r\n          this.proposedTransport?.dispose();\r\n          this.pendingTransport?.dispose();\r\n          this.connectBase(transportParams, ++this.connectCounter);\r\n        } else {\r\n          // if we don't have a base transport to fallback to, just let the websocket connection attempt time out\r\n          Logger.logAction(\r\n            Logger.LOG_MAJOR,\r\n            'ConnectionManager WebSocket give up timer',\r\n            'websocket connectivity appears to be unavailable but no other transports to try',\r\n          );\r\n        }\r\n      }\r\n    }, this.options.timeouts.webSocketConnectTimeout);\r\n  }\r\n\r\n  cancelWebSocketGiveUpTimer() {\r\n    if (this.webSocketGiveUpTimer) {\r\n      clearTimeout(this.webSocketGiveUpTimer);\r\n      this.webSocketGiveUpTimer = null;\r\n    }\r\n  }\r\n\r\n  notifyState(indicated: ConnectionState): void {\r\n    const state = indicated.state;\r\n\r\n    /* We retry immediately if:\r\n     * - something disconnects us while we're connected, or\r\n     * - a viable (but not yet active) transport fails due to a token error (so\r\n     *   this.errorReason will be set, and startConnect will do a forced\r\n     *   authorize). If this.errorReason is already set (to a token error),\r\n     *   then there has been at least one previous attempt to connect that also\r\n     *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait\r\n     *   before trying again */\r\n    const retryImmediately =\r\n      state === 'disconnected' &&\r\n      (this.state === this.states.connected ||\r\n        indicated.retryImmediately ||\r\n        (this.state === this.states.connecting &&\r\n          indicated.error &&\r\n          Auth.isTokenErr(indicated.error) &&\r\n          !(this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo))));\r\n\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.notifyState()',\r\n      'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''),\r\n    );\r\n    /* do nothing if we're already in the indicated state */\r\n    if (state == this.state.state) return;\r\n\r\n    /* kill timers (possibly excepting suspend timer depending on the notified\r\n     * state), as these are superseded by this notification */\r\n    this.cancelTransitionTimer();\r\n    this.cancelRetryTimer();\r\n    this.cancelWebSocketSlowTimer();\r\n    this.cancelWebSocketGiveUpTimer();\r\n    this.checkSuspendTimer(indicated.state);\r\n\r\n    if (state === 'suspended' || state === 'connected') {\r\n      this.disconnectedRetryCount = 0;\r\n    }\r\n\r\n    /* do nothing if we're unable to move from the current state */\r\n    if (this.state.terminal) return;\r\n\r\n    /* process new state */\r\n    const newState = this.states[indicated.state];\r\n\r\n    let retryDelay = newState.retryDelay;\r\n    if (newState.state === 'disconnected') {\r\n      this.disconnectedRetryCount++;\r\n      retryDelay = Utils.getRetryTime(newState.retryDelay as number, this.disconnectedRetryCount);\r\n    }\r\n\r\n    const change = new ConnectionStateChange(\r\n      this.state.state,\r\n      newState.state,\r\n      retryDelay,\r\n      indicated.error || (ConnectionErrors as Partial<Record<string, () => ErrorInfo>>)[newState.state]?.(),\r\n    );\r\n\r\n    if (retryImmediately) {\r\n      const autoReconnect = () => {\r\n        if (this.state === this.states.disconnected) {\r\n          this.lastAutoReconnectAttempt = Date.now();\r\n          this.requestState({ state: 'connecting' });\r\n        }\r\n      };\r\n      const sinceLast = this.lastAutoReconnectAttempt && Date.now() - this.lastAutoReconnectAttempt + 1;\r\n      if (sinceLast && sinceLast < 1000) {\r\n        Logger.logAction(\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.notifyState()',\r\n          'Last reconnect attempt was only ' +\r\n            sinceLast +\r\n            'ms ago, waiting another ' +\r\n            (1000 - sinceLast) +\r\n            'ms before trying again',\r\n        );\r\n        setTimeout(autoReconnect, 1000 - sinceLast);\r\n      } else {\r\n        Platform.Config.nextTick(autoReconnect);\r\n      }\r\n    } else if (state === 'disconnected' || state === 'suspended') {\r\n      this.startRetryTimer(retryDelay as number);\r\n    }\r\n\r\n    /* If going into disconnect/suspended (and not retrying immediately), or a\r\n     * terminal state, ensure there are no orphaned transports hanging around. */\r\n    if ((state === 'disconnected' && !retryImmediately) || state === 'suspended' || newState.terminal) {\r\n      /* Wait till the next tick so the connection state change is enacted,\r\n       * so aborting transports doesn't trigger redundant state changes */\r\n      Platform.Config.nextTick(() => {\r\n        this.disconnectAllTransports();\r\n      });\r\n    }\r\n\r\n    if (state == 'connected' && !this.activeProtocol) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'ConnectionManager.notifyState()',\r\n        'Broken invariant: attempted to go into connected state, but there is no active protocol',\r\n      );\r\n    }\r\n\r\n    /* implement the change and notify */\r\n    this.enactStateChange(change);\r\n    if (this.state.sendEvents) {\r\n      this.sendQueuedMessages();\r\n    } else if (!this.state.queueEvents) {\r\n      this.realtime.channels.propogateConnectionInterruption(state, change.reason);\r\n      this.failQueuedMessages(change.reason as ErrorInfo); // RTN7c\r\n    }\r\n  }\r\n\r\n  requestState(request: any): void {\r\n    const state = request.state;\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'ConnectionManager.requestState()',\r\n      'requested state: ' + state + '; current state: ' + this.state.state,\r\n    );\r\n    if (state == this.state.state) return; /* silently do nothing */\r\n\r\n    /* kill running timers, as this request supersedes them */\r\n    this.cancelWebSocketSlowTimer();\r\n    this.cancelWebSocketGiveUpTimer();\r\n    this.cancelTransitionTimer();\r\n    this.cancelRetryTimer();\r\n    /* for suspend timer check rather than cancel -- eg requesting a connecting\r\n     * state should not reset the suspend timer */\r\n    this.checkSuspendTimer(state);\r\n\r\n    if (state == 'connecting' && this.state.state == 'connected') return;\r\n    if (state == 'closing' && this.state.state == 'closed') return;\r\n\r\n    const newState = this.states[state],\r\n      change = new ConnectionStateChange(\r\n        this.state.state,\r\n        newState.state,\r\n        null,\r\n        request.error || (ConnectionErrors as Partial<Record<string, () => ErrorInfo>>)[newState.state]?.(),\r\n      );\r\n\r\n    this.enactStateChange(change);\r\n\r\n    if (state == 'connecting') {\r\n      Platform.Config.nextTick(() => {\r\n        this.startConnect();\r\n      });\r\n    }\r\n    if (state == 'closing') {\r\n      this.closeImpl();\r\n    }\r\n  }\r\n\r\n  startConnect(): void {\r\n    if (this.state !== this.states.connecting) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.startConnect()',\r\n        'Must be in connecting state to connect, but was ' + this.state.state,\r\n      );\r\n      return;\r\n    }\r\n\r\n    const auth = this.realtime.auth;\r\n\r\n    /* The point of the connectCounter mechanism is to ensure that the\r\n     * connection procedure can be cancelled. We want disconnectAllTransports\r\n     * to be able to stop any in-progress connection, even before it gets to\r\n     * the stage of having a pending (or even a proposed) transport that it can\r\n     * dispose() of. So we check that it's still current after any async stage,\r\n     * up until the stage that is synchronous with instantiating a transport */\r\n    const connectCount = ++this.connectCounter;\r\n\r\n    const connect = () => {\r\n      this.checkConnectionStateFreshness();\r\n      this.getTransportParams((transportParams: TransportParams) => {\r\n        if (transportParams.mode === 'recover' && transportParams.options.recover) {\r\n          const recoveryContext = decodeRecoveryKey(transportParams.options.recover);\r\n          if (recoveryContext) {\r\n            this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\r\n          }\r\n        }\r\n\r\n        if (connectCount !== this.connectCounter) {\r\n          return;\r\n        }\r\n        this.connectImpl(transportParams, connectCount);\r\n      });\r\n    };\r\n\r\n    Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');\r\n    this.startSuspendTimer();\r\n    this.startTransitionTimer(this.states.connecting);\r\n\r\n    if (auth.method === 'basic') {\r\n      connect();\r\n    } else {\r\n      const authCb = (err: ErrorInfo | null) => {\r\n        if (connectCount !== this.connectCounter) {\r\n          return;\r\n        }\r\n        if (err) {\r\n          this.actOnErrorFromAuthorize(err);\r\n        } else {\r\n          connect();\r\n        }\r\n      };\r\n      if (this.errorReason && Auth.isTokenErr(this.errorReason as ErrorInfo)) {\r\n        /* Force a refetch of a new token */\r\n        Utils.whenPromiseSettles(auth._forceNewToken(null, null), authCb);\r\n      } else {\r\n        Utils.whenPromiseSettles(auth._ensureValidAuthCredentials(false), authCb);\r\n      }\r\n    }\r\n  }\r\n\r\n  /*\r\n   * there are, at most, two transports available with which a connection may\r\n   * be attempted: web_socket and/or a base transport (xhr_polling in browsers,\r\n   * comet in nodejs). web_socket is always preferred, and the base transport is\r\n   * only used in case web_socket connectivity appears to be unavailable.\r\n   *\r\n   * connectImpl begins the transport selection process by checking which transports\r\n   * are available, and if there is a cached preference. It then defers to the\r\n   * transport-specific connect methods: connectWs and connectBase.\r\n   *\r\n   * It is also responsible for invalidating the cache in the case that a base\r\n   * transport preference is stored but web socket connectivity is now available.\r\n   *\r\n   * handling of the case where we need to failover from web_socket to the base\r\n   * transport is implemented in the connectWs method.\r\n   */\r\n  connectImpl(transportParams: TransportParams, connectCount: number): void {\r\n    const state = this.state.state;\r\n    if (state !== this.states.connecting.state) {\r\n      /* Only keep trying as long as in the 'connecting' state (or 'connected'\r\n       * for upgrading). Any operation can put us into 'disconnected' to cancel\r\n       * connection attempts and wait before retrying, or 'failed' to fail. */\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'ConnectionManager.connectImpl()',\r\n        'Must be in connecting state to connect, but was ' + state,\r\n      );\r\n      return;\r\n    }\r\n\r\n    const transportPreference = this.getTransportPreference();\r\n\r\n    // If transport preference is for a non-ws transport but websocket is now available, unpersist the preference for next time\r\n    if (transportPreference && transportPreference === this.baseTransport && this.webSocketTransportAvailable) {\r\n      this.checkWsConnectivity()\r\n        .then(() => {\r\n          this.wsCheckResult = true;\r\n          this.abandonedWebSocket = false;\r\n          this.unpersistTransportPreference();\r\n          if (this.state === this.states.connecting) {\r\n            Logger.logAction(\r\n              Logger.LOG_MINOR,\r\n              'ConnectionManager.connectImpl():',\r\n              'web socket connectivity available, cancelling connection attempt with ' + this.baseTransport,\r\n            );\r\n            this.disconnectAllTransports();\r\n            this.connectWs(transportParams, ++this.connectCounter);\r\n          }\r\n        })\r\n        .catch(noop);\r\n    }\r\n\r\n    if (\r\n      (transportPreference && transportPreference === this.baseTransport) ||\r\n      (this.baseTransport && !this.webSocketTransportAvailable)\r\n    ) {\r\n      this.connectBase(transportParams, connectCount);\r\n    } else {\r\n      this.connectWs(transportParams, connectCount);\r\n    }\r\n  }\r\n\r\n  /*\r\n   * connectWs starts two timers to monitor the success of a web_socket connection attempt:\r\n   * - webSocketSlowTimer: if this timer fires before the connection succeeds,\r\n   *   cm will simultaneously check websocket and http/xhr connectivity. if the http\r\n   *   connectivity check fails, we give up the connection sequence entirely and\r\n   *   transition to disconnected. if the websocket connectivity check fails then\r\n   *   we assume no ws connectivity and failover to base transport. in the case that\r\n   *   the checks succeed, we continue with websocket and wait for it to try fallback hosts\r\n   *   and, if unsuccessful, ultimately transition to disconnected.\r\n   * - webSocketGiveUpTimer: if this timer fires, and the preceding websocket\r\n   *   connectivity check is still pending then we assume that there is an issue\r\n   *   with the transport and fallback to base transport.\r\n   */\r\n  connectWs(transportParams: TransportParams, connectCount: number) {\r\n    Logger.logAction(Logger.LOG_DEBUG, 'ConnectionManager.connectWs()');\r\n    this.startWebSocketSlowTimer();\r\n    this.startWebSocketGiveUpTimer(transportParams);\r\n\r\n    this.tryTransportWithFallbacks('web_socket', transportParams, true, connectCount, () => {\r\n      return this.wsCheckResult !== false && !this.abandonedWebSocket;\r\n    });\r\n  }\r\n\r\n  connectBase(transportParams: TransportParams, connectCount: number) {\r\n    Logger.logAction(Logger.LOG_DEBUG, 'ConnectionManager.connectBase()');\r\n    if (this.baseTransport) {\r\n      this.tryTransportWithFallbacks(this.baseTransport, transportParams, false, connectCount, () => true);\r\n    } else {\r\n      this.notifyState({\r\n        state: 'disconnected',\r\n        error: new ErrorInfo('No transports left to try', 80000, 404),\r\n      });\r\n    }\r\n  }\r\n\r\n  tryTransportWithFallbacks(\r\n    transportName: TransportName,\r\n    transportParams: TransportParams,\r\n    ws: boolean,\r\n    connectCount: number,\r\n    shouldContinue: () => boolean,\r\n  ): void {\r\n    Logger.logAction(Logger.LOG_DEBUG, 'ConnectionManager.tryTransportWithFallbacks()', transportName);\r\n    const giveUp = (err: IPartialErrorInfo) => {\r\n      this.notifyState({ state: this.states.connecting.failState as string, error: err });\r\n    };\r\n\r\n    const candidateHosts = ws ? this.wsHosts.slice() : this.httpHosts.slice();\r\n\r\n    const hostAttemptCb = (fatal: boolean, transport: Transport) => {\r\n      if (connectCount !== this.connectCounter) {\r\n        return;\r\n      }\r\n      if (!shouldContinue()) {\r\n        if (transport) {\r\n          transport.dispose();\r\n        }\r\n        return;\r\n      }\r\n      if (!transport && !fatal) {\r\n        tryFallbackHosts();\r\n      }\r\n    };\r\n\r\n    /* first try to establish a connection with the priority host with http transport */\r\n    const host = candidateHosts.shift();\r\n    if (!host) {\r\n      giveUp(new ErrorInfo('Unable to connect (no available host)', 80003, 404));\r\n      return;\r\n    }\r\n    transportParams.host = host;\r\n\r\n    /* this is what we'll be doing if the attempt for the main host fails */\r\n    const tryFallbackHosts = () => {\r\n      /* if there aren't any fallback hosts, fail */\r\n      if (!candidateHosts.length) {\r\n        giveUp(new ErrorInfo('Unable to connect (and no more fallback hosts to try)', 80003, 404));\r\n        return;\r\n      }\r\n      /* before trying any fallback (or any remaining fallback) we decide if\r\n       * there is a problem with the ably host, or there is a general connectivity\r\n       * problem */\r\n      if (!this.realtime.http.checkConnectivity) {\r\n        giveUp(new PartialErrorInfo('Internal error: Http.checkConnectivity not set', null, 500));\r\n        return;\r\n      }\r\n      Utils.whenPromiseSettles(\r\n        this.realtime.http.checkConnectivity(),\r\n        (err?: ErrorInfo | null, connectivity?: boolean) => {\r\n          if (connectCount !== this.connectCounter) {\r\n            return;\r\n          }\r\n          if (!shouldContinue()) {\r\n            return;\r\n          }\r\n          /* we know err won't happen but handle it here anyway */\r\n          if (err) {\r\n            giveUp(err);\r\n            return;\r\n          }\r\n          if (!connectivity) {\r\n            /* the internet isn't reachable, so don't try the fallback hosts */\r\n            giveUp(new ErrorInfo('Unable to connect (network unreachable)', 80003, 404));\r\n            return;\r\n          }\r\n          /* the network is there, so there's a problem with the main host, or\r\n           * its dns. Try the fallback hosts. We could try them simultaneously but\r\n           * that would potentially cause a huge spike in load on the load balancer */\r\n          transportParams.host = Utils.arrPopRandomElement(candidateHosts);\r\n          this.tryATransport(transportParams, transportName, hostAttemptCb);\r\n        },\r\n      );\r\n    };\r\n\r\n    if (this.forceFallbackHost && candidateHosts.length) {\r\n      this.forceFallbackHost = false;\r\n      tryFallbackHosts();\r\n      return;\r\n    }\r\n\r\n    this.tryATransport(transportParams, transportName, hostAttemptCb);\r\n  }\r\n\r\n  closeImpl(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');\r\n    this.cancelSuspendTimer();\r\n    this.startTransitionTimer(this.states.closing);\r\n\r\n    if (this.pendingTransport) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.closeImpl()',\r\n        'Closing pending transport: ' + this.pendingTransport,\r\n      );\r\n      this.pendingTransport.close();\r\n    }\r\n\r\n    if (this.activeProtocol) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.closeImpl()',\r\n        'Closing active transport: ' + this.activeProtocol.getTransport(),\r\n      );\r\n      this.activeProtocol.getTransport().close();\r\n    }\r\n\r\n    /* If there was an active transport, this will probably be\r\n     * preempted by the notifyState call in deactivateTransport */\r\n    this.notifyState({ state: 'closed' });\r\n  }\r\n\r\n  onAuthUpdated(tokenDetails: API.TokenDetails, callback: Function): void {\r\n    switch (this.state.state) {\r\n      case 'connected': {\r\n        Logger.logAction(\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.onAuthUpdated()',\r\n          'Sending AUTH message on active transport',\r\n        );\r\n\r\n        /* Do any transport-specific new-token action */\r\n        const activeTransport = this.activeProtocol?.getTransport();\r\n        if (activeTransport && activeTransport.onAuthUpdated) {\r\n          activeTransport.onAuthUpdated(tokenDetails);\r\n        }\r\n\r\n        const authMsg = protocolMessageFromValues({\r\n          action: actions.AUTH,\r\n          auth: {\r\n            accessToken: tokenDetails.token,\r\n          },\r\n        });\r\n        this.send(authMsg);\r\n\r\n        /* The answer will come back as either a connectiondetails event\r\n         * (realtime sends a CONNECTED to acknowledge the reauth) or a\r\n         * statechange to failed */\r\n        const successListener = () => {\r\n          this.off(failureListener);\r\n          callback(null, tokenDetails);\r\n        };\r\n        const failureListener = (stateChange: ConnectionStateChange) => {\r\n          if (stateChange.current === 'failed') {\r\n            this.off(successListener);\r\n            this.off(failureListener);\r\n            callback(stateChange.reason || this.getStateError());\r\n          }\r\n        };\r\n        this.once('connectiondetails', successListener);\r\n        this.on('connectionstate', failureListener);\r\n        break;\r\n      }\r\n\r\n      case 'connecting':\r\n        Logger.logAction(\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.onAuthUpdated()',\r\n          'Aborting current connection attempts in order to start again with the new auth details',\r\n        );\r\n        this.disconnectAllTransports();\r\n      /* fallthrough to add statechange listener */\r\n\r\n      default: {\r\n        Logger.logAction(\r\n          Logger.LOG_MICRO,\r\n          'ConnectionManager.onAuthUpdated()',\r\n          'Connection state is ' + this.state.state + '; waiting until either connected or failed',\r\n        );\r\n        const listener = (stateChange: ConnectionStateChange) => {\r\n          switch (stateChange.current) {\r\n            case 'connected':\r\n              this.off(listener);\r\n              callback(null, tokenDetails);\r\n              break;\r\n            case 'failed':\r\n            case 'closed':\r\n            case 'suspended':\r\n              this.off(listener);\r\n              callback(stateChange.reason || this.getStateError());\r\n              break;\r\n            default:\r\n              /* ignore till we get either connected or failed */\r\n              break;\r\n          }\r\n        };\r\n        this.on('connectionstate', listener);\r\n        if (this.state.state === 'connecting') {\r\n          /* can happen if in the connecting state but no transport was pending\r\n           * yet, so disconnectAllTransports did not trigger a disconnected state */\r\n          this.startConnect();\r\n        } else {\r\n          this.requestState({ state: 'connecting' });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  disconnectAllTransports(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting all transports');\r\n\r\n    /* This will prevent any connection procedure in an async part of one of its early stages from continuing */\r\n    this.connectCounter++;\r\n\r\n    if (this.pendingTransport) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.disconnectAllTransports()',\r\n        'Disconnecting pending transport: ' + this.pendingTransport,\r\n      );\r\n      this.pendingTransport.disconnect();\r\n    }\r\n    delete this.pendingTransport;\r\n\r\n    if (this.proposedTransport) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.disconnectAllTransports()',\r\n        'Disconnecting proposed transport: ' + this.pendingTransport,\r\n      );\r\n      this.proposedTransport.disconnect();\r\n    }\r\n    delete this.pendingTransport;\r\n\r\n    if (this.activeProtocol) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.disconnectAllTransports()',\r\n        'Disconnecting active transport: ' + this.activeProtocol.getTransport(),\r\n      );\r\n      this.activeProtocol.getTransport().disconnect();\r\n    }\r\n    /* No need to notify state disconnected; disconnecting the active transport\r\n     * will have that effect */\r\n  }\r\n\r\n  /******************\r\n   * event queueing\r\n   ******************/\r\n\r\n  send(msg: ProtocolMessage, queueEvent?: boolean, callback?: ErrCallback): void {\r\n    callback = callback || noop;\r\n    const state = this.state;\r\n\r\n    if (state.sendEvents) {\r\n      Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.send()', 'sending event');\r\n      this.sendImpl(new PendingMessage(msg, callback));\r\n      return;\r\n    }\r\n    const shouldQueue = queueEvent && state.queueEvents;\r\n    if (!shouldQueue) {\r\n      const err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;\r\n      Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.send()', err);\r\n      callback(this.errorReason || new ErrorInfo(err, 90000, 400));\r\n      return;\r\n    }\r\n    if (Logger.shouldLog(Logger.LOG_MICRO)) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.send()',\r\n        'queueing msg; ' + stringifyProtocolMessage(msg, this.realtime._RealtimePresence),\r\n      );\r\n    }\r\n    this.queue(msg, callback);\r\n  }\r\n\r\n  sendImpl(pendingMessage: PendingMessage): void {\r\n    const msg = pendingMessage.message;\r\n    /* If have already attempted to send this, resend with the same msgSerial,\r\n     * so Ably can dedup if the previous send succeeded */\r\n    if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\r\n      msg.msgSerial = this.msgSerial++;\r\n    }\r\n    try {\r\n      (this.activeProtocol as Protocol).send(pendingMessage);\r\n    } catch (e) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'ConnectionManager.sendImpl()',\r\n        'Unexpected exception in transport.send(): ' + (e as Error).stack,\r\n      );\r\n    }\r\n  }\r\n\r\n  queue(msg: ProtocolMessage, callback: ErrCallback): void {\r\n    Logger.logAction(Logger.LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');\r\n    const lastQueued = this.queuedMessages.last();\r\n    const maxSize = this.options.maxMessageSize;\r\n    /* If have already attempted to send a message, don't merge more messages\r\n     * into it, as if the previous send actually succeeded and realtime ignores\r\n     * the dup, they'll be lost */\r\n    if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {\r\n      if (!lastQueued.merged) {\r\n        lastQueued.callback = Multicaster.create([lastQueued.callback]);\r\n        lastQueued.merged = true;\r\n      }\r\n      (lastQueued.callback as MulticasterInstance<void>).push(callback);\r\n    } else {\r\n      this.queuedMessages.push(new PendingMessage(msg, callback));\r\n    }\r\n  }\r\n\r\n  sendQueuedMessages(): void {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'ConnectionManager.sendQueuedMessages()',\r\n      'sending ' + this.queuedMessages.count() + ' queued messages',\r\n    );\r\n    let pendingMessage;\r\n    while ((pendingMessage = this.queuedMessages.shift())) this.sendImpl(pendingMessage);\r\n  }\r\n\r\n  queuePendingMessages(pendingMessages: Array<PendingMessage>): void {\r\n    if (pendingMessages && pendingMessages.length) {\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'ConnectionManager.queuePendingMessages()',\r\n        'queueing ' + pendingMessages.length + ' pending messages',\r\n      );\r\n      this.queuedMessages.prepend(pendingMessages);\r\n    }\r\n  }\r\n\r\n  failQueuedMessages(err: ErrorInfo): void {\r\n    const numQueued = this.queuedMessages.count();\r\n    if (numQueued > 0) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'ConnectionManager.failQueuedMessages()',\r\n        'failing ' + numQueued + ' queued messages, err = ' + Utils.inspectError(err),\r\n      );\r\n      this.queuedMessages.completeAllMessages(err);\r\n    }\r\n  }\r\n\r\n  onChannelMessage(message: ProtocolMessage, transport: Transport): void {\r\n    this.pendingChannelMessagesState.queue.push({ message, transport });\r\n\r\n    if (!this.pendingChannelMessagesState.isProcessing) {\r\n      this.processNextPendingChannelMessage();\r\n    }\r\n  }\r\n\r\n  private processNextPendingChannelMessage() {\r\n    if (this.pendingChannelMessagesState.queue.length > 0) {\r\n      this.pendingChannelMessagesState.isProcessing = true;\r\n\r\n      const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift()!;\r\n      this.processChannelMessage(pendingChannelMessage.message)\r\n        .catch((err) => {\r\n          Logger.logAction(\r\n            Logger.LOG_ERROR,\r\n            'ConnectionManager.processNextPendingChannelMessage() received error ',\r\n            err,\r\n          );\r\n        })\r\n        .finally(() => {\r\n          this.pendingChannelMessagesState.isProcessing = false;\r\n          this.processNextPendingChannelMessage();\r\n        });\r\n    }\r\n  }\r\n\r\n  private async processChannelMessage(message: ProtocolMessage) {\r\n    await this.realtime.channels.processChannelMessage(message);\r\n  }\r\n\r\n  ping(transport: Transport | null, callback: Function): void {\r\n    /* if transport is specified, try that */\r\n    if (transport) {\r\n      Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);\r\n\r\n      const onTimeout = function () {\r\n        transport.off('heartbeat', onHeartbeat);\r\n        callback(new ErrorInfo('Timeout waiting for heartbeat response', 50000, 500));\r\n      };\r\n\r\n      const pingStart = Date.now(),\r\n        id = Utils.cheapRandStr();\r\n\r\n      const onHeartbeat = function (responseId: string) {\r\n        if (responseId === id) {\r\n          transport.off('heartbeat', onHeartbeat);\r\n          clearTimeout(timer);\r\n          const responseTime = Date.now() - pingStart;\r\n          callback(null, responseTime);\r\n        }\r\n      };\r\n\r\n      const timer = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);\r\n\r\n      transport.on('heartbeat', onHeartbeat);\r\n      transport.ping(id);\r\n      return;\r\n    }\r\n\r\n    /* if we're not connected, don't attempt */\r\n    if (this.state.state !== 'connected') {\r\n      callback(new ErrorInfo('Unable to ping service; not connected', 40000, 400));\r\n      return;\r\n    }\r\n\r\n    /* no transport was specified, so use the current (connected) one\r\n     * but ensure that we retry if the transport is superseded before we complete */\r\n    let completed = false;\r\n\r\n    const onPingComplete = (err: Error, responseTime: number) => {\r\n      this.off('transport.active', onTransportActive);\r\n      if (!completed) {\r\n        completed = true;\r\n        callback(err, responseTime);\r\n      }\r\n    };\r\n\r\n    const onTransportActive = () => {\r\n      if (!completed) {\r\n        /* ensure that no callback happens for the currently outstanding operation */\r\n        completed = true;\r\n        /* repeat but picking up the new transport */\r\n        Platform.Config.nextTick(() => {\r\n          this.ping(null, callback);\r\n        });\r\n      }\r\n    };\r\n\r\n    this.on('transport.active', onTransportActive);\r\n    this.ping((this.activeProtocol as Protocol).getTransport(), onPingComplete);\r\n  }\r\n\r\n  abort(error: ErrorInfo): void {\r\n    (this.activeProtocol as Protocol).getTransport().fail(error);\r\n  }\r\n\r\n  getTransportPreference(): TransportName {\r\n    return this.transportPreference || (haveWebStorage() && Platform.WebStorage?.get?.(transportPreferenceName));\r\n  }\r\n\r\n  persistTransportPreference(transport: Transport): void {\r\n    this.transportPreference = transport.shortName;\r\n    if (haveWebStorage()) {\r\n      Platform.WebStorage?.set?.(transportPreferenceName, transport.shortName);\r\n    }\r\n  }\r\n\r\n  unpersistTransportPreference(): void {\r\n    this.transportPreference = null;\r\n    if (haveWebStorage()) {\r\n      Platform.WebStorage?.remove?.(transportPreferenceName);\r\n    }\r\n  }\r\n\r\n  /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\r\n   * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\r\n   * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\r\n   * server returns 403. */\r\n  actOnErrorFromAuthorize(err: ErrorInfo): void {\r\n    if (err.code === 40171) {\r\n      /* No way to reauth */\r\n      this.notifyState({ state: 'failed', error: err });\r\n    } else if (err.code === 40102) {\r\n      this.notifyState({ state: 'failed', error: err });\r\n    } else if (err.statusCode === HttpStatusCodes.Forbidden) {\r\n      const msg = 'Client configured authentication provider returned 403; failing the connection';\r\n      Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);\r\n      this.notifyState({ state: 'failed', error: new ErrorInfo(msg, 80019, 403, err) });\r\n    } else {\r\n      const msg = 'Client configured authentication provider request failed';\r\n      Logger.logAction(Logger.LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);\r\n      this.notifyState({ state: this.state.failState as string, error: new ErrorInfo(msg, 80019, 401, err) });\r\n    }\r\n  }\r\n\r\n  onConnectionDetailsUpdate(connectionDetails: Record<string, any>, transport: Transport): void {\r\n    if (!connectionDetails) {\r\n      return;\r\n    }\r\n    this.connectionDetails = connectionDetails;\r\n    if (connectionDetails.maxMessageSize) {\r\n      this.options.maxMessageSize = connectionDetails.maxMessageSize;\r\n    }\r\n    const clientId = connectionDetails.clientId;\r\n    if (clientId) {\r\n      const err = this.realtime.auth._uncheckedSetClientId(clientId);\r\n      if (err) {\r\n        Logger.logAction(Logger.LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);\r\n        /* Errors setting the clientId are fatal to the connection */\r\n        transport.fail(err);\r\n        return;\r\n      }\r\n    }\r\n    const connectionStateTtl = connectionDetails.connectionStateTtl;\r\n    if (connectionStateTtl) {\r\n      this.connectionStateTtl = connectionStateTtl;\r\n    }\r\n    this.maxIdleInterval = connectionDetails.maxIdleInterval;\r\n    this.emit('connectiondetails', connectionDetails);\r\n  }\r\n\r\n  checkWsConnectivity() {\r\n    const ws = new Platform.Config.WebSocket(Defaults.wsConnectivityUrl);\r\n    return new Promise<void>((resolve, reject) => {\r\n      let finished = false;\r\n      ws.onopen = () => {\r\n        if (!finished) {\r\n          finished = true;\r\n          resolve();\r\n          ws.close();\r\n        }\r\n      };\r\n\r\n      ws.onclose = ws.onerror = () => {\r\n        if (!finished) {\r\n          finished = true;\r\n          reject();\r\n        }\r\n      };\r\n    });\r\n  }\r\n}\r\n\r\nexport default ConnectionManager;\r\n\r\nexport interface TransportStorage {\r\n  supportedTransports: Partial<Record<TransportName, TransportCtor>>;\r\n}\r\n","import EventEmitter from '../util/eventemitter';\r\nimport ConnectionManager from '../transport/connectionmanager';\r\nimport Logger from '../util/logger';\r\nimport ConnectionStateChange from './connectionstatechange';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport { NormalisedClientOptions } from '../../types/ClientOptions';\r\nimport BaseRealtime from './baserealtime';\r\nimport Platform from 'common/platform';\r\n\r\nclass Connection extends EventEmitter {\r\n  ably: BaseRealtime;\r\n  connectionManager: ConnectionManager;\r\n  state: string;\r\n  key?: string;\r\n  id?: string;\r\n  errorReason: ErrorInfo | null;\r\n\r\n  constructor(ably: BaseRealtime, options: NormalisedClientOptions) {\r\n    super();\r\n    this.ably = ably;\r\n    this.connectionManager = new ConnectionManager(ably, options);\r\n    this.state = this.connectionManager.state.state;\r\n    this.key = undefined;\r\n    this.id = undefined;\r\n    this.errorReason = null;\r\n\r\n    this.connectionManager.on('connectionstate', (stateChange: ConnectionStateChange) => {\r\n      const state = (this.state = stateChange.current as string);\r\n      Platform.Config.nextTick(() => {\r\n        this.emit(state, stateChange);\r\n      });\r\n    });\r\n    this.connectionManager.on('update', (stateChange: ConnectionStateChange) => {\r\n      Platform.Config.nextTick(() => {\r\n        this.emit('update', stateChange);\r\n      });\r\n    });\r\n  }\r\n\r\n  whenState = ((state: string) => {\r\n    return EventEmitter.prototype.whenState.call(this, state, this.state);\r\n  }) as any;\r\n\r\n  connect(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Connection.connect()', '');\r\n    this.connectionManager.requestState({ state: 'connecting' });\r\n  }\r\n\r\n  async ping(): Promise<number> {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Connection.ping()', '');\r\n    return new Promise((resolve, reject) => {\r\n      this.connectionManager.ping(null, (err: unknown, result: number) => (err ? reject(err) : resolve(result)));\r\n    });\r\n  }\r\n\r\n  close(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);\r\n    this.connectionManager.requestState({ state: 'closing' });\r\n  }\r\n\r\n  get recoveryKey(): string | null {\r\n    Logger.deprecationWarning(\r\n      'The `Connection.recoveryKey` attribute has been replaced by the `Connection.createRecoveryKey()` method. Replace your usage of `recoveryKey` with the return value of `createRecoveryKey()`. `recoveryKey` will be removed in a future version.',\r\n    );\r\n    return this.createRecoveryKey();\r\n  }\r\n\r\n  createRecoveryKey(): string | null {\r\n    return this.connectionManager.createRecoveryKey();\r\n  }\r\n}\r\n\r\nexport default Connection;\r\n","import ErrorInfo from '../types/errorinfo';\r\n\r\nclass ChannelStateChange {\r\n  previous: string;\r\n  current: string;\r\n  resumed?: boolean;\r\n  reason?: string | Error | ErrorInfo;\r\n  hasBacklog?: boolean;\r\n\r\n  constructor(\r\n    previous: string,\r\n    current: string,\r\n    resumed?: boolean,\r\n    hasBacklog?: boolean,\r\n    reason?: string | Error | ErrorInfo | null,\r\n  ) {\r\n    this.previous = previous;\r\n    this.current = current;\r\n    if (current === 'attached') {\r\n      this.resumed = resumed;\r\n      this.hasBacklog = hasBacklog;\r\n    }\r\n    if (reason) this.reason = reason;\r\n  }\r\n}\r\n\r\nexport default ChannelStateChange;\r\n","import ProtocolMessage, {\r\n  actions,\r\n  channelModes,\r\n  fromValues as protocolMessageFromValues,\r\n} from '../types/protocolmessage';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport * as Utils from '../util/utils';\r\nimport Logger from '../util/logger';\r\nimport RealtimePresence from './realtimepresence';\r\nimport Message, {\r\n  fromValues as messageFromValues,\r\n  fromValuesArray as messagesFromValuesArray,\r\n  encodeArray as encodeMessagesArray,\r\n  decode as decodeMessage,\r\n  getMessagesSize,\r\n  CipherOptions,\r\n  EncodingDecodingContext,\r\n} from '../types/message';\r\nimport ChannelStateChange from './channelstatechange';\r\nimport ErrorInfo, { PartialErrorInfo } from '../types/errorinfo';\r\nimport PresenceMessage, { decode as decodePresenceMessage } from '../types/presencemessage';\r\nimport ConnectionErrors from '../transport/connectionerrors';\r\nimport * as API from '../../../../ably';\r\nimport ConnectionManager from '../transport/connectionmanager';\r\nimport ConnectionStateChange from './connectionstatechange';\r\nimport { ErrCallback, StandardCallback } from '../../types/utils';\r\nimport BaseRealtime from './baserealtime';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport { normaliseChannelOptions } from '../util/defaults';\r\nimport { PaginatedResult } from './paginatedresource';\r\n\r\ninterface RealtimeHistoryParams {\r\n  start?: number;\r\n  end?: number;\r\n  direction?: string;\r\n  limit?: number;\r\n  untilAttach?: boolean;\r\n  from_serial?: string;\r\n}\r\n\r\nconst noop = function () {};\r\n\r\nfunction validateChannelOptions(options?: API.ChannelOptions) {\r\n  if (options && 'params' in options && !Utils.isObject(options.params)) {\r\n    return new ErrorInfo('options.params must be an object', 40000, 400);\r\n  }\r\n  if (options && 'modes' in options) {\r\n    if (!Array.isArray(options.modes)) {\r\n      return new ErrorInfo('options.modes must be an array', 40000, 400);\r\n    }\r\n    for (let i = 0; i < options.modes.length; i++) {\r\n      const currentMode = options.modes[i];\r\n      if (\r\n        !currentMode ||\r\n        typeof currentMode !== 'string' ||\r\n        !channelModes.includes(String.prototype.toUpperCase.call(currentMode))\r\n      ) {\r\n        return new ErrorInfo('Invalid channel mode: ' + currentMode, 40000, 400);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass RealtimeChannel extends EventEmitter {\r\n  name: string;\r\n  channelOptions: ChannelOptions;\r\n  client: BaseRealtime;\r\n  private _presence: RealtimePresence | null;\r\n  get presence(): RealtimePresence {\r\n    if (!this._presence) {\r\n      Utils.throwMissingPluginError('RealtimePresence');\r\n    }\r\n    return this._presence;\r\n  }\r\n  connectionManager: ConnectionManager;\r\n  state: API.ChannelState;\r\n  subscriptions: EventEmitter;\r\n  filteredSubscriptions?: Map<API.messageCallback<Message>, Map<API.MessageFilter, API.messageCallback<Message>[]>>;\r\n  syncChannelSerial?: string | null;\r\n  properties: {\r\n    attachSerial: string | null | undefined;\r\n    channelSerial: string | null | undefined;\r\n  };\r\n  errorReason: ErrorInfo | string | null;\r\n  _requestedFlags: Array<API.ChannelMode> | null;\r\n  _mode?: null | number;\r\n  _attachResume: boolean;\r\n  _decodingContext: EncodingDecodingContext;\r\n  _lastPayload: {\r\n    messageId?: string | null;\r\n    protocolMessageChannelSerial?: string | null;\r\n    decodeFailureRecoveryInProgress: null | boolean;\r\n  };\r\n  _allChannelChanges: EventEmitter;\r\n  params?: Record<string, any>;\r\n  modes: string[] | undefined;\r\n  stateTimer?: number | NodeJS.Timeout | null;\r\n  retryTimer?: number | NodeJS.Timeout | null;\r\n  retryCount: number = 0;\r\n\r\n  constructor(client: BaseRealtime, name: string, options?: API.ChannelOptions) {\r\n    super();\r\n    Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);\r\n    this.name = name;\r\n    this.channelOptions = normaliseChannelOptions(client._Crypto ?? null, options);\r\n    this.client = client;\r\n    this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;\r\n    this.connectionManager = client.connection.connectionManager;\r\n    this.state = 'initialized';\r\n    this.subscriptions = new EventEmitter();\r\n    this.syncChannelSerial = undefined;\r\n    this.properties = {\r\n      attachSerial: undefined,\r\n      channelSerial: undefined,\r\n    };\r\n    this.setOptions(options);\r\n    this.errorReason = null;\r\n    this._requestedFlags = null;\r\n    this._mode = null;\r\n    this._attachResume = false;\r\n    this._decodingContext = {\r\n      channelOptions: this.channelOptions,\r\n      plugins: client.options.plugins || {},\r\n      baseEncodedPreviousPayload: undefined,\r\n    };\r\n    this._lastPayload = {\r\n      messageId: null,\r\n      protocolMessageChannelSerial: null,\r\n      decodeFailureRecoveryInProgress: null,\r\n    };\r\n    /* Only differences between this and the public event emitter is that this emits an\r\n     * update event for all ATTACHEDs, whether resumed or not */\r\n    this._allChannelChanges = new EventEmitter();\r\n  }\r\n\r\n  invalidStateError(): ErrorInfo {\r\n    return new ErrorInfo(\r\n      'Channel operation failed as channel state is ' + this.state,\r\n      90001,\r\n      400,\r\n      this.errorReason || undefined,\r\n    );\r\n  }\r\n\r\n  static processListenerArgs(args: unknown[]): any[] {\r\n    /* [event], listener */\r\n    args = Array.prototype.slice.call(args);\r\n    if (typeof args[0] === 'function') {\r\n      args.unshift(null);\r\n    }\r\n    return args;\r\n  }\r\n\r\n  async setOptions(options?: API.ChannelOptions): Promise<void> {\r\n    const previousChannelOptions = this.channelOptions;\r\n    const err = validateChannelOptions(options);\r\n    if (err) {\r\n      throw err;\r\n    }\r\n    this.channelOptions = normaliseChannelOptions(this.client._Crypto ?? null, options);\r\n    if (this._decodingContext) this._decodingContext.channelOptions = this.channelOptions;\r\n    if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\r\n      /* This does not just do _attach(true, null, callback) because that would put us\r\n       * into the 'attaching' state until we receive the new attached, which is\r\n       * conceptually incorrect: we are still attached, we just have a pending request to\r\n       * change some channel params. Per RTL17 going into the attaching state would mean\r\n       * rejecting messages until we have confirmation that the options have changed,\r\n       * which would unnecessarily lose message continuity. */\r\n      this.attachImpl();\r\n      return new Promise((resolve, reject) => {\r\n        // Ignore 'attaching' -- could be just due to to a resume & reattach, should not\r\n        // call back setOptions until we're definitely attached with the new options (or\r\n        // else in a terminal state)\r\n        this._allChannelChanges.once(\r\n          ['attached', 'update', 'detached', 'failed'],\r\n          function (this: { event: string }, stateChange: ConnectionStateChange) {\r\n            switch (this.event) {\r\n              case 'update':\r\n              case 'attached':\r\n                resolve();\r\n                break;\r\n              default:\r\n                reject(stateChange.reason);\r\n            }\r\n          },\r\n        );\r\n      });\r\n    }\r\n  }\r\n\r\n  _shouldReattachToSetOptions(options: API.ChannelOptions | undefined, prevOptions: API.ChannelOptions) {\r\n    if (!(this.state === 'attached' || this.state === 'attaching')) {\r\n      return false;\r\n    }\r\n    if (options?.params) {\r\n      // Don't check against the `agent` param - it isn't returned in the ATTACHED message\r\n      const requestedParams = omitAgent(options.params);\r\n      const existingParams = omitAgent(prevOptions.params);\r\n\r\n      if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\r\n        return true;\r\n      }\r\n\r\n      if (!Utils.shallowEquals(existingParams, requestedParams)) {\r\n        return true;\r\n      }\r\n    }\r\n    if (options?.modes) {\r\n      if (!prevOptions.modes || !Utils.arrEquals(options.modes, prevOptions.modes)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  async publish(...args: any[]): Promise<void> {\r\n    let messages = args[0];\r\n    let argCount = args.length;\r\n\r\n    if (!this.connectionManager.activeState()) {\r\n      throw this.connectionManager.getError();\r\n    }\r\n    if (argCount == 1) {\r\n      if (Utils.isObject(messages)) messages = [messageFromValues(messages)];\r\n      else if (Array.isArray(messages)) messages = messagesFromValuesArray(messages);\r\n      else\r\n        throw new ErrorInfo(\r\n          'The single-argument form of publish() expects a message object or an array of message objects',\r\n          40013,\r\n          400,\r\n        );\r\n    } else {\r\n      messages = [messageFromValues({ name: args[0], data: args[1] })];\r\n    }\r\n    const maxMessageSize = this.client.options.maxMessageSize;\r\n    await encodeMessagesArray(messages, this.channelOptions as CipherOptions);\r\n    /* RSL1i */\r\n    const size = getMessagesSize(messages);\r\n    if (size > maxMessageSize) {\r\n      throw new ErrorInfo(\r\n        'Maximum size of messages that can be published at once exceeded ( was ' +\r\n          size +\r\n          ' bytes; limit is ' +\r\n          maxMessageSize +\r\n          ' bytes)',\r\n        40009,\r\n        400,\r\n      );\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      this._publish(messages, (err) => (err ? reject(err) : resolve()));\r\n    });\r\n  }\r\n\r\n  _publish(messages: Array<Message>, callback: ErrCallback) {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);\r\n    const state = this.state;\r\n    switch (state) {\r\n      case 'failed':\r\n      case 'suspended':\r\n        callback(ErrorInfo.fromValues(this.invalidStateError()));\r\n        break;\r\n      default: {\r\n        Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.publish()', 'sending message; channel state is ' + state);\r\n        const msg = new ProtocolMessage();\r\n        msg.action = actions.MESSAGE;\r\n        msg.channel = this.name;\r\n        msg.messages = messages;\r\n        this.sendMessage(msg, callback);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  onEvent(messages: Array<any>): void {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');\r\n    const subscriptions = this.subscriptions;\r\n    for (let i = 0; i < messages.length; i++) {\r\n      const message = messages[i];\r\n      subscriptions.emit(message.name, message);\r\n    }\r\n  }\r\n\r\n  async attach(): Promise<ChannelStateChange | null> {\r\n    if (this.state === 'attached') {\r\n      return null;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      this._attach(false, null, (err, result) => (err ? reject(err) : resolve(result!)));\r\n    });\r\n  }\r\n\r\n  _attach(\r\n    forceReattach: boolean,\r\n    attachReason: ErrorInfo | null,\r\n    callback?: StandardCallback<ChannelStateChange>,\r\n  ): void {\r\n    if (!callback) {\r\n      callback = function (err?: ErrorInfo | null) {\r\n        if (err) {\r\n          Logger.logAction(Logger.LOG_ERROR, 'RealtimeChannel._attach()', 'Channel attach failed: ' + err.toString());\r\n        }\r\n      };\r\n    }\r\n\r\n    const connectionManager = this.connectionManager;\r\n    if (!connectionManager.activeState()) {\r\n      callback(connectionManager.getError());\r\n      return;\r\n    }\r\n\r\n    if (this.state !== 'attaching' || forceReattach) {\r\n      this.requestState('attaching', attachReason);\r\n    }\r\n\r\n    this.once(function (this: { event: string }, stateChange: ChannelStateChange) {\r\n      switch (this.event) {\r\n        case 'attached':\r\n          callback?.(null, stateChange);\r\n          break;\r\n        case 'detached':\r\n        case 'suspended':\r\n        case 'failed':\r\n          callback?.(\r\n            stateChange.reason ||\r\n              connectionManager.getError() ||\r\n              new ErrorInfo('Unable to attach; reason unknown; state = ' + this.event, 90000, 500),\r\n          );\r\n          break;\r\n        case 'detaching':\r\n          callback?.(new ErrorInfo('Attach request superseded by a subsequent detach request', 90000, 409));\r\n          break;\r\n      }\r\n    });\r\n  }\r\n\r\n  attachImpl(): void {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');\r\n    const attachMsg = protocolMessageFromValues({\r\n      action: actions.ATTACH,\r\n      channel: this.name,\r\n      params: this.channelOptions.params,\r\n      // RTL4c1: Includes the channel serial to resume from a previous message\r\n      // or attachment.\r\n      channelSerial: this.properties.channelSerial,\r\n    });\r\n    if (this._requestedFlags) {\r\n      attachMsg.encodeModesToFlags(this._requestedFlags);\r\n    } else if (this.channelOptions.modes) {\r\n      attachMsg.encodeModesToFlags(Utils.allToUpperCase(this.channelOptions.modes) as API.ChannelMode[]);\r\n    }\r\n    if (this._attachResume) {\r\n      attachMsg.setFlag('ATTACH_RESUME');\r\n    }\r\n    if (this._lastPayload.decodeFailureRecoveryInProgress) {\r\n      attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\r\n    }\r\n    this.sendMessage(attachMsg, noop);\r\n  }\r\n\r\n  async detach(): Promise<void> {\r\n    const connectionManager = this.connectionManager;\r\n    if (!connectionManager.activeState()) {\r\n      throw connectionManager.getError();\r\n    }\r\n    switch (this.state) {\r\n      case 'suspended':\r\n        this.notifyState('detached');\r\n        return;\r\n      case 'detached':\r\n        return;\r\n      case 'failed':\r\n        throw new ErrorInfo('Unable to detach; channel state = failed', 90001, 400);\r\n      default:\r\n        this.requestState('detaching');\r\n      // eslint-disable-next-line no-fallthrough\r\n      case 'detaching':\r\n        return new Promise((resolve, reject) => {\r\n          this.once(function (this: { event: string }, stateChange: ChannelStateChange) {\r\n            switch (this.event) {\r\n              case 'detached':\r\n                resolve();\r\n                break;\r\n              case 'attached':\r\n              case 'suspended':\r\n              case 'failed':\r\n                reject(\r\n                  stateChange.reason ||\r\n                    connectionManager.getError() ||\r\n                    new ErrorInfo('Unable to detach; reason unknown; state = ' + this.event, 90000, 500),\r\n                );\r\n                break;\r\n              case 'attaching':\r\n                reject(new ErrorInfo('Detach request superseded by a subsequent attach request', 90000, 409));\r\n                break;\r\n            }\r\n          });\r\n        });\r\n    }\r\n  }\r\n\r\n  detachImpl(callback?: ErrCallback): void {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');\r\n    const msg = protocolMessageFromValues({ action: actions.DETACH, channel: this.name });\r\n    this.sendMessage(msg, callback || noop);\r\n  }\r\n\r\n  async subscribe(...args: unknown[] /* [event], listener */): Promise<ChannelStateChange | null> {\r\n    const [event, listener] = RealtimeChannel.processListenerArgs(args);\r\n\r\n    if (this.state === 'failed') {\r\n      throw ErrorInfo.fromValues(this.invalidStateError());\r\n    }\r\n\r\n    // Filtered\r\n    if (event && typeof event === 'object' && !Array.isArray(event)) {\r\n      this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);\r\n    } else {\r\n      this.subscriptions.on(event, listener);\r\n    }\r\n\r\n    return this.attach();\r\n  }\r\n\r\n  unsubscribe(...args: unknown[] /* [event], listener */): void {\r\n    const [event, listener] = RealtimeChannel.processListenerArgs(args);\r\n\r\n    // If we either have a filtered listener, a filter or both we need to do additional processing to find the original function(s)\r\n    if ((typeof event === 'object' && !listener) || this.filteredSubscriptions?.has(listener)) {\r\n      this.client._FilteredSubscriptions\r\n        .getAndDeleteFilteredSubscriptions(this, event, listener)\r\n        .forEach((l) => this.subscriptions.off(l));\r\n      return;\r\n    }\r\n\r\n    this.subscriptions.off(event, listener);\r\n  }\r\n\r\n  sync(): void {\r\n    /* check preconditions */\r\n    switch (this.state) {\r\n      case 'initialized':\r\n      case 'detaching':\r\n      case 'detached':\r\n        throw new PartialErrorInfo('Unable to sync to channel; not attached', 40000);\r\n      default:\r\n    }\r\n    const connectionManager = this.connectionManager;\r\n    if (!connectionManager.activeState()) {\r\n      throw connectionManager.getError();\r\n    }\r\n\r\n    /* send sync request */\r\n    const syncMessage = protocolMessageFromValues({ action: actions.SYNC, channel: this.name });\r\n    if (this.syncChannelSerial) {\r\n      syncMessage.channelSerial = this.syncChannelSerial;\r\n    }\r\n    connectionManager.send(syncMessage);\r\n  }\r\n\r\n  sendMessage(msg: ProtocolMessage, callback?: ErrCallback): void {\r\n    this.connectionManager.send(msg, this.client.options.queueMessages, callback);\r\n  }\r\n\r\n  sendPresence(presence: PresenceMessage | PresenceMessage[], callback?: ErrCallback): void {\r\n    const msg = protocolMessageFromValues({\r\n      action: actions.PRESENCE,\r\n      channel: this.name,\r\n      presence: Array.isArray(presence)\r\n        ? this.client._RealtimePresence!.presenceMessagesFromValuesArray(presence)\r\n        : [this.client._RealtimePresence!.presenceMessageFromValues(presence)],\r\n    });\r\n    this.sendMessage(msg, callback);\r\n  }\r\n\r\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.\r\n  async processMessage(message: ProtocolMessage): Promise<void> {\r\n    if (\r\n      message.action === actions.ATTACHED ||\r\n      message.action === actions.MESSAGE ||\r\n      message.action === actions.PRESENCE\r\n    ) {\r\n      // RTL15b\r\n      this.setChannelSerial(message.channelSerial);\r\n    }\r\n\r\n    let syncChannelSerial,\r\n      isSync = false;\r\n    switch (message.action) {\r\n      case actions.ATTACHED: {\r\n        this.properties.attachSerial = message.channelSerial;\r\n        this._mode = message.getMode();\r\n        this.params = (message as any).params || {};\r\n        const modesFromFlags = message.decodeModesFromFlags();\r\n        this.modes = (modesFromFlags && Utils.allToLowerCase(modesFromFlags)) || undefined;\r\n        const resumed = message.hasFlag('RESUMED');\r\n        const hasPresence = message.hasFlag('HAS_PRESENCE');\r\n        const hasBacklog = message.hasFlag('HAS_BACKLOG');\r\n        if (this.state === 'attached') {\r\n          if (!resumed) {\r\n            /* On a loss of continuity, the presence set needs to be re-synced */\r\n            if (this._presence) {\r\n              this._presence.onAttached(hasPresence);\r\n            }\r\n          }\r\n          const change = new ChannelStateChange(this.state, this.state, resumed, hasBacklog, message.error);\r\n          this._allChannelChanges.emit('update', change);\r\n          if (!resumed || this.channelOptions.updateOnAttached) {\r\n            this.emit('update', change);\r\n          }\r\n        } else if (this.state === 'detaching') {\r\n          /* RTL5i: re-send DETACH and remain in the 'detaching' state */\r\n          this.checkPendingState();\r\n        } else {\r\n          this.notifyState('attached', message.error, resumed, hasPresence, hasBacklog);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case actions.DETACHED: {\r\n        const detachErr = message.error\r\n          ? ErrorInfo.fromValues(message.error)\r\n          : new ErrorInfo('Channel detached', 90001, 404);\r\n        if (this.state === 'detaching') {\r\n          this.notifyState('detached', detachErr);\r\n        } else if (this.state === 'attaching') {\r\n          /* Only retry immediately if we were previously attached. If we were\r\n           * attaching, go into suspended, fail messages, and wait a few seconds\r\n           * before retrying */\r\n          this.notifyState('suspended', detachErr);\r\n        } else {\r\n          this.requestState('attaching', detachErr);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case actions.SYNC:\r\n        /* syncs can have channelSerials, but might not if the sync is one page long */\r\n        isSync = true;\r\n        syncChannelSerial = this.syncChannelSerial = message.channelSerial;\r\n        /* syncs can happen on channels with no presence data as part of connection\r\n         * resuming, in which case protocol message has no presence property */\r\n        if (!message.presence) break;\r\n      // eslint-disable-next-line no-fallthrough\r\n      case actions.PRESENCE: {\r\n        const presence = message.presence;\r\n\r\n        if (!presence) {\r\n          break;\r\n        }\r\n\r\n        const { id, connectionId, timestamp } = message;\r\n\r\n        const options = this.channelOptions;\r\n        let presenceMsg: PresenceMessage;\r\n        for (let i = 0; i < presence.length; i++) {\r\n          try {\r\n            presenceMsg = presence[i];\r\n            await decodePresenceMessage(presenceMsg, options);\r\n            if (!presenceMsg.connectionId) presenceMsg.connectionId = connectionId;\r\n            if (!presenceMsg.timestamp) presenceMsg.timestamp = timestamp;\r\n            if (!presenceMsg.id) presenceMsg.id = id + ':' + i;\r\n          } catch (e) {\r\n            Logger.logAction(Logger.LOG_ERROR, 'RealtimeChannel.processMessage()', (e as Error).toString());\r\n          }\r\n        }\r\n        if (this._presence) {\r\n          this._presence.setPresence(presence, isSync, syncChannelSerial as any);\r\n        }\r\n        break;\r\n      }\r\n      case actions.MESSAGE: {\r\n        //RTL17\r\n        if (this.state !== 'attached') {\r\n          Logger.logAction(\r\n            Logger.LOG_MAJOR,\r\n            'RealtimeChannel.processMessage()',\r\n            'Message \"' +\r\n              message.id +\r\n              '\" skipped as this channel \"' +\r\n              this.name +\r\n              '\" state is not \"attached\" (state is \"' +\r\n              this.state +\r\n              '\").',\r\n          );\r\n          return;\r\n        }\r\n\r\n        const messages = message.messages as Array<Message>,\r\n          firstMessage = messages[0],\r\n          lastMessage = messages[messages.length - 1],\r\n          id = message.id,\r\n          connectionId = message.connectionId,\r\n          timestamp = message.timestamp;\r\n\r\n        if (\r\n          firstMessage.extras &&\r\n          firstMessage.extras.delta &&\r\n          firstMessage.extras.delta.from !== this._lastPayload.messageId\r\n        ) {\r\n          const msg =\r\n            'Delta message decode failure - previous message not available for message \"' +\r\n            message.id +\r\n            '\" on this channel \"' +\r\n            this.name +\r\n            '\".';\r\n          Logger.logAction(Logger.LOG_ERROR, 'RealtimeChannel.processMessage()', msg);\r\n          this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));\r\n          break;\r\n        }\r\n\r\n        for (let i = 0; i < messages.length; i++) {\r\n          const msg = messages[i];\r\n          try {\r\n            await decodeMessage(msg, this._decodingContext);\r\n          } catch (e) {\r\n            /* decrypt failed .. the most likely cause is that we have the wrong key */\r\n            Logger.logAction(Logger.LOG_ERROR, 'RealtimeChannel.processMessage()', (e as Error).toString());\r\n            switch ((e as ErrorInfo).code) {\r\n              case 40018:\r\n                /* decode failure */\r\n                this._startDecodeFailureRecovery(e as ErrorInfo);\r\n                return;\r\n              case 40019:\r\n              /* No vcdiff plugin passed in - no point recovering, give up */\r\n              // eslint-disable-next-line no-fallthrough\r\n              case 40021:\r\n                /* Browser does not support deltas, similarly no point recovering */\r\n                this.notifyState('failed', e as ErrorInfo);\r\n                return;\r\n            }\r\n          }\r\n          if (!msg.connectionId) msg.connectionId = connectionId;\r\n          if (!msg.timestamp) msg.timestamp = timestamp;\r\n          if (!msg.id) msg.id = id + ':' + i;\r\n        }\r\n        this._lastPayload.messageId = lastMessage.id;\r\n        this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\r\n        this.onEvent(messages);\r\n        break;\r\n      }\r\n\r\n      case actions.ERROR: {\r\n        /* there was a channel-specific error */\r\n        const err = message.error as ErrorInfo;\r\n        if (err && err.code == 80016) {\r\n          /* attach/detach operation attempted on superseded transport handle */\r\n          this.checkPendingState();\r\n        } else {\r\n          this.notifyState('failed', ErrorInfo.fromValues(err));\r\n        }\r\n        break;\r\n      }\r\n\r\n      default:\r\n        Logger.logAction(\r\n          Logger.LOG_ERROR,\r\n          'RealtimeChannel.processMessage()',\r\n          'Fatal protocol error: unrecognised action (' + message.action + ')',\r\n        );\r\n        this.connectionManager.abort(ConnectionErrors.unknownChannelErr());\r\n    }\r\n  }\r\n\r\n  _startDecodeFailureRecovery(reason: ErrorInfo): void {\r\n    if (!this._lastPayload.decodeFailureRecoveryInProgress) {\r\n      Logger.logAction(\r\n        Logger.LOG_MAJOR,\r\n        'RealtimeChannel.processMessage()',\r\n        'Starting decode failure recovery process.',\r\n      );\r\n      this._lastPayload.decodeFailureRecoveryInProgress = true;\r\n      this._attach(true, reason, () => {\r\n        this._lastPayload.decodeFailureRecoveryInProgress = false;\r\n      });\r\n    }\r\n  }\r\n\r\n  onAttached(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.onAttached', 'activating channel; name = ' + this.name);\r\n  }\r\n\r\n  notifyState(\r\n    state: API.ChannelState,\r\n    reason?: ErrorInfo | null,\r\n    resumed?: boolean,\r\n    hasPresence?: boolean,\r\n    hasBacklog?: boolean,\r\n  ): void {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'RealtimeChannel.notifyState',\r\n      'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state,\r\n    );\r\n    this.clearStateTimer();\r\n\r\n    // RTP5a1\r\n    if (['detached', 'suspended', 'failed'].includes(state)) {\r\n      this.properties.channelSerial = null;\r\n    }\r\n\r\n    if (state === this.state) {\r\n      return;\r\n    }\r\n    if (this._presence) {\r\n      this._presence.actOnChannelState(state, hasPresence, reason);\r\n    }\r\n    if (state === 'suspended' && this.connectionManager.state.sendEvents) {\r\n      this.startRetryTimer();\r\n    } else {\r\n      this.cancelRetryTimer();\r\n    }\r\n    if (reason) {\r\n      this.errorReason = reason;\r\n    }\r\n    const change = new ChannelStateChange(this.state, state, resumed, hasBacklog, reason);\r\n    const action = 'Channel state for channel \"' + this.name + '\"';\r\n    const message = state + (reason ? '; reason: ' + reason : '');\r\n    if (state === 'failed') {\r\n      Logger.logAction(Logger.LOG_ERROR, action, message);\r\n    } else {\r\n      Logger.logAction(Logger.LOG_MAJOR, action, message);\r\n    }\r\n\r\n    if (state !== 'attaching' && state !== 'suspended') {\r\n      this.retryCount = 0;\r\n    }\r\n\r\n    /* Note: we don't set inProgress for pending states until the request is actually in progress */\r\n    if (state === 'attached') {\r\n      this.onAttached();\r\n    }\r\n\r\n    if (state === 'attached') {\r\n      this._attachResume = true;\r\n    } else if (state === 'detaching' || state === 'failed') {\r\n      this._attachResume = false;\r\n    }\r\n\r\n    this.state = state;\r\n    this._allChannelChanges.emit(state, change);\r\n    this.emit(state, change);\r\n  }\r\n\r\n  requestState(state: API.ChannelState, reason?: ErrorInfo | null): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.requestState', 'name = ' + this.name + ', state = ' + state);\r\n    this.notifyState(state, reason);\r\n    /* send the event and await response */\r\n    this.checkPendingState();\r\n  }\r\n\r\n  checkPendingState(): void {\r\n    /* if can't send events, do nothing */\r\n    const cmState = this.connectionManager.state;\r\n    if (!cmState.sendEvents) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'RealtimeChannel.checkPendingState',\r\n        'sendEvents is false; state is ' + this.connectionManager.state.state,\r\n      );\r\n      return;\r\n    }\r\n\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'RealtimeChannel.checkPendingState',\r\n      'name = ' + this.name + ', state = ' + this.state,\r\n    );\r\n    /* Only start the state timer running when actually sending the event */\r\n    switch (this.state) {\r\n      case 'attaching':\r\n        this.startStateTimerIfNotRunning();\r\n        this.attachImpl();\r\n        break;\r\n      case 'detaching':\r\n        this.startStateTimerIfNotRunning();\r\n        this.detachImpl();\r\n        break;\r\n      case 'attached':\r\n        /* resume any sync operation that was in progress */\r\n        this.sync();\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  timeoutPendingState(): void {\r\n    switch (this.state) {\r\n      case 'attaching': {\r\n        const err = new ErrorInfo('Channel attach timed out', 90007, 408);\r\n        this.notifyState('suspended', err);\r\n        break;\r\n      }\r\n      case 'detaching': {\r\n        const err = new ErrorInfo('Channel detach timed out', 90007, 408);\r\n        this.notifyState('attached', err);\r\n        break;\r\n      }\r\n      default:\r\n        this.checkPendingState();\r\n        break;\r\n    }\r\n  }\r\n\r\n  startStateTimerIfNotRunning(): void {\r\n    if (!this.stateTimer) {\r\n      this.stateTimer = setTimeout(() => {\r\n        Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');\r\n        this.stateTimer = null;\r\n        this.timeoutPendingState();\r\n      }, this.client.options.timeouts.realtimeRequestTimeout);\r\n    }\r\n  }\r\n\r\n  clearStateTimer(): void {\r\n    const stateTimer = this.stateTimer;\r\n    if (stateTimer) {\r\n      clearTimeout(stateTimer);\r\n      this.stateTimer = null;\r\n    }\r\n  }\r\n\r\n  startRetryTimer(): void {\r\n    if (this.retryTimer) return;\r\n\r\n    this.retryCount++;\r\n    const retryDelay = Utils.getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);\r\n\r\n    this.retryTimer = setTimeout(() => {\r\n      /* If connection is not connected, just leave in suspended, a reattach\r\n       * will be triggered once it connects again */\r\n      if (this.state === 'suspended' && this.connectionManager.state.sendEvents) {\r\n        this.retryTimer = null;\r\n        Logger.logAction(Logger.LOG_MINOR, 'RealtimeChannel retry timer expired', 'attempting a new attach');\r\n        this.requestState('attaching');\r\n      }\r\n    }, retryDelay);\r\n  }\r\n\r\n  cancelRetryTimer(): void {\r\n    if (this.retryTimer) {\r\n      clearTimeout(this.retryTimer as NodeJS.Timeout);\r\n      this.retryTimer = null;\r\n    }\r\n  }\r\n\r\n  history = async function (\r\n    this: RealtimeChannel,\r\n    params: RealtimeHistoryParams | null,\r\n  ): Promise<PaginatedResult<Message>> {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);\r\n\r\n    // We fetch this first so that any plugin-not-provided error takes priority over other errors\r\n    const restMixin = this.client.rest.channelMixin;\r\n\r\n    if (params && params.untilAttach) {\r\n      if (this.state !== 'attached') {\r\n        throw new ErrorInfo('option untilAttach requires the channel to be attached', 40000, 400);\r\n      }\r\n      if (!this.properties.attachSerial) {\r\n        throw new ErrorInfo(\r\n          'untilAttach was specified and channel is attached, but attachSerial is not defined',\r\n          40000,\r\n          400,\r\n        );\r\n      }\r\n      delete params.untilAttach;\r\n      params.from_serial = this.properties.attachSerial;\r\n    }\r\n\r\n    return restMixin.history(this, params);\r\n  } as any;\r\n\r\n  whenState = ((state: string) => {\r\n    return EventEmitter.prototype.whenState.call(this, state, this.state);\r\n  }) as any;\r\n\r\n  /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\r\n  getReleaseErr(): ErrorInfo | null {\r\n    const s = this.state;\r\n    if (s === 'initialized' || s === 'detached' || s === 'failed') {\r\n      return null;\r\n    }\r\n    return new ErrorInfo(\r\n      'Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' +\r\n        s,\r\n      90001,\r\n      400,\r\n    );\r\n  }\r\n\r\n  setChannelSerial(channelSerial?: string | null): void {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'RealtimeChannel.setChannelSerial()',\r\n      'Updating channel serial; serial = ' + channelSerial + '; previous = ' + this.properties.channelSerial,\r\n    );\r\n\r\n    // RTP17h: Only update the channel serial if its present (it won't always\r\n    // be set).\r\n    if (channelSerial) {\r\n      this.properties.channelSerial = channelSerial;\r\n    }\r\n  }\r\n\r\n  async status(): Promise<API.ChannelDetails> {\r\n    return this.client.rest.channelMixin.status(this);\r\n  }\r\n}\r\n\r\nfunction omitAgent(channelParams?: API.ChannelParams) {\r\n  const { agent: _, ...paramsWithoutAgent } = channelParams || {};\r\n  return paramsWithoutAgent;\r\n}\r\n\r\nexport default RealtimeChannel;\r\n","import * as Utils from '../util/utils';\r\nimport BaseClient from './baseclient';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport Connection from './connection';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport ProtocolMessage from '../types/protocolmessage';\r\nimport { ChannelOptions } from '../../types/channel';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport * as API from '../../../../ably';\r\nimport { ModularPlugins, RealtimePresencePlugin } from './modularplugins';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\nimport { TransportImplementations } from 'common/platform';\r\nimport Defaults from '../util/defaults';\r\n\r\n/**\r\n `BaseRealtime` is an export of the tree-shakable version of the SDK, and acts as the base class for the `DefaultRealtime` class exported by the non tree-shakable version.\r\n */\r\nclass BaseRealtime extends BaseClient {\r\n  readonly _RealtimePresence: RealtimePresencePlugin | null;\r\n  // Extra transport implementations available to this client, in addition to those in Platform.Transports.bundledImplementations\r\n  readonly _additionalTransportImplementations: TransportImplementations;\r\n  _channels: any;\r\n  connection: Connection;\r\n\r\n  /*\r\n   * The public typings declare that this only accepts an object, but since we want to emit a good error message in the case where a non-TypeScript user does one of these things:\r\n   *\r\n   * 1. passes a string (which is quite likely if theyâ€™re e.g. migrating from the default variant to the modular variant)\r\n   * 2. passes no argument at all\r\n   *\r\n   * tell the compiler that these cases are possible so that it forces us to handle them.\r\n   */\r\n  constructor(options?: ClientOptions | string) {\r\n    super(Defaults.objectifyOptions(options, false, 'BaseRealtime'));\r\n    Logger.logAction(Logger.LOG_MINOR, 'Realtime()', '');\r\n    this._additionalTransportImplementations = BaseRealtime.transportImplementationsFromPlugins(this.options.plugins);\r\n    this._RealtimePresence = this.options.plugins?.RealtimePresence ?? null;\r\n    this.connection = new Connection(this, this.options);\r\n    this._channels = new Channels(this);\r\n    if (this.options.autoConnect !== false) this.connect();\r\n  }\r\n\r\n  private static transportImplementationsFromPlugins(plugins?: ModularPlugins) {\r\n    const transports: TransportImplementations = {};\r\n\r\n    if (plugins?.WebSocketTransport) {\r\n      transports[TransportNames.WebSocket] = plugins.WebSocketTransport;\r\n    }\r\n    if (plugins?.XHRPolling) {\r\n      transports[TransportNames.XhrPolling] = plugins.XHRPolling;\r\n    }\r\n\r\n    return transports;\r\n  }\r\n\r\n  get channels() {\r\n    return this._channels;\r\n  }\r\n\r\n  connect(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Realtime.connect()', '');\r\n    this.connection.connect();\r\n  }\r\n\r\n  close(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'Realtime.close()', '');\r\n    this.connection.close();\r\n  }\r\n}\r\n\r\nclass Channels extends EventEmitter {\r\n  realtime: BaseRealtime;\r\n  all: Record<string, RealtimeChannel>;\r\n\r\n  constructor(realtime: BaseRealtime) {\r\n    super();\r\n    this.realtime = realtime;\r\n    this.all = Object.create(null);\r\n    realtime.connection.connectionManager.on('transport.active', () => {\r\n      this.onTransportActive();\r\n    });\r\n  }\r\n\r\n  channelSerials(): { [name: string]: string } {\r\n    let serials: { [name: string]: string } = {};\r\n    for (const name of Utils.keysArray(this.all, true)) {\r\n      const channel = this.all[name];\r\n      if (channel.properties.channelSerial) {\r\n        serials[name] = channel.properties.channelSerial;\r\n      }\r\n    }\r\n    return serials;\r\n  }\r\n\r\n  // recoverChannels gets the given channels and sets their channel serials.\r\n  recoverChannels(channelSerials: { [name: string]: string }) {\r\n    for (const name of Utils.keysArray(channelSerials, true)) {\r\n      const channel = this.get(name);\r\n      channel.properties.channelSerial = channelSerials[name];\r\n    }\r\n  }\r\n\r\n  // Access to this method is synchronised by ConnectionManager#processChannelMessage.\r\n  async processChannelMessage(msg: ProtocolMessage) {\r\n    const channelName = msg.channel;\r\n    if (channelName === undefined) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'Channels.processChannelMessage()',\r\n        'received event unspecified channel, action = ' + msg.action,\r\n      );\r\n      return;\r\n    }\r\n    const channel = this.all[channelName];\r\n    if (!channel) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'Channels.processChannelMessage()',\r\n        'received event for non-existent channel: ' + channelName,\r\n      );\r\n      return;\r\n    }\r\n    await channel.processMessage(msg);\r\n  }\r\n\r\n  /* called when a transport becomes connected; reattempt attach/detach\r\n   * for channels that are attaching or detaching. */\r\n  onTransportActive() {\r\n    for (const channelName in this.all) {\r\n      const channel = this.all[channelName];\r\n      if (channel.state === 'attaching' || channel.state === 'detaching') {\r\n        channel.checkPendingState();\r\n      } else if (channel.state === 'suspended') {\r\n        channel._attach(false, null);\r\n      } else if (channel.state === 'attached') {\r\n        // Note explicity request the state, channel.attach() would do nothing\r\n        // as its already attached.\r\n        channel.requestState('attaching');\r\n      }\r\n    }\r\n  }\r\n\r\n  /* Connection interruptions (ie when the connection will no longer queue\r\n   * events) imply connection state changes for any channel which is either\r\n   * attached, pending, or will attempt to become attached in the future */\r\n  propogateConnectionInterruption(connectionState: string, reason: ErrorInfo) {\r\n    const connectionStateToChannelState: Record<string, API.ChannelState> = {\r\n      closing: 'detached',\r\n      closed: 'detached',\r\n      failed: 'failed',\r\n      suspended: 'suspended',\r\n    };\r\n    const fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];\r\n    const toChannelState = connectionStateToChannelState[connectionState];\r\n\r\n    for (const channelId in this.all) {\r\n      const channel = this.all[channelId];\r\n      if (fromChannelStates.includes(channel.state)) {\r\n        channel.notifyState(toChannelState, reason);\r\n      }\r\n    }\r\n  }\r\n\r\n  get(name: string, channelOptions?: ChannelOptions) {\r\n    name = String(name);\r\n    let channel = this.all[name];\r\n    if (!channel) {\r\n      channel = this.all[name] = new RealtimeChannel(this.realtime, name, channelOptions);\r\n    } else if (channelOptions) {\r\n      if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\r\n        throw new ErrorInfo(\r\n          'Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.',\r\n          40000,\r\n          400,\r\n        );\r\n      }\r\n      channel.setOptions(channelOptions);\r\n    }\r\n    return channel;\r\n  }\r\n\r\n  getDerived(name: string, deriveOptions: API.DeriveOptions, channelOptions?: ChannelOptions) {\r\n    if (deriveOptions.filter) {\r\n      const filter = Utils.toBase64(deriveOptions.filter);\r\n      const match = Utils.matchDerivedChannel(name);\r\n      name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;\r\n    }\r\n    return this.get(name, channelOptions);\r\n  }\r\n\r\n  /* Included to support certain niche use-cases; most users should ignore this.\r\n   * Please do not use this unless you know what you're doing */\r\n  release(name: string) {\r\n    name = String(name);\r\n    const channel = this.all[name];\r\n    if (!channel) {\r\n      return;\r\n    }\r\n    const releaseErr = channel.getReleaseErr();\r\n    if (releaseErr) {\r\n      throw releaseErr;\r\n    }\r\n    delete this.all[name];\r\n  }\r\n}\r\n\r\nexport default BaseRealtime;\r\n","import * as Utils from '../util/utils';\r\nimport EventEmitter from '../util/eventemitter';\r\nimport Logger from '../util/logger';\r\nimport PresenceMessage, {\r\n  fromValues as presenceMessageFromValues,\r\n  fromData as presenceMessageFromData,\r\n  encode as encodePresenceMessage,\r\n} from '../types/presencemessage';\r\nimport ErrorInfo, { PartialErrorInfo } from '../types/errorinfo';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport Multicaster from '../util/multicaster';\r\nimport ChannelStateChange from './channelstatechange';\r\nimport { CipherOptions } from '../types/message';\r\nimport { ErrCallback } from '../../types/utils';\r\nimport { PaginatedResult } from './paginatedresource';\r\n\r\ninterface RealtimePresenceParams {\r\n  waitForSync?: boolean;\r\n  clientId?: string;\r\n  connectionId?: string;\r\n}\r\n\r\ninterface RealtimeHistoryParams {\r\n  start?: number;\r\n  end?: number;\r\n  direction?: string;\r\n  limit?: number;\r\n  untilAttach?: boolean;\r\n  from_serial?: string | null;\r\n}\r\n\r\nfunction getClientId(realtimePresence: RealtimePresence) {\r\n  return realtimePresence.channel.client.auth.clientId;\r\n}\r\n\r\nfunction isAnonymousOrWildcard(realtimePresence: RealtimePresence) {\r\n  const realtime = realtimePresence.channel.client;\r\n  /* If not currently connected, we can't assume that we're an anonymous\r\n   * client, as realtime may inform us of our clientId in the CONNECTED\r\n   * message. So assume we're not anonymous and leave it to realtime to\r\n   * return an error if we are */\r\n  const clientId = realtime.auth.clientId;\r\n  return (!clientId || clientId === '*') && realtime.connection.state === 'connected';\r\n}\r\n\r\n/* Callback is called only in the event of an error */\r\nfunction waitAttached(channel: RealtimeChannel, callback: ErrCallback, action: () => void) {\r\n  switch (channel.state) {\r\n    case 'attached':\r\n    case 'suspended':\r\n      action();\r\n      break;\r\n    case 'initialized':\r\n    case 'detached':\r\n    case 'detaching':\r\n    case 'attaching':\r\n      Utils.whenPromiseSettles(channel.attach(), function (err: Error | null) {\r\n        if (err) callback(err);\r\n        else action();\r\n      });\r\n      break;\r\n    default:\r\n      callback(ErrorInfo.fromValues(channel.invalidStateError()));\r\n  }\r\n}\r\n\r\nfunction newerThan(item: PresenceMessage, existing: PresenceMessage) {\r\n  /* RTP2b1: if either is synthesised, compare by timestamp */\r\n  if (item.isSynthesized() || existing.isSynthesized()) {\r\n    // RTP2b1a: if equal, prefer the newly-arrived one\r\n    return (item.timestamp as number) >= (existing.timestamp as number);\r\n  }\r\n\r\n  /* RTP2b2 */\r\n  const itemOrderings = item.parseId(),\r\n    existingOrderings = existing.parseId();\r\n  if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\r\n    return itemOrderings.index > existingOrderings.index;\r\n  } else {\r\n    return itemOrderings.msgSerial > existingOrderings.msgSerial;\r\n  }\r\n}\r\n\r\nclass RealtimePresence extends EventEmitter {\r\n  channel: RealtimeChannel;\r\n  pendingPresence: { presence: PresenceMessage; callback: ErrCallback }[];\r\n  syncComplete: boolean;\r\n  members: PresenceMap;\r\n  _myMembers: PresenceMap;\r\n  subscriptions: EventEmitter;\r\n  name?: string;\r\n\r\n  constructor(channel: RealtimeChannel) {\r\n    super();\r\n    this.channel = channel;\r\n    this.syncComplete = false;\r\n    this.members = new PresenceMap(this, (item) => item.clientId + ':' + item.connectionId);\r\n    // RTP17h: Store own members by clientId only.\r\n    this._myMembers = new PresenceMap(this, (item) => item.clientId!);\r\n    this.subscriptions = new EventEmitter();\r\n    this.pendingPresence = [];\r\n  }\r\n\r\n  async enter(data: unknown): Promise<void> {\r\n    if (isAnonymousOrWildcard(this)) {\r\n      throw new ErrorInfo('clientId must be specified to enter a presence channel', 40012, 400);\r\n    }\r\n    return this._enterOrUpdateClient(undefined, undefined, data, 'enter');\r\n  }\r\n\r\n  async update(data: unknown): Promise<void> {\r\n    if (isAnonymousOrWildcard(this)) {\r\n      throw new ErrorInfo('clientId must be specified to update presence data', 40012, 400);\r\n    }\r\n    return this._enterOrUpdateClient(undefined, undefined, data, 'update');\r\n  }\r\n\r\n  async enterClient(clientId: string, data: unknown): Promise<void> {\r\n    return this._enterOrUpdateClient(undefined, clientId, data, 'enter');\r\n  }\r\n\r\n  async updateClient(clientId: string, data: unknown): Promise<void> {\r\n    return this._enterOrUpdateClient(undefined, clientId, data, 'update');\r\n  }\r\n\r\n  async _enterOrUpdateClient(\r\n    id: string | undefined,\r\n    clientId: string | undefined,\r\n    data: unknown,\r\n    action: string,\r\n  ): Promise<void> {\r\n    const channel = this.channel;\r\n    if (!channel.connectionManager.activeState()) {\r\n      throw channel.connectionManager.getError();\r\n    }\r\n\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'RealtimePresence.' + action + 'Client()',\r\n      'channel = ' + channel.name + ', id = ' + id + ', client = ' + (clientId || '(implicit) ' + getClientId(this)),\r\n    );\r\n\r\n    const presence = presenceMessageFromData(data);\r\n    presence.action = action;\r\n    if (id) {\r\n      presence.id = id;\r\n    }\r\n    if (clientId) {\r\n      presence.clientId = clientId;\r\n    }\r\n\r\n    await encodePresenceMessage(presence, channel.channelOptions as CipherOptions);\r\n    switch (channel.state) {\r\n      case 'attached':\r\n        return new Promise((resolve, reject) => {\r\n          channel.sendPresence(presence, (err) => (err ? reject(err) : resolve()));\r\n        });\r\n      case 'initialized':\r\n      case 'detached':\r\n        channel.attach();\r\n      // eslint-disable-next-line no-fallthrough\r\n      case 'attaching':\r\n        return new Promise((resolve, reject) => {\r\n          this.pendingPresence.push({\r\n            presence: presence,\r\n            callback: (err) => (err ? reject(err) : resolve()),\r\n          });\r\n        });\r\n      default: {\r\n        const err = new PartialErrorInfo(\r\n          'Unable to ' + action + ' presence channel while in ' + channel.state + ' state',\r\n          90001,\r\n        );\r\n        err.code = 90001;\r\n        throw err;\r\n      }\r\n    }\r\n  }\r\n\r\n  async leave(data: unknown): Promise<void> {\r\n    if (isAnonymousOrWildcard(this)) {\r\n      throw new ErrorInfo('clientId must have been specified to enter or leave a presence channel', 40012, 400);\r\n    }\r\n    return this.leaveClient(undefined, data);\r\n  }\r\n\r\n  async leaveClient(clientId?: string, data?: unknown): Promise<void> {\r\n    const channel = this.channel;\r\n    if (!channel.connectionManager.activeState()) {\r\n      throw channel.connectionManager.getError();\r\n    }\r\n\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'RealtimePresence.leaveClient()',\r\n      'leaving; channel = ' + this.channel.name + ', client = ' + clientId,\r\n    );\r\n    const presence = presenceMessageFromData(data);\r\n    presence.action = 'leave';\r\n    if (clientId) {\r\n      presence.clientId = clientId;\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      switch (channel.state) {\r\n        case 'attached':\r\n          channel.sendPresence(presence, (err) => (err ? reject(err) : resolve()));\r\n          break;\r\n        case 'attaching':\r\n          this.pendingPresence.push({\r\n            presence: presence,\r\n            callback: (err) => (err ? reject(err) : resolve()),\r\n          });\r\n          break;\r\n        case 'initialized':\r\n        case 'failed': {\r\n          /* we're not attached; therefore we let any entered status\r\n           * timeout by itself instead of attaching just in order to leave */\r\n          const err = new PartialErrorInfo('Unable to leave presence channel (incompatible state)', 90001);\r\n          reject(err);\r\n          break;\r\n        }\r\n        default:\r\n          reject(channel.invalidStateError());\r\n      }\r\n    });\r\n  }\r\n\r\n  async get(params?: RealtimePresenceParams): Promise<PresenceMessage[]> {\r\n    const waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      function returnMembers(members: PresenceMap) {\r\n        resolve(params ? members.list(params) : members.values());\r\n      }\r\n\r\n      /* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */\r\n      if (this.channel.state === 'suspended') {\r\n        if (waitForSync) {\r\n          reject(\r\n            ErrorInfo.fromValues({\r\n              statusCode: 400,\r\n              code: 91005,\r\n              message: 'Presence state is out of sync due to channel being in the SUSPENDED state',\r\n            }),\r\n          );\r\n        } else {\r\n          returnMembers(this.members);\r\n        }\r\n        return;\r\n      }\r\n\r\n      waitAttached(\r\n        this.channel,\r\n        (err) => reject(err),\r\n        () => {\r\n          const members = this.members;\r\n          if (waitForSync) {\r\n            members.waitSync(function () {\r\n              returnMembers(members);\r\n            });\r\n          } else {\r\n            returnMembers(members);\r\n          }\r\n        },\r\n      );\r\n    });\r\n  }\r\n\r\n  async history(params: RealtimeHistoryParams | null): Promise<PaginatedResult<PresenceMessage>> {\r\n    Logger.logAction(Logger.LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);\r\n    // We fetch this first so that any plugin-not-provided error takes priority over other errors\r\n    const restMixin = this.channel.client.rest.presenceMixin;\r\n\r\n    if (params && params.untilAttach) {\r\n      if (this.channel.state === 'attached') {\r\n        delete params.untilAttach;\r\n        params.from_serial = this.channel.properties.attachSerial;\r\n      } else {\r\n        throw new ErrorInfo(\r\n          'option untilAttach requires the channel to be attached, was: ' + this.channel.state,\r\n          40000,\r\n          400,\r\n        );\r\n      }\r\n    }\r\n\r\n    return restMixin.history(this, params);\r\n  }\r\n\r\n  setPresence(presenceSet: PresenceMessage[], isSync: boolean, syncChannelSerial?: string): void {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'RealtimePresence.setPresence()',\r\n      'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial,\r\n    );\r\n    let syncCursor, match;\r\n    const members = this.members,\r\n      myMembers = this._myMembers,\r\n      broadcastMessages = [],\r\n      connId = this.channel.connectionManager.connectionId;\r\n\r\n    if (isSync) {\r\n      this.members.startSync();\r\n      if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\r\n        syncCursor = match[1];\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < presenceSet.length; i++) {\r\n      const presence = presenceMessageFromValues(presenceSet[i]);\r\n      switch (presence.action) {\r\n        case 'leave':\r\n          if (members.remove(presence)) {\r\n            broadcastMessages.push(presence);\r\n          }\r\n          if (presence.connectionId === connId && !presence.isSynthesized()) {\r\n            myMembers.remove(presence);\r\n          }\r\n          break;\r\n        case 'enter':\r\n        case 'present':\r\n        case 'update':\r\n          if (members.put(presence)) {\r\n            broadcastMessages.push(presence);\r\n          }\r\n          if (presence.connectionId === connId) {\r\n            myMembers.put(presence);\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    /* if this is the last (or only) message in a sequence of sync updates, end the sync */\r\n    if (isSync && !syncCursor) {\r\n      members.endSync();\r\n      this.channel.syncChannelSerial = null;\r\n    }\r\n\r\n    /* broadcast to listeners */\r\n    for (let i = 0; i < broadcastMessages.length; i++) {\r\n      const presence = broadcastMessages[i];\r\n      this.subscriptions.emit(presence.action as string, presence);\r\n    }\r\n  }\r\n\r\n  onAttached(hasPresence?: boolean): void {\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'RealtimePresence.onAttached()',\r\n      'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence,\r\n    );\r\n\r\n    if (hasPresence) {\r\n      this.members.startSync();\r\n    } else {\r\n      this._synthesizeLeaves(this.members.values());\r\n      this.members.clear();\r\n    }\r\n\r\n    // RTP17f: Re-enter own members when moving into the attached state.\r\n    this._ensureMyMembersPresent();\r\n\r\n    /* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */\r\n    const pendingPresence = this.pendingPresence,\r\n      pendingPresCount = pendingPresence.length;\r\n\r\n    if (pendingPresCount) {\r\n      this.pendingPresence = [];\r\n      const presenceArray = [];\r\n      const multicaster = Multicaster.create();\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'RealtimePresence.onAttached',\r\n        'sending ' + pendingPresCount + ' queued presence messages',\r\n      );\r\n      for (let i = 0; i < pendingPresCount; i++) {\r\n        const event = pendingPresence[i];\r\n        presenceArray.push(event.presence);\r\n        multicaster.push(event.callback);\r\n      }\r\n      this.channel.sendPresence(presenceArray, multicaster);\r\n    }\r\n  }\r\n\r\n  actOnChannelState(state: string, hasPresence?: boolean, err?: ErrorInfo | null): void {\r\n    switch (state) {\r\n      case 'attached':\r\n        this.onAttached(hasPresence);\r\n        break;\r\n      case 'detached':\r\n      case 'failed':\r\n        this._clearMyMembers();\r\n        this.members.clear();\r\n      /* falls through */\r\n      case 'suspended':\r\n        this.failPendingPresence(err);\r\n        break;\r\n    }\r\n  }\r\n\r\n  failPendingPresence(err?: ErrorInfo | null): void {\r\n    if (this.pendingPresence.length) {\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'RealtimeChannel.failPendingPresence',\r\n        'channel; name = ' + this.channel.name + ', err = ' + Utils.inspectError(err),\r\n      );\r\n      for (let i = 0; i < this.pendingPresence.length; i++)\r\n        try {\r\n          this.pendingPresence[i].callback(err);\r\n          // eslint-disable-next-line no-empty\r\n        } catch (e) {}\r\n      this.pendingPresence = [];\r\n    }\r\n  }\r\n\r\n  _clearMyMembers(): void {\r\n    this._myMembers.clear();\r\n  }\r\n\r\n  _ensureMyMembersPresent(): void {\r\n    const myMembers = this._myMembers,\r\n      reenterCb = (err?: ErrorInfo | null) => {\r\n        if (err) {\r\n          const msg = 'Presence auto-re-enter failed: ' + err.toString();\r\n          const wrappedErr = new ErrorInfo(msg, 91004, 400);\r\n          Logger.logAction(Logger.LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);\r\n          const change = new ChannelStateChange(this.channel.state, this.channel.state, true, false, wrappedErr);\r\n          this.channel.emit('update', change);\r\n        }\r\n      };\r\n\r\n    for (const memberKey in myMembers.map) {\r\n      const entry = myMembers.map[memberKey];\r\n      Logger.logAction(\r\n        Logger.LOG_MICRO,\r\n        'RealtimePresence._ensureMyMembersPresent()',\r\n        'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set',\r\n      );\r\n      // RTP17g: Send ENTER containing the member id, clientId and data\r\n      // attributes.\r\n      Utils.whenPromiseSettles(this._enterOrUpdateClient(entry.id, entry.clientId, entry.data, 'enter'), reenterCb);\r\n    }\r\n  }\r\n\r\n  _synthesizeLeaves(items: PresenceMessage[]): void {\r\n    const subscriptions = this.subscriptions;\r\n    items.forEach(function (item) {\r\n      const presence = presenceMessageFromValues({\r\n        action: 'leave',\r\n        connectionId: item.connectionId,\r\n        clientId: item.clientId,\r\n        data: item.data,\r\n        encoding: item.encoding,\r\n        timestamp: Date.now(),\r\n      });\r\n      subscriptions.emit('leave', presence);\r\n    });\r\n  }\r\n\r\n  async subscribe(..._args: unknown[] /* [event], listener */): Promise<void> {\r\n    const args = RealtimeChannel.processListenerArgs(_args);\r\n    const event = args[0];\r\n    const listener = args[1];\r\n    const channel = this.channel;\r\n\r\n    if (channel.state === 'failed') {\r\n      throw ErrorInfo.fromValues(channel.invalidStateError());\r\n    }\r\n\r\n    this.subscriptions.on(event, listener);\r\n    await channel.attach();\r\n  }\r\n\r\n  unsubscribe(..._args: unknown[] /* [event], listener */): void {\r\n    const args = RealtimeChannel.processListenerArgs(_args);\r\n    const event = args[0];\r\n    const listener = args[1];\r\n    this.subscriptions.off(event, listener);\r\n  }\r\n}\r\n\r\nclass PresenceMap extends EventEmitter {\r\n  map: Record<string, PresenceMessage>;\r\n  residualMembers: Record<string, PresenceMessage> | null;\r\n  syncInProgress: boolean;\r\n  presence: RealtimePresence;\r\n  memberKey: (item: PresenceMessage) => string;\r\n\r\n  constructor(presence: RealtimePresence, memberKey: (item: PresenceMessage) => string) {\r\n    super();\r\n    this.presence = presence;\r\n    this.map = Object.create(null);\r\n    this.syncInProgress = false;\r\n    this.residualMembers = null;\r\n    this.memberKey = memberKey;\r\n  }\r\n\r\n  get(key: string) {\r\n    return this.map[key];\r\n  }\r\n\r\n  getClient(clientId: string) {\r\n    const map = this.map,\r\n      result = [];\r\n    for (const key in map) {\r\n      const item = map[key];\r\n      if (item.clientId == clientId && item.action != 'absent') result.push(item);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  list(params: RealtimePresenceParams) {\r\n    const map = this.map,\r\n      clientId = params && params.clientId,\r\n      connectionId = params && params.connectionId,\r\n      result = [];\r\n\r\n    for (const key in map) {\r\n      const item = map[key];\r\n      if (item.action === 'absent') continue;\r\n      if (clientId && clientId != item.clientId) continue;\r\n      if (connectionId && connectionId != item.connectionId) continue;\r\n      result.push(item);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  put(item: PresenceMessage) {\r\n    if (item.action === 'enter' || item.action === 'update') {\r\n      item = presenceMessageFromValues(item);\r\n      item.action = 'present';\r\n    }\r\n    const map = this.map,\r\n      key = this.memberKey(item);\r\n    /* we've seen this member, so do not remove it at the end of sync */\r\n    if (this.residualMembers) delete this.residualMembers[key];\r\n\r\n    /* compare the timestamp of the new item with any existing member (or ABSENT witness) */\r\n    const existingItem = map[key];\r\n    if (existingItem && !newerThan(item, existingItem)) {\r\n      return false;\r\n    }\r\n    map[key] = item;\r\n    return true;\r\n  }\r\n\r\n  values() {\r\n    const map = this.map,\r\n      result = [];\r\n    for (const key in map) {\r\n      const item = map[key];\r\n      if (item.action != 'absent') result.push(item);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  remove(item: PresenceMessage) {\r\n    const map = this.map,\r\n      key = this.memberKey(item);\r\n    const existingItem = map[key];\r\n\r\n    if (existingItem && !newerThan(item, existingItem)) {\r\n      return false;\r\n    }\r\n\r\n    /* RTP2f */\r\n    if (this.syncInProgress) {\r\n      item = presenceMessageFromValues(item);\r\n      item.action = 'absent';\r\n      map[key] = item;\r\n    } else {\r\n      delete map[key];\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  startSync() {\r\n    const map = this.map,\r\n      syncInProgress = this.syncInProgress;\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'PresenceMap.startSync()',\r\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\r\n    );\r\n    /* we might be called multiple times while a sync is in progress */\r\n    if (!this.syncInProgress) {\r\n      this.residualMembers = Utils.copy(map);\r\n      this.setInProgress(true);\r\n    }\r\n  }\r\n\r\n  endSync() {\r\n    const map = this.map,\r\n      syncInProgress = this.syncInProgress;\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'PresenceMap.endSync()',\r\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\r\n    );\r\n    if (syncInProgress) {\r\n      /* we can now strip out the ABSENT members, as we have\r\n       * received all of the out-of-order sync messages */\r\n      for (const memberKey in map) {\r\n        const entry = map[memberKey];\r\n        if (entry.action === 'absent') {\r\n          delete map[memberKey];\r\n        }\r\n      }\r\n      /* any members that were present at the start of the sync,\r\n       * and have not been seen in sync, can be removed, and leave events emitted */\r\n      this.presence._synthesizeLeaves(Utils.valuesArray(this.residualMembers as Record<string, PresenceMessage>));\r\n      for (const memberKey in this.residualMembers) {\r\n        delete map[memberKey];\r\n      }\r\n      this.residualMembers = null;\r\n\r\n      /* finish, notifying any waiters */\r\n      this.setInProgress(false);\r\n    }\r\n    this.emit('sync');\r\n  }\r\n\r\n  waitSync(callback: () => void) {\r\n    const syncInProgress = this.syncInProgress;\r\n    Logger.logAction(\r\n      Logger.LOG_MINOR,\r\n      'PresenceMap.waitSync()',\r\n      'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress,\r\n    );\r\n    if (!syncInProgress) {\r\n      callback();\r\n      return;\r\n    }\r\n    this.once('sync', callback);\r\n  }\r\n\r\n  clear() {\r\n    this.map = {};\r\n    this.setInProgress(false);\r\n    this.residualMembers = null;\r\n  }\r\n\r\n  setInProgress(inProgress: boolean) {\r\n    Logger.logAction(Logger.LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);\r\n    this.syncInProgress = inProgress;\r\n    this.presence.syncComplete = !inProgress;\r\n  }\r\n}\r\n\r\nexport default RealtimePresence;\r\n","import Platform from 'common/platform';\r\nimport * as Utils from '../util/utils';\r\nimport Transport from './transport';\r\nimport Defaults from '../util/defaults';\r\nimport Logger from '../util/logger';\r\nimport ProtocolMessage, {\r\n  serialize as serializeProtocolMessage,\r\n  deserialize as deserializeProtocolMessage,\r\n} from '../types/protocolmessage';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport NodeWebSocket from 'ws';\r\nimport ConnectionManager, { TransportParams } from './connectionmanager';\r\nimport Auth from '../client/auth';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\n\r\nconst shortName = TransportNames.WebSocket;\r\n\r\nfunction isNodeWebSocket(ws: WebSocket | NodeWebSocket): ws is NodeWebSocket {\r\n  return !!(ws as NodeWebSocket).on;\r\n}\r\n\r\nclass WebSocketTransport extends Transport {\r\n  shortName = shortName;\r\n  wsHost: string;\r\n  uri?: string;\r\n  wsConnection?: WebSocket | NodeWebSocket;\r\n\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\r\n    super(connectionManager, auth, params);\r\n    /* If is a browser, can't detect pings, so request protocol heartbeats */\r\n    params.heartbeats = Platform.Config.useProtocolHeartbeats;\r\n    this.wsHost = params.host as string;\r\n  }\r\n\r\n  static isAvailable() {\r\n    return !!Platform.Config.WebSocket;\r\n  }\r\n\r\n  createWebSocket(uri: string, connectParams: Record<string, string>) {\r\n    this.uri = uri + Utils.toQueryString(connectParams);\r\n    return new Platform.Config.WebSocket(this.uri);\r\n  }\r\n\r\n  toString() {\r\n    return 'WebSocketTransport; uri=' + this.uri;\r\n  }\r\n\r\n  connect() {\r\n    Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'starting');\r\n    Transport.prototype.connect.call(this);\r\n    const self = this,\r\n      params = this.params,\r\n      options = params.options;\r\n    const wsScheme = options.tls ? 'wss://' : 'ws://';\r\n    const wsUri = wsScheme + this.wsHost + ':' + Defaults.getPort(options) + '/';\r\n    Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);\r\n    Utils.whenPromiseSettles(\r\n      this.auth.getAuthParams(),\r\n      function (err: ErrorInfo | null, authParams?: Record<string, string>) {\r\n        if (self.isDisposed) {\r\n          return;\r\n        }\r\n        let paramStr = '';\r\n        for (const param in authParams) paramStr += ' ' + param + ': ' + authParams[param] + ';';\r\n        Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.connect()', 'authParams:' + paramStr + ' err: ' + err);\r\n        if (err) {\r\n          self.disconnect(err);\r\n          return;\r\n        }\r\n        const connectParams = params.getConnectParams(authParams!);\r\n        try {\r\n          const wsConnection = (self.wsConnection = self.createWebSocket(wsUri, connectParams));\r\n          wsConnection.binaryType = Platform.Config.binaryType;\r\n          wsConnection.onopen = function () {\r\n            self.onWsOpen();\r\n          };\r\n          wsConnection.onclose = function (ev: CloseEvent) {\r\n            self.onWsClose(ev);\r\n          };\r\n          wsConnection.onmessage = function (ev: MessageEvent) {\r\n            self.onWsData(ev.data);\r\n          };\r\n          wsConnection.onerror = function (ev: Event) {\r\n            self.onWsError(ev as ErrorEvent);\r\n          };\r\n          if (isNodeWebSocket(wsConnection)) {\r\n            /* node; browsers currently don't have a general eventemitter and can't detect\r\n             * pings. Also, no need to reply with a pong explicitly, ws lib handles that */\r\n            wsConnection.on('ping', function () {\r\n              self.onActivity();\r\n            });\r\n          }\r\n        } catch (e) {\r\n          Logger.logAction(\r\n            Logger.LOG_ERROR,\r\n            'WebSocketTransport.connect()',\r\n            'Unexpected exception creating websocket: err = ' + ((e as Error).stack || (e as Error).message),\r\n          );\r\n          self.disconnect(e as Error);\r\n        }\r\n      },\r\n    );\r\n  }\r\n\r\n  send(message: ProtocolMessage) {\r\n    const wsConnection = this.wsConnection;\r\n    if (!wsConnection) {\r\n      Logger.logAction(Logger.LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');\r\n      return;\r\n    }\r\n    try {\r\n      (wsConnection as NodeWebSocket).send(\r\n        serializeProtocolMessage(message, this.connectionManager.realtime._MsgPack, this.params.format),\r\n      );\r\n    } catch (e) {\r\n      const msg = 'Exception from ws connection when trying to send: ' + Utils.inspectError(e);\r\n      Logger.logAction(Logger.LOG_ERROR, 'WebSocketTransport.send()', msg);\r\n      /* Don't try to request a disconnect, that'll just involve sending data\r\n       * down the websocket again. Just finish the transport. */\r\n      this.finish('disconnected', new ErrorInfo(msg, 50000, 500));\r\n    }\r\n  }\r\n\r\n  onWsData(data: string) {\r\n    Logger.logAction(\r\n      Logger.LOG_MICRO,\r\n      'WebSocketTransport.onWsData()',\r\n      'data received; length = ' + data.length + '; type = ' + typeof data,\r\n    );\r\n    try {\r\n      this.onProtocolMessage(\r\n        deserializeProtocolMessage(\r\n          data,\r\n          this.connectionManager.realtime._MsgPack,\r\n          this.connectionManager.realtime._RealtimePresence,\r\n          this.format,\r\n        ),\r\n      );\r\n    } catch (e) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'WebSocketTransport.onWsData()',\r\n        'Unexpected exception handing channel message: ' + (e as Error).stack,\r\n      );\r\n    }\r\n  }\r\n\r\n  onWsOpen() {\r\n    Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');\r\n    this.emit('preconnect');\r\n  }\r\n\r\n  onWsClose(ev: number | CloseEvent) {\r\n    let wasClean, code;\r\n    if (typeof ev == 'object') {\r\n      /* W3C spec-compatible */\r\n      code = ev.code;\r\n      // ev.wasClean is undefined in reactnative\r\n      wasClean = ev.wasClean || code === 1000;\r\n    } /*if(typeof(ev) == 'number')*/ else {\r\n      /* ws in node */\r\n      code = ev;\r\n      wasClean = code == 1000;\r\n    }\r\n    delete this.wsConnection;\r\n    if (wasClean) {\r\n      Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');\r\n      const err = new ErrorInfo('Websocket closed', 80003, 400);\r\n      this.finish('disconnected', err);\r\n    } else {\r\n      const msg = 'Unclean disconnection of WebSocket ; code = ' + code,\r\n        err = new ErrorInfo(msg, 80003, 400);\r\n      Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);\r\n      this.finish('disconnected', err);\r\n    }\r\n    this.emit('disposed');\r\n  }\r\n\r\n  onWsError(err: ErrorEvent) {\r\n    Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.onError()', 'Error from WebSocket: ' + err.message);\r\n    /* Wait a tick before aborting: if the websocket was connected, this event\r\n     * will be immediately followed by an onclose event with a close code. Allow\r\n     * that to close it (so we see the close code) rather than anticipating it */\r\n    Platform.Config.nextTick(() => {\r\n      this.disconnect(Error(err.message));\r\n    });\r\n  }\r\n\r\n  dispose() {\r\n    Logger.logAction(Logger.LOG_MINOR, 'WebSocketTransport.dispose()', '');\r\n    this.isDisposed = true;\r\n    const wsConnection = this.wsConnection;\r\n    if (wsConnection) {\r\n      /* Ignore any messages that come through after dispose() is called but before\r\n       * websocket is actually closed. (mostly would be harmless, but if it's a\r\n       * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */\r\n      wsConnection.onmessage = function () {};\r\n      delete this.wsConnection;\r\n      /* defer until the next event loop cycle before closing the socket,\r\n       * giving some implementations the opportunity to send any outstanding close message */\r\n      Platform.Config.nextTick(function () {\r\n        Logger.logAction(Logger.LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');\r\n        if (!wsConnection) {\r\n          throw new Error('WebSocketTransport.dispose(): wsConnection is not defined');\r\n        }\r\n        wsConnection.close();\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nexport default WebSocketTransport;\r\n","import * as API from '../../../../ably';\r\nimport RealtimeChannel from './realtimechannel';\r\nimport Message from '../types/message';\r\n\r\nexport class FilteredSubscriptions {\r\n  static subscribeFilter(channel: RealtimeChannel, filter: API.MessageFilter, listener: API.messageCallback<Message>) {\r\n    const filteredListener = (m: Message) => {\r\n      const mapping: { [key in keyof API.MessageFilter]: any } = {\r\n        name: m.name,\r\n        refTimeserial: m.extras?.ref?.timeserial,\r\n        refType: m.extras?.ref?.type,\r\n        isRef: !!m.extras?.ref?.timeserial,\r\n        clientId: m.clientId,\r\n      };\r\n      // Check if any values are defined in the filter and if they match the value in the message object\r\n      if (\r\n        Object.entries(filter).find(([key, value]) =>\r\n          value !== undefined ? mapping[key as keyof API.MessageFilter] !== value : false,\r\n        )\r\n      ) {\r\n        return;\r\n      }\r\n      listener(m);\r\n    };\r\n    this.addFilteredSubscription(channel, filter, listener, filteredListener);\r\n    channel.subscriptions.on(filteredListener);\r\n  }\r\n\r\n  // Adds a new filtered subscription\r\n  static addFilteredSubscription(\r\n    channel: RealtimeChannel,\r\n    filter: API.MessageFilter,\r\n    realListener: API.messageCallback<Message>,\r\n    filteredListener: API.messageCallback<Message>,\r\n  ) {\r\n    if (!channel.filteredSubscriptions) {\r\n      channel.filteredSubscriptions = new Map<\r\n        API.messageCallback<Message>,\r\n        Map<API.MessageFilter, API.messageCallback<Message>[]>\r\n      >();\r\n    }\r\n    if (channel.filteredSubscriptions.has(realListener)) {\r\n      const realListenerMap = channel.filteredSubscriptions.get(realListener) as Map<\r\n        API.MessageFilter,\r\n        API.messageCallback<Message>[]\r\n      >;\r\n      // Add the filtered listener to the map, or append to the array if this filter has already been used\r\n      realListenerMap.set(filter, realListenerMap?.get(filter)?.concat(filteredListener) || [filteredListener]);\r\n    } else {\r\n      channel.filteredSubscriptions.set(\r\n        realListener,\r\n        new Map<API.MessageFilter, API.messageCallback<Message>[]>([[filter, [filteredListener]]]),\r\n      );\r\n    }\r\n  }\r\n\r\n  static getAndDeleteFilteredSubscriptions(\r\n    channel: RealtimeChannel,\r\n    filter: API.MessageFilter | undefined,\r\n    realListener: API.messageCallback<Message> | undefined,\r\n  ): API.messageCallback<Message>[] {\r\n    // No filtered subscriptions map means there has been no filtered subscriptions yet, so return nothing\r\n    if (!channel.filteredSubscriptions) {\r\n      return [];\r\n    }\r\n    // Only a filter is passed in with no specific listener\r\n    if (!realListener && filter) {\r\n      // Return each listener which is attached to the specified filter object\r\n      return Array.from(channel.filteredSubscriptions.entries())\r\n        .map(([key, filterMaps]) => {\r\n          // Get (then delete) the maps matching this filter\r\n          let listenerMaps = filterMaps.get(filter);\r\n          filterMaps.delete(filter);\r\n          // Clear the parent if nothing is left\r\n          if (filterMaps.size === 0) {\r\n            channel.filteredSubscriptions?.delete(key);\r\n          }\r\n          return listenerMaps;\r\n        })\r\n        .reduce(\r\n          (prev, cur) => (cur ? (prev as API.messageCallback<Message>[]).concat(...cur) : prev),\r\n          [],\r\n        ) as API.messageCallback<Message>[];\r\n    }\r\n\r\n    // No subscriptions for this listener\r\n    if (!realListener || !channel.filteredSubscriptions.has(realListener)) {\r\n      return [];\r\n    }\r\n    const realListenerMap = channel.filteredSubscriptions.get(realListener) as Map<\r\n      API.MessageFilter,\r\n      API.messageCallback<Message>[]\r\n    >;\r\n    // If no filter is specified return all listeners using that function\r\n    if (!filter) {\r\n      // array.flat is not available unless we support es2019 or higher\r\n      const listeners = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);\r\n      // remove the listener from the map\r\n      channel.filteredSubscriptions.delete(realListener);\r\n      return listeners;\r\n    }\r\n\r\n    let listeners = realListenerMap.get(filter);\r\n    realListenerMap.delete(filter);\r\n\r\n    return listeners || [];\r\n  }\r\n}\r\n","import BaseRealtime from './baserealtime';\r\nimport ClientOptions from '../../types/ClientOptions';\r\nimport { allCommonModularPlugins } from './modularplugins';\r\nimport * as Utils from '../util/utils';\r\nimport ConnectionManager from '../transport/connectionmanager';\r\nimport ProtocolMessage from '../types/protocolmessage';\r\nimport Platform from 'common/platform';\r\nimport { DefaultMessage } from '../types/defaultmessage';\r\nimport { MsgPack } from 'common/types/msgpack';\r\nimport RealtimePresence from './realtimepresence';\r\nimport { DefaultPresenceMessage } from '../types/defaultpresencemessage';\r\nimport WebSocketTransport from '../transport/websockettransport';\r\nimport { FilteredSubscriptions } from './filteredsubscriptions';\r\nimport {\r\n  fromValues as presenceMessageFromValues,\r\n  fromValuesArray as presenceMessagesFromValuesArray,\r\n} from '../types/presencemessage';\r\nimport { Http } from 'common/types/http';\r\nimport Defaults from '../util/defaults';\r\n\r\n/**\r\n `DefaultRealtime` is the class that the non tree-shakable version of the SDK exports as `Realtime`. It ensures that this version of the SDK includes all of the functionality which is optionally available in the tree-shakable version.\r\n */\r\nexport class DefaultRealtime extends BaseRealtime {\r\n  // The public typings declare that this requires an argument to be passed, but since we want to emit a good error message in the case where a non-TypeScript user does not pass an argument, tell the compiler that this is possible so that it forces us to handle it.\r\n  constructor(options?: ClientOptions | string) {\r\n    const MsgPack = DefaultRealtime._MsgPack;\r\n    if (!MsgPack) {\r\n      throw new Error('Expected DefaultRealtime._MsgPack to have been set');\r\n    }\r\n\r\n    super(\r\n      Defaults.objectifyOptions(options, true, 'Realtime', {\r\n        ...allCommonModularPlugins,\r\n        Crypto: DefaultRealtime.Crypto ?? undefined,\r\n        MsgPack,\r\n        RealtimePresence: {\r\n          RealtimePresence,\r\n          presenceMessageFromValues,\r\n          presenceMessagesFromValuesArray,\r\n        },\r\n        WebSocketTransport,\r\n        MessageInteractions: FilteredSubscriptions,\r\n      }),\r\n    );\r\n  }\r\n\r\n  static Utils = Utils;\r\n  static ConnectionManager = ConnectionManager;\r\n  static ProtocolMessage = ProtocolMessage;\r\n\r\n  private static _Crypto: typeof Platform.Crypto = null;\r\n  static get Crypto() {\r\n    if (this._Crypto === null) {\r\n      throw new Error('Encryption not enabled; use ably.encryption.js instead');\r\n    }\r\n\r\n    return this._Crypto;\r\n  }\r\n  static set Crypto(newValue: typeof Platform.Crypto) {\r\n    this._Crypto = newValue;\r\n  }\r\n\r\n  static Message = DefaultMessage;\r\n  static PresenceMessage = DefaultPresenceMessage;\r\n\r\n  static _MsgPack: MsgPack | null = null;\r\n\r\n  // Used by tests\r\n  static _Http = Http;\r\n}\r\n","/**\r\n * Copied from https://gist.github.com/stevendesu/2d52f7b5e1f1184af3b667c0b5e054b8\r\n *\r\n * \"A simple, open-source, HMAC-SHA256 implementation in pure JavaScript. Designed for efficient minification.\"\r\n *\r\n * I asked about licensing, and the author said:\r\n *\r\n * > Feel free to use it however you'd like ðŸ˜„ As the gist title indicates,\r\n * > this is \"a simple open source implementation\". Feel free to choose whatever\r\n * > license you find most permissible, but I offer no warranty for the code.\r\n * > It's 100% free to do with as you please.\r\n */\r\n\r\n// To ensure cross-browser support even without a proper SubtleCrypto\r\n// impelmentation (or without access to the impelmentation, as is the case with\r\n// Chrome loaded over HTTP instead of HTTPS), this library can create SHA-256\r\n// HMAC signatures using nothing but raw JavaScript\r\n\r\n/* eslint-disable no-magic-numbers, id-length, no-param-reassign, new-cap */\r\n\r\n// By giving internal functions names that we can mangle, future calls to\r\n// them are reduced to a single byte (minor space savings in minified file)\r\nvar uint8Array = Uint8Array;\r\nvar uint32Array = Uint32Array;\r\nvar pow = Math.pow;\r\n\r\n// Will be initialized below\r\n// Using a Uint32Array instead of a simple array makes the minified code\r\n// a bit bigger (we lose our `unshift()` hack), but comes with huge\r\n// performance gains\r\nvar DEFAULT_STATE = new uint32Array(8);\r\nvar ROUND_CONSTANTS: number[] = [];\r\n\r\n// Reusable object for expanded message\r\n// Using a Uint32Array instead of a simple array makes the minified code\r\n// 7 bytes larger, but comes with huge performance gains\r\nvar M = new uint32Array(64);\r\n\r\n// After minification the code to compute the default state and round\r\n// constants is smaller than the output. More importantly, this serves as a\r\n// good educational aide for anyone wondering where the magic numbers come\r\n// from. No magic numbers FTW!\r\nfunction getFractionalBits(n: number) {\r\n  return ((n - (n | 0)) * pow(2, 32)) | 0;\r\n}\r\n\r\nvar n = 2,\r\n  nPrime = 0;\r\nwhile (nPrime < 64) {\r\n  // isPrime() was in-lined from its original function form to save\r\n  // a few bytes\r\n  var isPrime = true;\r\n  // Math.sqrt() was replaced with pow(n, 1/2) to save a few bytes\r\n  // var sqrtN = pow(n, 1 / 2);\r\n  // So technically to determine if a number is prime you only need to\r\n  // check numbers up to the square root. However this function only runs\r\n  // once and we're only computing the first 64 primes (up to 311), so on\r\n  // any modern CPU this whole function runs in a couple milliseconds.\r\n  // By going to n / 2 instead of sqrt(n) we net 8 byte savings and no\r\n  // scaling performance cost\r\n  for (var factor = 2; factor <= n / 2; factor++) {\r\n    if (n % factor === 0) {\r\n      isPrime = false;\r\n    }\r\n  }\r\n  if (isPrime) {\r\n    if (nPrime < 8) {\r\n      DEFAULT_STATE[nPrime] = getFractionalBits(pow(n, 1 / 2));\r\n    }\r\n    ROUND_CONSTANTS[nPrime] = getFractionalBits(pow(n, 1 / 3));\r\n\r\n    nPrime++;\r\n  }\r\n\r\n  n++;\r\n}\r\n\r\n// For cross-platform support we need to ensure that all 32-bit words are\r\n// in the same endianness. A UTF-8 TextEncoder will return BigEndian data,\r\n// so upon reading or writing to our ArrayBuffer we'll only swap the bytes\r\n// if our system is LittleEndian (which is about 99% of CPUs)\r\nvar LittleEndian = !!new uint8Array(new uint32Array([1]).buffer)[0];\r\n\r\nfunction convertEndian(word: number) {\r\n  if (LittleEndian) {\r\n    return (\r\n      // byte 1 -> byte 4\r\n      (word >>> 24) |\r\n      // byte 2 -> byte 3\r\n      (((word >>> 16) & 0xff) << 8) |\r\n      // byte 3 -> byte 2\r\n      ((word & 0xff00) << 8) |\r\n      // byte 4 -> byte 1\r\n      (word << 24)\r\n    );\r\n  } else {\r\n    return word;\r\n  }\r\n}\r\n\r\nfunction rightRotate(word: number, bits: number) {\r\n  return (word >>> bits) | (word << (32 - bits));\r\n}\r\n\r\nfunction sha256(data: Uint8Array) {\r\n  // Copy default state\r\n  var STATE = DEFAULT_STATE.slice();\r\n\r\n  // Caching this reduces occurrences of \".length\" in minified JavaScript\r\n  // 3 more byte savings! :D\r\n  var legth = data.length;\r\n\r\n  // Pad data\r\n  var bitLength = legth * 8;\r\n  var newBitLength = 512 - ((bitLength + 64) % 512) - 1 + bitLength + 65;\r\n\r\n  // \"bytes\" and \"words\" are stored BigEndian\r\n  var bytes = new uint8Array(newBitLength / 8);\r\n  var words = new uint32Array(bytes.buffer);\r\n\r\n  bytes.set(data, 0);\r\n  // Append a 1\r\n  bytes[legth] = 0b10000000;\r\n  // Store length in BigEndian\r\n  words[words.length - 1] = convertEndian(bitLength);\r\n\r\n  // Loop iterator (avoid two instances of \"var\") -- saves 2 bytes\r\n  var round;\r\n\r\n  // Process blocks (512 bits / 64 bytes / 16 words at a time)\r\n  for (var block = 0; block < newBitLength / 32; block += 16) {\r\n    var workingState = STATE.slice();\r\n\r\n    // Rounds\r\n    for (round = 0; round < 64; round++) {\r\n      var MRound;\r\n      // Expand message\r\n      if (round < 16) {\r\n        // Convert to platform Endianness for later math\r\n        MRound = convertEndian(words[block + round]);\r\n      } else {\r\n        var gamma0x = M[round - 15];\r\n        var gamma1x = M[round - 2];\r\n        MRound =\r\n          M[round - 7] +\r\n          M[round - 16] +\r\n          (rightRotate(gamma0x, 7) ^ rightRotate(gamma0x, 18) ^ (gamma0x >>> 3)) +\r\n          (rightRotate(gamma1x, 17) ^ rightRotate(gamma1x, 19) ^ (gamma1x >>> 10));\r\n      }\r\n\r\n      // M array matches platform endianness\r\n      M[round] = MRound |= 0;\r\n\r\n      // Computation\r\n      var t1 =\r\n        (rightRotate(workingState[4], 6) ^ rightRotate(workingState[4], 11) ^ rightRotate(workingState[4], 25)) +\r\n        ((workingState[4] & workingState[5]) ^ (~workingState[4] & workingState[6])) +\r\n        workingState[7] +\r\n        MRound +\r\n        ROUND_CONSTANTS[round];\r\n      var t2 =\r\n        (rightRotate(workingState[0], 2) ^ rightRotate(workingState[0], 13) ^ rightRotate(workingState[0], 22)) +\r\n        ((workingState[0] & workingState[1]) ^ (workingState[2] & (workingState[0] ^ workingState[1])));\r\n      for (var i = 7; i > 0; i--) {\r\n        workingState[i] = workingState[i - 1];\r\n      }\r\n      workingState[0] = (t1 + t2) | 0;\r\n      workingState[4] = (workingState[4] + t1) | 0;\r\n    }\r\n\r\n    // Update state\r\n    for (round = 0; round < 8; round++) {\r\n      STATE[round] = (STATE[round] + workingState[round]) | 0;\r\n    }\r\n  }\r\n\r\n  // Finally the state needs to be converted to BigEndian for output\r\n  // And we want to return a Uint8Array, not a Uint32Array\r\n  return new uint8Array(\r\n    new uint32Array(\r\n      STATE.map(function (val) {\r\n        return convertEndian(val);\r\n      }),\r\n    ).buffer,\r\n  );\r\n}\r\n\r\nexport function hmac(key: Uint8Array, data: Uint8Array) {\r\n  if (key.length > 64) key = sha256(key);\r\n\r\n  if (key.length < 64) {\r\n    const tmp = new Uint8Array(64);\r\n    tmp.set(key, 0);\r\n    key = tmp;\r\n  }\r\n\r\n  // Generate inner and outer keys\r\n  var innerKey = new Uint8Array(64);\r\n  var outerKey = new Uint8Array(64);\r\n  for (var i = 0; i < 64; i++) {\r\n    innerKey[i] = 0x36 ^ key[i];\r\n    outerKey[i] = 0x5c ^ key[i];\r\n  }\r\n\r\n  // Append the innerKey\r\n  var msg = new Uint8Array(data.length + 64);\r\n  msg.set(innerKey, 0);\r\n  msg.set(data, 64);\r\n\r\n  // Has the previous message and append the outerKey\r\n  var result = new Uint8Array(64 + 32);\r\n  result.set(outerKey, 0);\r\n  result.set(sha256(msg), 64);\r\n\r\n  // Hash the previous message\r\n  return sha256(result);\r\n}\r\n","import Platform from 'common/platform';\r\nimport IBufferUtils from 'common/types/IBufferUtils';\r\nimport { hmac as hmacSha256 } from './hmac-sha256';\r\n\r\n/* Most BufferUtils methods that return a binary object return an ArrayBuffer\r\n * The exception is toBuffer, which returns a Uint8Array (and won't work on\r\n * browsers too old to support it) */\r\n\r\nexport type Bufferlike = BufferSource;\r\nexport type Output = Bufferlike;\r\nexport type ToBufferOutput = Uint8Array;\r\n\r\nclass BufferUtils implements IBufferUtils<Bufferlike, Output, ToBufferOutput> {\r\n  base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n  hexCharSet = '0123456789abcdef';\r\n\r\n  // // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js\r\n  uint8ViewToBase64(bytes: Uint8Array) {\r\n    let base64 = '';\r\n    const encodings = this.base64CharSet;\r\n\r\n    const byteLength = bytes.byteLength;\r\n    const byteRemainder = byteLength % 3;\r\n    const mainLength = byteLength - byteRemainder;\r\n\r\n    let a, b, c, d;\r\n    let chunk;\r\n\r\n    // Main loop deals with bytes in chunks of 3\r\n    for (let i = 0; i < mainLength; i = i + 3) {\r\n      // Combine the three bytes into a single integer\r\n      chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\r\n\r\n      // Use bitmasks to extract 6-bit segments from the triplet\r\n      a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\r\n      b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\r\n      c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\r\n      d = chunk & 63; // 63       = 2^6 - 1\r\n\r\n      // Convert the raw binary segments to the appropriate ASCII encoding\r\n      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\r\n    }\r\n\r\n    // Deal with the remaining bytes and padding\r\n    if (byteRemainder == 1) {\r\n      chunk = bytes[mainLength];\r\n\r\n      a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\r\n\r\n      // Set the 4 least significant bits to zero\r\n      b = (chunk & 3) << 4; // 3   = 2^2 - 1\r\n\r\n      base64 += encodings[a] + encodings[b] + '==';\r\n    } else if (byteRemainder == 2) {\r\n      chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\r\n\r\n      a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\r\n      b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\r\n\r\n      // Set the 2 least significant bits to zero\r\n      c = (chunk & 15) << 2; // 15    = 2^4 - 1\r\n\r\n      base64 += encodings[a] + encodings[b] + encodings[c] + '=';\r\n    }\r\n\r\n    return base64;\r\n  }\r\n\r\n  base64ToArrayBuffer(base64: string) {\r\n    const binary_string = atob?.(base64) as string; // this will always be defined in browser so it's safe to cast\r\n    const len = binary_string.length;\r\n    const bytes = new Uint8Array(len);\r\n    for (let i = 0; i < len; i++) {\r\n      const ascii = binary_string.charCodeAt(i);\r\n      bytes[i] = ascii;\r\n    }\r\n    return bytes.buffer;\r\n  }\r\n\r\n  isBuffer(buffer: unknown): buffer is Bufferlike {\r\n    return buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);\r\n  }\r\n\r\n  /* In browsers, returns a Uint8Array */\r\n  toBuffer(buffer: Bufferlike): ToBufferOutput {\r\n    if (!ArrayBuffer) {\r\n      throw new Error(\"Can't convert to Buffer: browser does not support the necessary types\");\r\n    }\r\n\r\n    if (buffer instanceof ArrayBuffer) {\r\n      return new Uint8Array(buffer);\r\n    }\r\n\r\n    if (ArrayBuffer.isView(buffer)) {\r\n      return new Uint8Array(buffer.buffer);\r\n    }\r\n\r\n    throw new Error('BufferUtils.toBuffer expected an ArrayBuffer or a view onto one');\r\n  }\r\n\r\n  toArrayBuffer(buffer: Bufferlike): ArrayBuffer {\r\n    if (buffer instanceof ArrayBuffer) {\r\n      return buffer;\r\n    }\r\n    return this.toBuffer(buffer).buffer;\r\n  }\r\n\r\n  base64Encode(buffer: Bufferlike) {\r\n    return this.uint8ViewToBase64(this.toBuffer(buffer));\r\n  }\r\n\r\n  base64Decode(str: string): Output {\r\n    if (ArrayBuffer && Platform.Config.atob) {\r\n      return this.base64ToArrayBuffer(str);\r\n    } else {\r\n      throw new Error('Expected ArrayBuffer to exist and Platform.Config.atob to be configured');\r\n    }\r\n  }\r\n\r\n  hexEncode(buffer: Bufferlike) {\r\n    const arrayBuffer =\r\n      buffer instanceof ArrayBuffer\r\n        ? buffer\r\n        : buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\r\n    const uint8Array = new Uint8Array(arrayBuffer);\r\n    return uint8Array.reduce((accum, byte) => accum + byte.toString(16).padStart(2, '0'), '');\r\n  }\r\n\r\n  hexDecode(hexEncodedBytes: string) {\r\n    if (hexEncodedBytes.length % 2 !== 0) {\r\n      throw new Error(\"Can't create a byte array from a hex string of odd length\");\r\n    }\r\n\r\n    const uint8Array = new Uint8Array(hexEncodedBytes.length / 2);\r\n\r\n    for (let i = 0; i < uint8Array.length; i++) {\r\n      uint8Array[i] = parseInt(hexEncodedBytes.slice(2 * i, 2 * (i + 1)), 16);\r\n    }\r\n\r\n    return uint8Array.buffer.slice(uint8Array.byteOffset, uint8Array.byteOffset + uint8Array.byteLength);\r\n  }\r\n\r\n  utf8Encode(string: string) {\r\n    if (Platform.Config.TextEncoder) {\r\n      return new Platform.Config.TextEncoder().encode(string).buffer;\r\n    } else {\r\n      throw new Error('Expected TextEncoder to be configured');\r\n    }\r\n  }\r\n\r\n  /* For utf8 decoding we apply slightly stricter input validation than to\r\n   * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from\r\n   * can take (in particular allowing strings, which are just interpreted as\r\n   * binary); here we ensure that the input is actually a buffer since trying\r\n   * to utf8-decode a string to another string is almost certainly a mistake */\r\n  utf8Decode(buffer: Bufferlike) {\r\n    if (!this.isBuffer(buffer)) {\r\n      throw new Error('Expected input of utf8decode to be an arraybuffer or typed array');\r\n    }\r\n    if (TextDecoder) {\r\n      return new TextDecoder().decode(buffer);\r\n    } else {\r\n      throw new Error('Expected TextDecoder to be configured');\r\n    }\r\n  }\r\n\r\n  areBuffersEqual(buffer1: Bufferlike, buffer2: Bufferlike) {\r\n    if (!buffer1 || !buffer2) return false;\r\n    const arrayBuffer1 = this.toArrayBuffer(buffer1);\r\n    const arrayBuffer2 = this.toArrayBuffer(buffer2);\r\n\r\n    if (arrayBuffer1.byteLength != arrayBuffer2.byteLength) return false;\r\n\r\n    const bytes1 = new Uint8Array(arrayBuffer1);\r\n    const bytes2 = new Uint8Array(arrayBuffer2);\r\n\r\n    for (var i = 0; i < bytes1.length; i++) {\r\n      if (bytes1[i] != bytes2[i]) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  byteLength(buffer: Bufferlike) {\r\n    if (buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer)) {\r\n      return buffer.byteLength;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /* Returns ArrayBuffer on browser and Buffer on Node.js */\r\n  arrayBufferViewToBuffer(arrayBufferView: ArrayBufferView) {\r\n    return arrayBufferView.buffer;\r\n  }\r\n\r\n  hmacSha256(message: Bufferlike, key: Bufferlike): Output {\r\n    return hmacSha256(this.toBuffer(key), this.toBuffer(message));\r\n  }\r\n}\r\n\r\nexport default new BufferUtils();\r\n","import Logger from '../../../../common/lib/util/logger';\r\nimport ErrorInfo from 'common/lib/types/errorinfo';\r\nimport * as API from '../../../../../ably';\r\nimport ICryptoStatic, { IGetCipherParams } from '../../../../common/types/ICryptoStatic';\r\nimport ICipher from '../../../../common/types/ICipher';\r\nimport { CryptoDataTypes } from '../../../../common/types/cryptoDataTypes';\r\nimport BufferUtils, { Bufferlike, Output as BufferUtilsOutput } from './bufferutils';\r\nimport { IPlatformConfig } from 'common/types/IPlatformConfig';\r\n\r\n// The type to which ./msgpack.ts deserializes elements of the `bin` or `ext` type\r\ntype MessagePackBinaryType = ArrayBuffer;\r\n\r\ntype IV = CryptoDataTypes.IV<BufferUtilsOutput>;\r\ntype InputPlaintext = CryptoDataTypes.InputPlaintext<Bufferlike, BufferUtilsOutput>;\r\ntype OutputCiphertext = ArrayBuffer;\r\ntype InputCiphertext = CryptoDataTypes.InputCiphertext<MessagePackBinaryType, BufferUtilsOutput>;\r\ntype OutputPlaintext = ArrayBuffer;\r\n\r\nvar createCryptoClass = function (config: IPlatformConfig, bufferUtils: typeof BufferUtils) {\r\n  var DEFAULT_ALGORITHM = 'aes';\r\n  var DEFAULT_KEYLENGTH = 256; // bits\r\n  var DEFAULT_MODE = 'cbc';\r\n  var DEFAULT_BLOCKLENGTH = 16; // bytes\r\n\r\n  /**\r\n   * Internal: checks that the cipherParams are a valid combination. Currently\r\n   * just checks that the calculated keyLength is a valid one for aes-cbc\r\n   */\r\n  function validateCipherParams(params: API.CipherParams) {\r\n    if (params.algorithm === 'aes' && params.mode === 'cbc') {\r\n      if (params.keyLength === 128 || params.keyLength === 256) {\r\n        return;\r\n      }\r\n      throw new Error(\r\n        'Unsupported key length ' +\r\n          params.keyLength +\r\n          ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)',\r\n      );\r\n    }\r\n  }\r\n\r\n  function normaliseBase64(string: string) {\r\n    /* url-safe base64 strings use _ and - instread of / and + */\r\n    return string.replace('_', '/').replace('-', '+');\r\n  }\r\n\r\n  function isCipherParams(params: API.CipherParams | API.CipherParamOptions): params is API.CipherParams {\r\n    // Although API.CipherParams is an interface, the documentation for its `key` property makes it clear that the only valid way to form one is by using getDefaultParams. The implementation of getDefaultParams returns an instance of CipherParams.\r\n    return params instanceof CipherParams;\r\n  }\r\n\r\n  /**\r\n   * A class encapsulating the client-specifiable parameters for\r\n   * the cipher.\r\n   *\r\n   * algorithm is the name of the algorithm in the default system provider,\r\n   * or the lower-cased version of it; eg \"aes\" or \"AES\".\r\n   *\r\n   * Clients are recommended to not call this directly, but instead to use the\r\n   * Crypto.getDefaultParams helper, which will fill in any fields not supplied\r\n   * with default values and validation the result.\r\n   */\r\n  class CipherParams implements API.CipherParams {\r\n    algorithm: string;\r\n    keyLength: number;\r\n    mode: string;\r\n    key: ArrayBuffer;\r\n\r\n    constructor(algorithm: string, keyLength: number, mode: string, key: ArrayBuffer) {\r\n      this.algorithm = algorithm;\r\n      this.keyLength = keyLength;\r\n      this.mode = mode;\r\n      this.key = key;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Utility classes and interfaces for message payload encryption.\r\n   *\r\n   * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits\r\n   * but supporting other keylengths. Other algorithms and chaining modes are\r\n   * not supported directly, but supportable by extending/implementing the base\r\n   * classes and interfaces here.\r\n   *\r\n   * Secure random data for creation of Initialization Vectors (IVs) and keys\r\n   * is obtained from window.crypto.getRandomValues.\r\n   *\r\n   * Each message payload is encrypted with an IV in CBC mode, and the IV is\r\n   * concatenated with the resulting raw ciphertext to construct the \"ciphertext\"\r\n   * data passed to the recipient.\r\n   */\r\n  class Crypto {\r\n    static CipherParams = CipherParams;\r\n\r\n    /**\r\n     * Obtain a complete CipherParams instance from the provided params, filling\r\n     * in any not provided with default values, calculating a keyLength from\r\n     * the supplied key, and validating the result.\r\n     * @param params an object containing at a minimum a `key` key with value the\r\n     * key, as either a binary or a base64-encoded string.\r\n     * May optionally also contain: algorithm (defaults to AES),\r\n     * mode (defaults to 'cbc')\r\n     */\r\n    static getDefaultParams(params: API.CipherParamOptions) {\r\n      var key: ArrayBuffer;\r\n\r\n      if (!params.key) {\r\n        throw new Error('Crypto.getDefaultParams: a key is required');\r\n      }\r\n\r\n      if (typeof params.key === 'string') {\r\n        key = bufferUtils.toArrayBuffer(bufferUtils.base64Decode(normaliseBase64(params.key)));\r\n      } else if (params.key instanceof ArrayBuffer) {\r\n        key = params.key;\r\n      } else {\r\n        key = bufferUtils.toArrayBuffer(params.key);\r\n      }\r\n\r\n      var algorithm = params.algorithm || DEFAULT_ALGORITHM;\r\n      var keyLength = key.byteLength * 8;\r\n      var mode = params.mode || DEFAULT_MODE;\r\n      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);\r\n\r\n      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\r\n        throw new Error(\r\n          'Crypto.getDefaultParams: a keyLength of ' +\r\n            params.keyLength +\r\n            ' was specified, but the key actually has length ' +\r\n            cipherParams.keyLength,\r\n        );\r\n      }\r\n\r\n      validateCipherParams(cipherParams);\r\n      return cipherParams;\r\n    }\r\n\r\n    /**\r\n     * Generate a random encryption key from the supplied keylength (or the\r\n     * default keyLength if none supplied) as an ArrayBuffer\r\n     * @param keyLength (optional) the required keyLength in bits\r\n     */\r\n    static async generateRandomKey(keyLength?: number): Promise<API.CipherKey> {\r\n      try {\r\n        return config.getRandomArrayBuffer((keyLength || DEFAULT_KEYLENGTH) / 8);\r\n      } catch (err) {\r\n        throw new ErrorInfo('Failed to generate random key: ' + (err as Error).message, 400, 50000, err as Error);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Internal; get a ChannelCipher instance based on the given cipherParams\r\n     * @param params either a CipherParams instance or some subset of its\r\n     * fields that includes a key\r\n     */\r\n    static getCipher(params: IGetCipherParams<IV>) {\r\n      var cipherParams = isCipherParams(params) ? (params as CipherParams) : this.getDefaultParams(params);\r\n\r\n      return {\r\n        cipherParams: cipherParams,\r\n        cipher: new CBCCipher(cipherParams, params.iv ?? null),\r\n      };\r\n    }\r\n  }\r\n\r\n  Crypto satisfies ICryptoStatic<IV, InputPlaintext, OutputCiphertext, InputCiphertext, OutputPlaintext>;\r\n\r\n  class CBCCipher implements ICipher<InputPlaintext, OutputCiphertext, InputCiphertext, OutputPlaintext> {\r\n    algorithm: string;\r\n    webCryptoAlgorithm: string;\r\n    key: ArrayBuffer;\r\n    iv: ArrayBuffer | null;\r\n\r\n    constructor(params: CipherParams, iv: IV | null) {\r\n      if (!crypto.subtle) {\r\n        if (isSecureContext) {\r\n          throw new Error(\r\n            'Crypto operations are not possible since the browserâ€™s SubtleCrypto class is unavailable (reason unknown).',\r\n          );\r\n        } else {\r\n          throw new Error(\r\n            'Crypto operations are is not possible since the current environment is a non-secure context and hence the browserâ€™s SubtleCrypto class is not available.',\r\n          );\r\n        }\r\n      }\r\n\r\n      this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;\r\n      this.webCryptoAlgorithm = params.algorithm + '-' + params.mode;\r\n      this.key = bufferUtils.toArrayBuffer(params.key);\r\n      this.iv = iv ? bufferUtils.toArrayBuffer(iv) : null;\r\n    }\r\n\r\n    private concat(buffer1: Bufferlike, buffer2: Bufferlike) {\r\n      const output = new ArrayBuffer(buffer1.byteLength + buffer2.byteLength);\r\n      const outputView = new DataView(output);\r\n\r\n      const buffer1View = new DataView(bufferUtils.toArrayBuffer(buffer1));\r\n      for (let i = 0; i < buffer1View.byteLength; i++) {\r\n        outputView.setInt8(i, buffer1View.getInt8(i));\r\n      }\r\n\r\n      const buffer2View = new DataView(bufferUtils.toArrayBuffer(buffer2));\r\n      for (let i = 0; i < buffer2View.byteLength; i++) {\r\n        outputView.setInt8(buffer1View.byteLength + i, buffer2View.getInt8(i));\r\n      }\r\n\r\n      return output;\r\n    }\r\n\r\n    async encrypt(plaintext: InputPlaintext): Promise<OutputCiphertext> {\r\n      Logger.logAction(Logger.LOG_MICRO, 'CBCCipher.encrypt()', '');\r\n\r\n      const iv = await this.getIv();\r\n      const cryptoKey = await crypto.subtle.importKey('raw', this.key, this.webCryptoAlgorithm, false, ['encrypt']);\r\n      const ciphertext = await crypto.subtle.encrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, plaintext);\r\n\r\n      return this.concat(iv, ciphertext);\r\n    }\r\n\r\n    async decrypt(ciphertext: InputCiphertext): Promise<OutputPlaintext> {\r\n      Logger.logAction(Logger.LOG_MICRO, 'CBCCipher.decrypt()', '');\r\n\r\n      const ciphertextArrayBuffer = bufferUtils.toArrayBuffer(ciphertext);\r\n      const iv = ciphertextArrayBuffer.slice(0, DEFAULT_BLOCKLENGTH);\r\n      const ciphertextBody = ciphertextArrayBuffer.slice(DEFAULT_BLOCKLENGTH);\r\n\r\n      const cryptoKey = await crypto.subtle.importKey('raw', this.key, this.webCryptoAlgorithm, false, ['decrypt']);\r\n      return crypto.subtle.decrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, ciphertextBody);\r\n    }\r\n\r\n    async getIv(): Promise<ArrayBuffer> {\r\n      if (this.iv) {\r\n        var iv = this.iv;\r\n        this.iv = null;\r\n        return iv;\r\n      }\r\n\r\n      const randomBlock = await config.getRandomArrayBuffer(DEFAULT_BLOCKLENGTH);\r\n      return bufferUtils.toArrayBuffer(randomBlock);\r\n    }\r\n  }\r\n\r\n  return Crypto;\r\n};\r\n\r\nexport { createCryptoClass };\r\n","enum XHRStates {\n  REQ_SEND = 0,\n  REQ_RECV = 1,\n  REQ_RECV_POLL = 2,\n  REQ_RECV_STREAM = 3,\n}\n\nexport default XHRStates;\n","import Platform from 'common/platform';\r\nimport Defaults from 'common/lib/util/defaults';\r\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport { RequestBody, RequestResultError, RequestParams, RequestResult } from 'common/types/http';\r\nimport HttpMethods from 'common/constants/HttpMethods';\r\nimport BaseClient from 'common/lib/client/baseclient';\r\nimport XHRStates from 'common/constants/XHRStates';\r\nimport Logger from 'common/lib/util/logger';\r\nimport { StandardCallback } from 'common/types/utils';\r\nimport { isSuccessCode } from 'common/constants/HttpStatusCodes';\r\nimport { ModularPlugins } from 'common/lib/client/modularplugins';\r\n\r\nexport type HTTPRequestImplementations = Pick<ModularPlugins, 'XHRRequest' | 'FetchRequest'>;\r\n\r\nfunction createMissingImplementationError() {\r\n  return new ErrorInfo(\r\n    'No HTTP request plugin provided. Provide at least one of the FetchRequest or XHRRequest plugins.',\r\n    400,\r\n    40000,\r\n  );\r\n}\r\n\r\nconst Http = class {\r\n  static methods = [HttpMethods.Get, HttpMethods.Delete, HttpMethods.Post, HttpMethods.Put, HttpMethods.Patch];\r\n  static methodsWithoutBody = [HttpMethods.Get, HttpMethods.Delete];\r\n  static methodsWithBody = [HttpMethods.Post, HttpMethods.Put, HttpMethods.Patch];\r\n  // HTTP request implementations that are available even without a BaseClient object (needed by some tests which directly instantiate `Http` without a client)\r\n  static bundledRequestImplementations: HTTPRequestImplementations;\r\n  checksInProgress: Array<StandardCallback<boolean>> | null = null;\r\n  private client: BaseClient | null;\r\n\r\n  constructor(client?: BaseClient) {\r\n    this.client = client ?? null;\r\n    const connectivityCheckUrl = client?.options.connectivityCheckUrl || Defaults.connectivityCheckUrl;\r\n    const connectivityCheckParams = client?.options.connectivityCheckParams ?? null;\r\n    const connectivityUrlIsDefault = !client?.options.connectivityCheckUrl;\r\n\r\n    const requestImplementations = {\r\n      ...Http.bundledRequestImplementations,\r\n      ...client?._additionalHTTPRequestImplementations,\r\n    };\r\n    const xhrRequestImplementation = requestImplementations.XHRRequest;\r\n    const fetchRequestImplementation = requestImplementations.FetchRequest;\r\n    const hasImplementation = !!(xhrRequestImplementation || fetchRequestImplementation);\r\n\r\n    if (!hasImplementation) {\r\n      throw createMissingImplementationError();\r\n    }\r\n\r\n    if (Platform.Config.xhrSupported && xhrRequestImplementation) {\r\n      this.supportsAuthHeaders = true;\r\n      this.Request = async function (\r\n        method: HttpMethods,\r\n        uri: string,\r\n        headers: Record<string, string> | null,\r\n        params: RequestParams,\r\n        body: RequestBody | null,\r\n      ) {\r\n        return new Promise((resolve) => {\r\n          const req = xhrRequestImplementation.createRequest(\r\n            uri,\r\n            headers,\r\n            params,\r\n            body,\r\n            XHRStates.REQ_SEND,\r\n            (client && client.options.timeouts) ?? null,\r\n            method,\r\n          );\r\n          req.once(\r\n            'complete',\r\n            (\r\n              error: RequestResult['error'],\r\n              body: RequestResult['body'],\r\n              headers: RequestResult['headers'],\r\n              unpacked: RequestResult['unpacked'],\r\n              statusCode: RequestResult['statusCode'],\r\n            ) => resolve({ error, body, headers, unpacked, statusCode }),\r\n          );\r\n          req.exec();\r\n        });\r\n      };\r\n      if (client?.options.disableConnectivityCheck) {\r\n        this.checkConnectivity = async function () {\r\n          return true;\r\n        };\r\n      } else {\r\n        this.checkConnectivity = async function () {\r\n          Logger.logAction(\r\n            Logger.LOG_MICRO,\r\n            '(XHRRequest)Http.checkConnectivity()',\r\n            'Sending; ' + connectivityCheckUrl,\r\n          );\r\n\r\n          const requestResult = await this.doUri(\r\n            HttpMethods.Get,\r\n            connectivityCheckUrl,\r\n            null,\r\n            null,\r\n            connectivityCheckParams,\r\n          );\r\n\r\n          let result = false;\r\n          if (!connectivityUrlIsDefault) {\r\n            result = !requestResult.error && isSuccessCode(requestResult.statusCode as number);\r\n          } else {\r\n            result = !requestResult.error && (requestResult.body as string)?.replace(/\\n/, '') == 'yes';\r\n          }\r\n\r\n          Logger.logAction(Logger.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);\r\n          return result;\r\n        };\r\n      }\r\n    } else if (Platform.Config.fetchSupported && fetchRequestImplementation) {\r\n      this.supportsAuthHeaders = true;\r\n      this.Request = async (method, uri, headers, params, body) => {\r\n        return fetchRequestImplementation(method, client ?? null, uri, headers, params, body);\r\n      };\r\n      this.checkConnectivity = async function () {\r\n        Logger.logAction(Logger.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Sending; ' + connectivityCheckUrl);\r\n        const requestResult = await this.doUri(HttpMethods.Get, connectivityCheckUrl, null, null, null);\r\n        const result = !requestResult.error && (requestResult.body as string)?.replace(/\\n/, '') == 'yes';\r\n        Logger.logAction(Logger.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Result: ' + result);\r\n        return result;\r\n      };\r\n    } else {\r\n      this.Request = async () => {\r\n        const error = hasImplementation\r\n          ? new PartialErrorInfo('no supported HTTP transports available', null, 400)\r\n          : createMissingImplementationError();\r\n        return { error };\r\n      };\r\n    }\r\n  }\r\n\r\n  async doUri(\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    body: RequestBody | null,\r\n    params: RequestParams,\r\n  ): Promise<RequestResult> {\r\n    if (!this.Request) {\r\n      return { error: new PartialErrorInfo('Request invoked before assigned to', null, 500) };\r\n    }\r\n    return this.Request(method, uri, headers, params, body);\r\n  }\r\n\r\n  private Request?: (\r\n    method: HttpMethods,\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params: RequestParams,\r\n    body: RequestBody | null,\r\n  ) => Promise<RequestResult>;\r\n\r\n  checkConnectivity?: () => Promise<boolean> = undefined;\r\n\r\n  supportsAuthHeaders = false;\r\n  supportsLinkHeaders = false;\r\n\r\n  shouldFallback(errorInfo: RequestResultError) {\r\n    const statusCode = errorInfo.statusCode as number;\r\n    /* 400 + no code = a generic xhr onerror. Browser doesn't give us enough\r\n     * detail to know whether it's fallback-fixable, but it may be (eg if a\r\n     * network issue), so try just in case */\r\n    return (\r\n      (statusCode === 408 && !errorInfo.code) ||\r\n      (statusCode === 400 && !errorInfo.code) ||\r\n      (statusCode >= 500 && statusCode <= 504)\r\n    );\r\n  }\r\n};\r\n\r\nexport default Http;\r\n","import { IPlatformConfig } from '../../common/types/IPlatformConfig';\r\nimport * as Utils from 'common/lib/util/utils';\r\n\r\n// Workaround for salesforce lightning locker compat\r\nconst globalObject = Utils.getGlobalObject();\r\n\r\nif (typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') {\r\n  console.log(\r\n    \"Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm\",\r\n  );\r\n}\r\n\r\nfunction allowComet() {\r\n  /* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg\r\n   * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask\r\n   * So if websockets are supported, then just forget about comet transports and use that */\r\n  const loc = globalObject.location;\r\n  return !globalObject.WebSocket || !loc || !loc.origin || loc.origin.indexOf('http') > -1;\r\n}\r\n\r\n// from: https://stackoverflow.com/a/18002694\r\nexport function isWebWorkerContext(): boolean {\r\n  // run this in global scope of window or worker. since window.self = window, we're ok\r\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nconst userAgent = globalObject.navigator && globalObject.navigator.userAgent.toString();\r\nconst currentUrl = globalObject.location && globalObject.location.href;\r\n\r\nconst Config: IPlatformConfig = {\r\n  agent: 'browser',\r\n  logTimestamps: true,\r\n  userAgent: userAgent,\r\n  currentUrl: currentUrl,\r\n  binaryType: 'arraybuffer',\r\n  WebSocket: globalObject.WebSocket,\r\n  fetchSupported: !!globalObject.fetch,\r\n  xhrSupported: globalObject.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),\r\n  allowComet: allowComet(),\r\n  useProtocolHeartbeats: true,\r\n  supportsBinary: !!globalObject.TextDecoder,\r\n  /* Per Paddy (https://ably-real-time.slack.com/archives/CURL4U2FP/p1705674537763479) web intentionally prefers JSON to MessagePack:\r\n   *\r\n   * > browsers' support for binary types in general was historically poor, and JSON transport performance is significantly better in a browser than msgpack. In modern browsers then binary is supported consistently, but I'd still expect that JSON encode/decode performance is dramatically better than msgpack in a browser.\r\n   */\r\n  preferBinary: false,\r\n  ArrayBuffer: globalObject.ArrayBuffer,\r\n  atob: globalObject.atob,\r\n  nextTick:\r\n    typeof globalObject.setImmediate !== 'undefined'\r\n      ? globalObject.setImmediate.bind(globalObject)\r\n      : function (f: () => void) {\r\n          setTimeout(f, 0);\r\n        },\r\n  addEventListener: globalObject.addEventListener,\r\n  inspect: JSON.stringify,\r\n  stringByteSize: function (str: string) {\r\n    /* str.length will be an underestimate for non-ascii strings. But if we're\r\n     * in a browser too old to support TextDecoder, not much we can do. Better\r\n     * to underestimate, so if we do go over-size, the server will reject the\r\n     * message */\r\n    return (globalObject.TextDecoder && new globalObject.TextEncoder().encode(str).length) || str.length;\r\n  },\r\n  TextEncoder: globalObject.TextEncoder,\r\n  TextDecoder: globalObject.TextDecoder,\r\n  getRandomArrayBuffer: async function (byteLength: number): Promise<ArrayBuffer> {\r\n    const byteArray = new Uint8Array(byteLength);\r\n    globalObject.crypto.getRandomValues(byteArray);\r\n    return byteArray.buffer;\r\n  },\r\n  isWebworker: isWebWorkerContext(),\r\n};\r\n\r\nexport default Config;\r\n","import * as Utils from '../util/utils';\r\nimport ProtocolMessage, {\r\n  actions,\r\n  fromValues as protocolMessageFromValues,\r\n  fromDeserialized as protocolMessageFromDeserialized,\r\n} from '../types/protocolmessage';\r\nimport Transport from './transport';\r\nimport Logger from '../util/logger';\r\nimport Defaults from '../util/defaults';\r\nimport ConnectionErrors from './connectionerrors';\r\nimport Auth from '../client/auth';\r\nimport ErrorInfo from '../types/errorinfo';\r\nimport IXHRRequest from '../../types/IXHRRequest';\r\nimport * as API from '../../../../ably';\r\nimport ConnectionManager, { TransportParams } from './connectionmanager';\r\nimport XHRStates from '../../constants/XHRStates';\r\nimport Platform from 'common/platform';\r\n\r\n/* TODO: can remove once realtime sends protocol message responses for comet errors */\r\nfunction shouldBeErrorAction(err: ErrorInfo) {\r\n  const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\r\n  if (err.code) {\r\n    if (Auth.isTokenErr(err)) return false;\r\n    if (UNRESOLVABLE_ERROR_CODES.includes(err.code)) return true;\r\n    return err.code >= 40000 && err.code < 50000;\r\n  } else {\r\n    /* Likely a network or transport error of some kind. Certainly not fatal to the connection */\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction protocolMessageFromRawError(err: ErrorInfo) {\r\n  /* err will be either a legacy (non-protocolmessage) comet error response\r\n   * (which will have an err.code), or a xhr/network error (which won't). */\r\n  if (shouldBeErrorAction(err)) {\r\n    return [protocolMessageFromValues({ action: actions.ERROR, error: err })];\r\n  } else {\r\n    return [protocolMessageFromValues({ action: actions.DISCONNECTED, error: err })];\r\n  }\r\n}\r\n\r\n/*\r\n * A base comet transport class\r\n */\r\nabstract class CometTransport extends Transport {\r\n  stream: string | boolean;\r\n  sendRequest: IXHRRequest | null;\r\n  recvRequest: null | IXHRRequest;\r\n  pendingCallback: null;\r\n  pendingItems: null | Array<ProtocolMessage>;\r\n  baseUri?: string;\r\n  authParams?: Record<string, any>;\r\n  closeUri?: string;\r\n  disconnectUri?: string;\r\n  sendUri?: string;\r\n  recvUri?: string;\r\n\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\r\n    super(connectionManager, auth, params, /* binary not supported for comet so force JSON protocol */ true);\r\n    this.stream = 'stream' in params ? params.stream : true;\r\n    this.sendRequest = null;\r\n    this.recvRequest = null;\r\n    this.pendingCallback = null;\r\n    this.pendingItems = null;\r\n  }\r\n\r\n  abstract createRequest(\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params?: Record<string, unknown> | null,\r\n    body?: unknown,\r\n    requestMode?: number,\r\n  ): IXHRRequest;\r\n\r\n  connect(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'CometTransport.connect()', 'starting');\r\n    Transport.prototype.connect.call(this);\r\n    const params = this.params;\r\n    const options = params.options;\r\n    const host = Defaults.getHost(options, params.host);\r\n    const port = Defaults.getPort(options);\r\n    const cometScheme = options.tls ? 'https://' : 'http://';\r\n\r\n    this.baseUri = cometScheme + host + ':' + port + '/comet/';\r\n    const connectUri = this.baseUri + 'connect';\r\n    Logger.logAction(Logger.LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);\r\n    Utils.whenPromiseSettles(this.auth.getAuthParams(), (err: Error | null, authParams?: Record<string, any>) => {\r\n      if (err) {\r\n        this.disconnect(err);\r\n        return;\r\n      }\r\n      if (this.isDisposed) {\r\n        return;\r\n      }\r\n      this.authParams = authParams;\r\n      const connectParams = this.params.getConnectParams(authParams!);\r\n      if ('stream' in connectParams) this.stream = connectParams.stream;\r\n      Logger.logAction(\r\n        Logger.LOG_MINOR,\r\n        'CometTransport.connect()',\r\n        'connectParams:' + Utils.toQueryString(connectParams),\r\n      );\r\n\r\n      /* this will be the 'recvRequest' so this connection can stream messages */\r\n      let preconnected = false;\r\n      const connectRequest = (this.recvRequest = this.createRequest(\r\n        connectUri,\r\n        null,\r\n        connectParams,\r\n        null,\r\n        this.stream ? XHRStates.REQ_RECV_STREAM : XHRStates.REQ_RECV,\r\n      ));\r\n\r\n      connectRequest.on('data', (data: any) => {\r\n        if (!this.recvRequest) {\r\n          /* the transport was disposed before we connected */\r\n          return;\r\n        }\r\n        if (!preconnected) {\r\n          preconnected = true;\r\n          this.emit('preconnect');\r\n        }\r\n        this.onData(data);\r\n      });\r\n      connectRequest.on('complete', (err: ErrorInfo) => {\r\n        if (!this.recvRequest) {\r\n          /* the transport was disposed before we connected */\r\n          err = err || new ErrorInfo('Request cancelled', 80003, 400);\r\n        }\r\n        this.recvRequest = null;\r\n        /* Connect request may complete without a emitting 'data' event since that is not\r\n         * emitted for e.g. a non-streamed error response. Still implies preconnect. */\r\n        if (!preconnected && !err) {\r\n          preconnected = true;\r\n          this.emit('preconnect');\r\n        }\r\n        this.onActivity();\r\n        if (err) {\r\n          if (err.code) {\r\n            /* A protocol error received from realtime. TODO: once realtime\r\n             * consistendly sends errors wrapped in protocol messages, should be\r\n             * able to remove this */\r\n            this.onData(protocolMessageFromRawError(err));\r\n          } else {\r\n            /* A network/xhr error. Don't bother wrapping in a protocol message,\r\n             * just disconnect the transport */\r\n            this.disconnect(err);\r\n          }\r\n          return;\r\n        }\r\n        Platform.Config.nextTick(() => {\r\n          this.recv();\r\n        });\r\n      });\r\n      connectRequest.exec();\r\n    });\r\n  }\r\n\r\n  requestClose(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'CometTransport.requestClose()');\r\n    this._requestCloseOrDisconnect(true);\r\n  }\r\n\r\n  requestDisconnect(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'CometTransport.requestDisconnect()');\r\n    this._requestCloseOrDisconnect(false);\r\n  }\r\n\r\n  _requestCloseOrDisconnect(closing: boolean): void {\r\n    const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\r\n    if (closeOrDisconnectUri) {\r\n      const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates.REQ_SEND);\r\n\r\n      request.on('complete', (err: ErrorInfo) => {\r\n        if (err) {\r\n          Logger.logAction(\r\n            Logger.LOG_ERROR,\r\n            'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'),\r\n            'request returned err = ' + Utils.inspectError(err),\r\n          );\r\n          this.finish('disconnected', err);\r\n        }\r\n      });\r\n      request.exec();\r\n    }\r\n  }\r\n\r\n  dispose(): void {\r\n    Logger.logAction(Logger.LOG_MINOR, 'CometTransport.dispose()', '');\r\n    if (!this.isDisposed) {\r\n      this.isDisposed = true;\r\n      if (this.recvRequest) {\r\n        Logger.logAction(Logger.LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');\r\n        this.recvRequest.abort();\r\n        this.recvRequest = null;\r\n      }\r\n      /* In almost all cases the transport will be finished before it's\r\n       * disposed. Finish here just to make sure. */\r\n      this.finish('disconnected', ConnectionErrors.disconnected());\r\n      Platform.Config.nextTick(() => {\r\n        this.emit('disposed');\r\n      });\r\n    }\r\n  }\r\n\r\n  onConnect(message: ProtocolMessage): void {\r\n    /* if this transport has been disposed whilst awaiting connection, do nothing */\r\n    if (this.isDisposed) {\r\n      return;\r\n    }\r\n\r\n    /* the connectionKey in a comet connected response is really\r\n     * <instId>-<connectionKey> */\r\n    const connectionStr = message.connectionDetails?.connectionKey;\r\n    Transport.prototype.onConnect.call(this, message);\r\n\r\n    const baseConnectionUri = (this.baseUri as string) + connectionStr;\r\n    Logger.logAction(Logger.LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri);\r\n    this.sendUri = baseConnectionUri + '/send';\r\n    this.recvUri = baseConnectionUri + '/recv';\r\n    this.closeUri = baseConnectionUri + '/close';\r\n    this.disconnectUri = baseConnectionUri + '/disconnect';\r\n  }\r\n\r\n  send(message: ProtocolMessage): void {\r\n    if (this.sendRequest) {\r\n      /* there is a pending send, so queue this message */\r\n      this.pendingItems = this.pendingItems || [];\r\n      this.pendingItems.push(message);\r\n      return;\r\n    }\r\n    /* send this, plus any pending, now */\r\n    const pendingItems = this.pendingItems || [];\r\n    pendingItems.push(message);\r\n    this.pendingItems = null;\r\n\r\n    this.sendItems(pendingItems);\r\n  }\r\n\r\n  sendAnyPending(): void {\r\n    const pendingItems = this.pendingItems;\r\n\r\n    if (!pendingItems) {\r\n      return;\r\n    }\r\n\r\n    this.pendingItems = null;\r\n    this.sendItems(pendingItems);\r\n  }\r\n\r\n  sendItems(items: Array<ProtocolMessage>): void {\r\n    const sendRequest = (this.sendRequest = this.createRequest(\r\n      this.sendUri as string,\r\n      null,\r\n      this.authParams,\r\n      this.encodeRequest(items),\r\n      XHRStates.REQ_SEND,\r\n    ));\r\n\r\n    sendRequest.on('complete', (err: ErrorInfo, data: string) => {\r\n      if (err)\r\n        Logger.logAction(\r\n          Logger.LOG_ERROR,\r\n          'CometTransport.sendItems()',\r\n          'on complete: err = ' + Utils.inspectError(err),\r\n        );\r\n      this.sendRequest = null;\r\n\r\n      /* the result of the request, even if a nack, is usually a protocol response\r\n       * contained in the data. An err is anomolous, and indicates some issue with the\r\n       * network,transport, or connection */\r\n      if (err) {\r\n        if (err.code) {\r\n          /* A protocol error received from realtime. TODO: once realtime\r\n           * consistendly sends errors wrapped in protocol messages, should be\r\n           * able to remove this */\r\n          this.onData(protocolMessageFromRawError(err));\r\n        } else {\r\n          /* A network/xhr error. Don't bother wrapping in a protocol message,\r\n           * just disconnect the transport */\r\n          this.disconnect(err);\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (data) {\r\n        this.onData(data);\r\n      }\r\n\r\n      if (this.pendingItems) {\r\n        Platform.Config.nextTick(() => {\r\n          /* If there's a new send request by now, any pending items will have\r\n           * been picked up by that; any new ones added since then will be\r\n           * picked up after that one completes */\r\n          if (!this.sendRequest) {\r\n            this.sendAnyPending();\r\n          }\r\n        });\r\n      }\r\n    });\r\n    sendRequest.exec();\r\n  }\r\n\r\n  recv(): void {\r\n    /* do nothing if there is an active request, which might be streaming */\r\n    if (this.recvRequest) return;\r\n\r\n    /* If we're no longer connected, do nothing */\r\n    if (!this.isConnected) return;\r\n\r\n    const recvRequest = (this.recvRequest = this.createRequest(\r\n      this.recvUri as string,\r\n      null,\r\n      this.authParams,\r\n      null,\r\n      this.stream ? XHRStates.REQ_RECV_STREAM : XHRStates.REQ_RECV_POLL,\r\n    ));\r\n\r\n    recvRequest.on('data', (data: string) => {\r\n      this.onData(data);\r\n    });\r\n    recvRequest.on('complete', (err: ErrorInfo) => {\r\n      this.recvRequest = null;\r\n      /* A request completing must be considered activity, as realtime sends\r\n       * heartbeats every 15s since a request began, not every 15s absolutely */\r\n      this.onActivity();\r\n      if (err) {\r\n        if (err.code) {\r\n          /* A protocol error received from realtime. TODO: once realtime\r\n           * consistently sends errors wrapped in protocol messages, should be\r\n           * able to remove this */\r\n          this.onData(protocolMessageFromRawError(err));\r\n        } else {\r\n          /* A network/xhr error. Don't bother wrapping in a protocol message,\r\n           * just disconnect the transport */\r\n          this.disconnect(err);\r\n        }\r\n        return;\r\n      }\r\n      Platform.Config.nextTick(() => {\r\n        this.recv();\r\n      });\r\n    });\r\n    recvRequest.exec();\r\n  }\r\n\r\n  onData(responseData: string | Record<string, any>): void {\r\n    try {\r\n      const items = this.decodeResponse(responseData);\r\n      if (items && items.length)\r\n        for (let i = 0; i < items.length; i++)\r\n          this.onProtocolMessage(\r\n            protocolMessageFromDeserialized(items[i], this.connectionManager.realtime._RealtimePresence),\r\n          );\r\n    } catch (e) {\r\n      Logger.logAction(\r\n        Logger.LOG_ERROR,\r\n        'CometTransport.onData()',\r\n        'Unexpected exception handing channel event: ' + (e as Error).stack,\r\n      );\r\n    }\r\n  }\r\n\r\n  encodeRequest(requestItems: Array<ProtocolMessage>): string {\r\n    return JSON.stringify(requestItems);\r\n  }\r\n\r\n  decodeResponse(responseData: string | Record<string, any>): Record<string, any> {\r\n    if (typeof responseData == 'string') return JSON.parse(responseData);\r\n    return responseData;\r\n  }\r\n\r\n  /* Historical comment, back from when we supported JSONP:\r\n   *\r\n   * > For comet, we could do the auth update by aborting the current recv and\r\n   * > starting a new one with the new token, that'd be sufficient for realtime.\r\n   * > Problem is JSONP - you can't cancel truly abort a recv once started. So\r\n   * > we need to send an AUTH for jsonp. In which case it's simpler to keep all\r\n   * > comet transports the same and do it for all of them. So we send the AUTH\r\n   * > instead, and don't need to abort the recv\r\n   *\r\n   * Now that weâ€™ve dropped JSONP support, we may be able to revisit the above;\r\n   * see https://github.com/ably/ably-js/issues/1214.\r\n   */\r\n  onAuthUpdated = (tokenDetails: API.TokenDetails): void => {\r\n    this.authParams = { access_token: tokenDetails.token };\r\n  };\r\n}\r\n\r\nexport default CometTransport;\r\n","import * as Utils from 'common/lib/util/utils';\r\nimport EventEmitter from 'common/lib/util/eventemitter';\r\nimport ErrorInfo, { IPartialErrorInfo, PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport Logger from 'common/lib/util/logger';\r\nimport Defaults from 'common/lib/util/defaults';\r\nimport HttpMethods from 'common/constants/HttpMethods';\r\nimport IXHRRequest from 'common/types/IXHRRequest';\r\nimport { RequestBody, RequestParams } from 'common/types/http';\r\nimport XHRStates from 'common/constants/XHRStates';\r\nimport Platform from 'common/platform';\r\n\r\nfunction isAblyError(responseBody: unknown, headers: Record<string, string>): responseBody is { error?: ErrorInfo } {\r\n  return Utils.allToLowerCase(Utils.keysArray(headers)).includes('x-ably-errorcode');\r\n}\r\n\r\nfunction getAblyError(responseBody: unknown, headers: Record<string, string>) {\r\n  if (isAblyError(responseBody, headers)) {\r\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\r\n  }\r\n}\r\n\r\nconst noop = function () {};\r\nlet idCounter = 0;\r\nconst pendingRequests: Record<string, XHRRequest> = {};\r\n\r\nfunction getHeader(xhr: XMLHttpRequest, header: string) {\r\n  return xhr.getResponseHeader && xhr.getResponseHeader(header);\r\n}\r\n\r\n/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact\r\n * it is 'chunked'. So instead, decide that it is chunked when\r\n * transfer-encoding is present or content-length is absent.  ('or' because\r\n * when using http2 streaming, there's no transfer-encoding header, but can\r\n * still deduce streaming from lack of content-length) */\r\nfunction isEncodingChunked(xhr: XMLHttpRequest) {\r\n  return (\r\n    xhr.getResponseHeader && (xhr.getResponseHeader('transfer-encoding') || !xhr.getResponseHeader('content-length'))\r\n  );\r\n}\r\n\r\nfunction getHeadersAsObject(xhr: XMLHttpRequest) {\r\n  const headerPairs = xhr.getAllResponseHeaders().trim().split('\\r\\n');\r\n  const headers: Record<string, string> = {};\r\n  for (let i = 0; i < headerPairs.length; i++) {\r\n    const parts = headerPairs[i].split(':').map((x) => x.trim());\r\n    headers[parts[0].toLowerCase()] = parts[1];\r\n  }\r\n  return headers;\r\n}\r\n\r\nclass XHRRequest extends EventEmitter implements IXHRRequest {\r\n  uri: string;\r\n  headers: Record<string, string>;\r\n  body: RequestBody | null;\r\n  method: string;\r\n  requestMode: number;\r\n  timeouts: Record<string, number>;\r\n  timedOut: boolean;\r\n  requestComplete: boolean;\r\n  id: string;\r\n  streamComplete?: boolean;\r\n  xhr?: XMLHttpRequest | null;\r\n  timer?: NodeJS.Timeout | number | null;\r\n\r\n  constructor(\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params: Record<string, string>,\r\n    body: RequestBody | null,\r\n    requestMode: number,\r\n    timeouts: Record<string, number>,\r\n    method?: HttpMethods,\r\n  ) {\r\n    super();\r\n    params = params || {};\r\n    params.rnd = Utils.cheapRandStr();\r\n    this.uri = uri + Utils.toQueryString(params);\r\n    this.headers = headers || {};\r\n    this.body = body;\r\n    this.method = method ? method.toUpperCase() : Utils.isNil(body) ? 'GET' : 'POST';\r\n    this.requestMode = requestMode;\r\n    this.timeouts = timeouts;\r\n    this.timedOut = false;\r\n    this.requestComplete = false;\r\n    this.id = String(++idCounter);\r\n    pendingRequests[this.id] = this;\r\n  }\r\n\r\n  static createRequest(\r\n    uri: string,\r\n    headers: Record<string, string> | null,\r\n    params: RequestParams,\r\n    body: RequestBody | null,\r\n    requestMode: number,\r\n    timeouts: Record<string, number> | null,\r\n    method?: HttpMethods,\r\n  ): XHRRequest {\r\n    /* XHR requests are used either with the context being a realtime\r\n     * transport, or with timeouts passed in (for when used by a rest client),\r\n     * or completely standalone.  Use the appropriate timeouts in each case */\r\n    const _timeouts = timeouts || Defaults.TIMEOUTS;\r\n    return new XHRRequest(\r\n      uri,\r\n      headers,\r\n      Utils.copy(params) as Record<string, string>,\r\n      body,\r\n      requestMode,\r\n      _timeouts,\r\n      method,\r\n    );\r\n  }\r\n\r\n  complete(\r\n    err?: IPartialErrorInfo | null,\r\n    body?: unknown,\r\n    headers?: Record<string, string> | null,\r\n    unpacked?: boolean | null,\r\n    statusCode?: number,\r\n  ): void {\r\n    if (!this.requestComplete) {\r\n      this.requestComplete = true;\r\n      if (!err && body) {\r\n        this.emit('data', body);\r\n      }\r\n      this.emit('complete', err, body, headers, unpacked, statusCode);\r\n      this.dispose();\r\n    }\r\n  }\r\n\r\n  abort(): void {\r\n    this.dispose();\r\n  }\r\n\r\n  exec(): void {\r\n    let headers = this.headers;\r\n    const timeout =\r\n        this.requestMode == XHRStates.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout,\r\n      timer = (this.timer = setTimeout(() => {\r\n        this.timedOut = true;\r\n        xhr.abort();\r\n      }, timeout)),\r\n      method = this.method,\r\n      xhr = (this.xhr = new XMLHttpRequest()),\r\n      accept = headers['accept'];\r\n    let body = this.body;\r\n    let responseType: XMLHttpRequestResponseType = 'text';\r\n\r\n    if (!accept) {\r\n      // Default to JSON\r\n      headers['accept'] = 'application/json';\r\n    } else if (accept.indexOf('application/x-msgpack') === 0) {\r\n      // Msgpack responses will be typed as ArrayBuffer\r\n      responseType = 'arraybuffer';\r\n    }\r\n\r\n    if (body) {\r\n      const contentType = headers['content-type'] || (headers['content-type'] = 'application/json');\r\n      if (contentType.indexOf('application/json') > -1 && typeof body != 'string') body = JSON.stringify(body);\r\n    }\r\n\r\n    // Can probably remove this directive if https://github.com/nodesecurity/eslint-plugin-security/issues/26 is resolved\r\n    // eslint-disable-next-line security/detect-non-literal-fs-filename\r\n    xhr.open(method, this.uri, true);\r\n    xhr.responseType = responseType;\r\n\r\n    if ('authorization' in headers) {\r\n      xhr.withCredentials = true;\r\n    }\r\n\r\n    for (const h in headers) xhr.setRequestHeader(h, headers[h]);\r\n\r\n    const errorHandler = (\r\n      errorEvent: ProgressEvent<EventTarget>,\r\n      message: string,\r\n      code: number | null,\r\n      statusCode: number,\r\n    ) => {\r\n      let errorMessage = message + ' (event type: ' + errorEvent.type + ')';\r\n      if (this?.xhr?.statusText) errorMessage += ', current statusText is ' + this.xhr.statusText;\r\n      Logger.logAction(Logger.LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);\r\n      this.complete(new PartialErrorInfo(errorMessage, code, statusCode));\r\n    };\r\n    xhr.onerror = function (errorEvent) {\r\n      errorHandler(errorEvent, 'XHR error occurred', null, 400);\r\n    };\r\n    xhr.onabort = (errorEvent) => {\r\n      if (this.timedOut) {\r\n        errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);\r\n      } else {\r\n        errorHandler(errorEvent, 'Request cancelled', null, 400);\r\n      }\r\n    };\r\n    xhr.ontimeout = function (errorEvent) {\r\n      errorHandler(errorEvent, 'Request timed out', null, 408);\r\n    };\r\n\r\n    let streaming: boolean | string;\r\n    let statusCode: number;\r\n    let successResponse: boolean;\r\n    let streamPos = 0;\r\n    let unpacked = false;\r\n\r\n    const onResponse = () => {\r\n      clearTimeout(timer);\r\n      successResponse = statusCode < 400;\r\n      if (statusCode == 204) {\r\n        this.complete(null, null, null, null, statusCode);\r\n        return;\r\n      }\r\n      streaming = this.requestMode == XHRStates.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);\r\n    };\r\n\r\n    const onEnd = () => {\r\n      let parsedResponse: any;\r\n      try {\r\n        const contentType = getHeader(xhr, 'content-type');\r\n        /* Be liberal in what we accept; buggy auth servers may respond\r\n         * without the correct contenttype, but assume they're still\r\n         * responding with json */\r\n        const json = contentType ? contentType.indexOf('application/json') >= 0 : xhr.responseType == 'text';\r\n\r\n        if (json) {\r\n          /* If we requested msgpack but server responded with json, then since\r\n           * we set the responseType expecting msgpack, the response will be\r\n           * an ArrayBuffer containing json */\r\n          const jsonResponseBody =\r\n            xhr.responseType === 'arraybuffer'\r\n              ? Platform.BufferUtils.utf8Decode(xhr.response)\r\n              : String(xhr.responseText);\r\n          if (jsonResponseBody.length) {\r\n            parsedResponse = JSON.parse(jsonResponseBody);\r\n          } else {\r\n            parsedResponse = jsonResponseBody;\r\n          }\r\n          unpacked = true;\r\n        } else {\r\n          parsedResponse = xhr.response;\r\n        }\r\n\r\n        if (parsedResponse.response !== undefined) {\r\n          /* unwrap JSON envelope */\r\n          statusCode = parsedResponse.statusCode;\r\n          successResponse = statusCode < 400;\r\n          headers = parsedResponse.headers;\r\n          parsedResponse = parsedResponse.response;\r\n        } else {\r\n          headers = getHeadersAsObject(xhr);\r\n        }\r\n      } catch (e) {\r\n        this.complete(new PartialErrorInfo('Malformed response body from server: ' + (e as Error).message, null, 400));\r\n        return;\r\n      }\r\n\r\n      /* If response is an array, it's an array of protocol messages -- even if\r\n       * is contains an error action (hence the nonsuccess statuscode), we can\r\n       * consider the request to have succeeded, just pass it on to\r\n       * onProtocolMessage to decide what to do */\r\n      if (successResponse || Array.isArray(parsedResponse)) {\r\n        this.complete(null, parsedResponse, headers, unpacked, statusCode);\r\n        return;\r\n      }\r\n\r\n      let err: IPartialErrorInfo | undefined = getAblyError(parsedResponse, headers);\r\n      if (!err) {\r\n        err = new PartialErrorInfo(\r\n          'Error response received from server: ' +\r\n            statusCode +\r\n            ' body was: ' +\r\n            Platform.Config.inspect(parsedResponse),\r\n          null,\r\n          statusCode,\r\n        );\r\n      }\r\n      this.complete(err, parsedResponse, headers, unpacked, statusCode);\r\n    };\r\n\r\n    function onProgress() {\r\n      const responseText = xhr.responseText;\r\n      const bodyEnd = responseText.length - 1;\r\n      let idx, chunk;\r\n      while (streamPos < bodyEnd && (idx = responseText.indexOf('\\n', streamPos)) > -1) {\r\n        chunk = responseText.slice(streamPos, idx);\r\n        streamPos = idx + 1;\r\n        onChunk(chunk);\r\n      }\r\n    }\r\n\r\n    const onChunk = (chunk: string) => {\r\n      try {\r\n        chunk = JSON.parse(chunk);\r\n      } catch (e) {\r\n        this.complete(new PartialErrorInfo('Malformed response body from server: ' + (e as Error).message, null, 400));\r\n        return;\r\n      }\r\n      this.emit('data', chunk);\r\n    };\r\n\r\n    const onStreamEnd = () => {\r\n      onProgress();\r\n      this.streamComplete = true;\r\n      Platform.Config.nextTick(() => {\r\n        this.complete();\r\n      });\r\n    };\r\n\r\n    xhr.onreadystatechange = function () {\r\n      const readyState = xhr.readyState;\r\n      if (readyState < 3) return;\r\n      if (xhr.status !== 0) {\r\n        if (statusCode === undefined) {\r\n          statusCode = xhr.status;\r\n          onResponse();\r\n        }\r\n        if (readyState == 3 && streaming) {\r\n          onProgress();\r\n        } else if (readyState == 4) {\r\n          if (streaming) onStreamEnd();\r\n          else onEnd();\r\n        }\r\n      }\r\n    };\r\n    xhr.send(body as any);\r\n  }\r\n\r\n  dispose(): void {\r\n    const xhr = this.xhr;\r\n    if (xhr) {\r\n      xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;\r\n      this.xhr = null;\r\n      const timer = this.timer;\r\n      if (timer) {\r\n        clearTimeout(timer as NodeJS.Timeout);\r\n        this.timer = null;\r\n      }\r\n      if (!this.requestComplete) xhr.abort();\r\n    }\r\n    delete pendingRequests[this.id];\r\n  }\r\n}\r\n\r\nexport default XHRRequest;\r\n","import Platform from '../../../../common/platform';\r\nimport CometTransport from '../../../../common/lib/transport/comettransport';\r\nimport XHRRequest from '../http/request/xhrrequest';\r\nimport ConnectionManager, { TransportParams } from 'common/lib/transport/connectionmanager';\r\nimport Auth from 'common/lib/client/auth';\r\nimport { RequestBody, RequestParams } from 'common/types/http';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\n\r\nvar shortName = TransportNames.XhrPolling;\r\nclass XHRPollingTransport extends CometTransport {\r\n  shortName = shortName;\r\n  constructor(connectionManager: ConnectionManager, auth: Auth, params: TransportParams) {\r\n    super(connectionManager, auth, params);\r\n    params.stream = false;\r\n    this.shortName = shortName;\r\n  }\r\n\r\n  static isAvailable() {\r\n    return !!(Platform.Config.xhrSupported && Platform.Config.allowComet);\r\n  }\r\n\r\n  toString() {\r\n    return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;\r\n  }\r\n\r\n  createRequest(\r\n    uri: string,\r\n    headers: Record<string, string>,\r\n    params: RequestParams,\r\n    body: RequestBody | null,\r\n    requestMode: number,\r\n  ) {\r\n    return XHRRequest.createRequest(uri, headers, params, body, requestMode, this.timeouts);\r\n  }\r\n}\r\n\r\nexport default XHRPollingTransport;\r\n","import TransportName from 'common/constants/TransportName';\r\nimport Platform from 'common/platform';\r\nimport XhrPollingTransport from './xhrpollingtransport';\r\nimport WebSocketTransport from '../../../../common/lib/transport/websockettransport';\r\n\r\n// For reasons that I donâ€™t understand, if we use [TransportNames.XhrPolling] for the keys in defaultTransportsâ€™s, then defaultTransports does not get tree-shaken. Hence using literals instead. Theyâ€™re still correctly type-checked.\r\n\r\nconst order: TransportName[] = ['xhr_polling'];\r\n\r\nconst defaultTransports: (typeof Platform)['Transports'] = {\r\n  order,\r\n  bundledImplementations: {\r\n    web_socket: WebSocketTransport,\r\n    xhr_polling: XhrPollingTransport,\r\n  },\r\n};\r\n\r\nexport default defaultTransports;\r\n\r\nexport const ModularTransports: (typeof Platform)['Transports'] = {\r\n  order,\r\n  bundledImplementations: {},\r\n};\r\n","import IWebStorage from 'common/types/IWebStorage';\r\n\r\nconst test = 'ablyjs-storage-test';\r\n\r\nlet globalObject = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : self;\r\n\r\nclass Webstorage implements IWebStorage {\r\n  sessionSupported: boolean;\r\n  localSupported: boolean;\r\n\r\n  constructor() {\r\n    /* Even just accessing the session/localStorage object can throw a\r\n     * security exception in some circumstances with some browsers. In\r\n     * others, calling setItem will throw. So have to check in this\r\n     * somewhat roundabout way. (If unsupported or no global object,\r\n     * will throw on accessing a property of undefined) */\r\n    try {\r\n      globalObject.sessionStorage.setItem(test, test);\r\n      globalObject.sessionStorage.removeItem(test);\r\n      this.sessionSupported = true;\r\n    } catch (e) {\r\n      this.sessionSupported = false;\r\n    }\r\n\r\n    try {\r\n      globalObject.localStorage.setItem(test, test);\r\n      globalObject.localStorage.removeItem(test);\r\n      this.localSupported = true;\r\n    } catch (e) {\r\n      this.localSupported = false;\r\n    }\r\n  }\r\n\r\n  get(name: string): any {\r\n    return this._get(name, false);\r\n  }\r\n\r\n  getSession(name: string): any {\r\n    return this._get(name, true);\r\n  }\r\n\r\n  remove(name: string): void {\r\n    return this._remove(name, false);\r\n  }\r\n\r\n  removeSession(name: string): void {\r\n    return this._remove(name, true);\r\n  }\r\n\r\n  set(name: string, value: string, ttl?: number): void {\r\n    return this._set(name, value, ttl, false);\r\n  }\r\n\r\n  setSession(name: string, value: string, ttl?: number): void {\r\n    return this._set(name, value, ttl, true);\r\n  }\r\n\r\n  private _set(name: string, value: string, ttl: number | undefined, session: any) {\r\n    const wrappedValue: Record<string, any> = { value: value };\r\n    if (ttl) {\r\n      wrappedValue.expires = Date.now() + ttl;\r\n    }\r\n    return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));\r\n  }\r\n\r\n  private _get(name: string, session?: boolean) {\r\n    if (session && !this.sessionSupported) throw new Error('Session Storage not supported');\r\n    if (!session && !this.localSupported) throw new Error('Local Storage not supported');\r\n    const rawItem = this.storageInterface(session).getItem(name);\r\n    if (!rawItem) return null;\r\n    const wrappedValue = JSON.parse(rawItem);\r\n    if (wrappedValue.expires && wrappedValue.expires < Date.now()) {\r\n      this.storageInterface(session).removeItem(name);\r\n      return null;\r\n    }\r\n    return wrappedValue.value;\r\n  }\r\n\r\n  private _remove(name: string, session?: boolean) {\r\n    return this.storageInterface(session).removeItem(name);\r\n  }\r\n\r\n  private storageInterface(session?: boolean) {\r\n    return session ? globalObject.sessionStorage : globalObject.localStorage;\r\n  }\r\n}\r\n\r\nexport default new Webstorage();\r\n","import IDefaults from 'common/types/IDefaults';\r\nimport { TransportNames } from 'common/constants/TransportName';\r\n\r\nconst Defaults: IDefaults = {\r\n  connectivityCheckUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',\r\n  wsConnectivityUrl: 'wss://ws-up.ably-realtime.com',\r\n  /* Order matters here: the base transport is the leftmost one in the\r\n   * intersection of baseTransportOrder and the transports clientOption that's\r\n   * supported. */\r\n  defaultTransports: [TransportNames.XhrPolling, TransportNames.WebSocket],\r\n};\r\n\r\nexport default Defaults;\r\n","function inspect(buffer: undefined | ArrayBuffer | DataView) {\r\n  if (buffer === undefined) return 'undefined';\r\n  let view;\r\n  let type;\r\n  if (buffer instanceof ArrayBuffer) {\r\n    type = 'ArrayBuffer';\r\n    view = new DataView(buffer);\r\n  } else if (buffer instanceof DataView) {\r\n    type = 'DataView';\r\n    view = buffer;\r\n  }\r\n  if (!view) return JSON.stringify(buffer);\r\n  const bytes = [];\r\n  for (let i = 0; i < buffer.byteLength; i++) {\r\n    if (i > 20) {\r\n      bytes.push('...');\r\n      break;\r\n    }\r\n    let byte_ = view.getUint8(i).toString(16);\r\n    if (byte_.length === 1) byte_ = '0' + byte_;\r\n    bytes.push(byte_);\r\n  }\r\n  return '<' + type + ' ' + bytes.join(' ') + '>';\r\n}\r\n\r\n// Encode string as utf8 into dataview at offset\r\nfunction utf8Write(view: DataView, offset: number, string: string) {\r\n  for (let i = 0, l = string.length; i < l; i++) {\r\n    const codePoint = string.charCodeAt(i);\r\n\r\n    // One byte of UTF-8\r\n    if (codePoint < 0x80) {\r\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x7f) | 0x00);\r\n      continue;\r\n    }\r\n\r\n    // Two bytes of UTF-8\r\n    if (codePoint < 0x800) {\r\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x1f) | 0xc0);\r\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\r\n      continue;\r\n    }\r\n\r\n    // Three bytes of UTF-8.\r\n    if (codePoint < 0x10000) {\r\n      view.setUint8(offset++, ((codePoint >>> 12) & 0x0f) | 0xe0);\r\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);\r\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\r\n      continue;\r\n    }\r\n\r\n    // Four bytes of UTF-8\r\n    if (codePoint < 0x110000) {\r\n      view.setUint8(offset++, ((codePoint >>> 18) & 0x07) | 0xf0);\r\n      view.setUint8(offset++, ((codePoint >>> 12) & 0x3f) | 0x80);\r\n      view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);\r\n      view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\r\n      continue;\r\n    }\r\n    throw new Error('bad codepoint ' + codePoint);\r\n  }\r\n}\r\n\r\nfunction utf8Read(view: DataView, offset: number, length: number) {\r\n  let string = '';\r\n  for (let i = offset, end = offset + length; i < end; i++) {\r\n    const byte_ = view.getUint8(i);\r\n    // One byte character\r\n    if ((byte_ & 0x80) === 0x00) {\r\n      string += String.fromCharCode(byte_);\r\n      continue;\r\n    }\r\n    // Two byte character\r\n    if ((byte_ & 0xe0) === 0xc0) {\r\n      string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));\r\n      continue;\r\n    }\r\n    // Three byte character\r\n    if ((byte_ & 0xf0) === 0xe0) {\r\n      string += String.fromCharCode(\r\n        ((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0),\r\n      );\r\n      continue;\r\n    }\r\n    // Four byte character\r\n    if ((byte_ & 0xf8) === 0xf0) {\r\n      string += String.fromCharCode(\r\n        ((byte_ & 0x07) << 18) |\r\n          ((view.getUint8(++i) & 0x3f) << 12) |\r\n          ((view.getUint8(++i) & 0x3f) << 6) |\r\n          ((view.getUint8(++i) & 0x3f) << 0),\r\n      );\r\n      continue;\r\n    }\r\n    throw new Error('Invalid byte ' + byte_.toString(16));\r\n  }\r\n  return string;\r\n}\r\n\r\nfunction utf8ByteCount(string: string) {\r\n  let count = 0;\r\n  for (let i = 0, l = string.length; i < l; i++) {\r\n    const codePoint = string.charCodeAt(i);\r\n    if (codePoint < 0x80) {\r\n      count += 1;\r\n      continue;\r\n    }\r\n    if (codePoint < 0x800) {\r\n      count += 2;\r\n      continue;\r\n    }\r\n    if (codePoint < 0x10000) {\r\n      count += 3;\r\n      continue;\r\n    }\r\n    if (codePoint < 0x110000) {\r\n      count += 4;\r\n      continue;\r\n    }\r\n    throw new Error('bad codepoint ' + codePoint);\r\n  }\r\n  return count;\r\n}\r\n\r\nfunction encode(value: unknown, sparse?: boolean) {\r\n  const size = sizeof(value, sparse);\r\n  if (size === 0) return undefined;\r\n  const buffer = new ArrayBuffer(size);\r\n  const view = new DataView(buffer);\r\n  _encode(value, view, 0, sparse);\r\n  return buffer;\r\n}\r\n\r\nconst SH_L_32 = (1 << 16) * (1 << 16),\r\n  SH_R_32 = 1 / SH_L_32;\r\nfunction getInt64(view: DataView, offset: number) {\r\n  offset = offset || 0;\r\n  return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);\r\n}\r\n\r\nfunction getUint64(view: DataView, offset: number) {\r\n  offset = offset || 0;\r\n  return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);\r\n}\r\n\r\nfunction setInt64(view: DataView, offset: number, val: number) {\r\n  if (val < 0x8000000000000000) {\r\n    view.setInt32(offset, Math.floor(val * SH_R_32));\r\n    view.setInt32(offset + 4, val & -1);\r\n  } else {\r\n    view.setUint32(offset, 0x7fffffff);\r\n    view.setUint32(offset + 4, 0x7fffffff);\r\n  }\r\n}\r\n\r\nfunction setUint64(view: DataView, offset: number, val: number) {\r\n  if (val < 0x10000000000000000) {\r\n    view.setUint32(offset, Math.floor(val * SH_R_32));\r\n    view.setInt32(offset + 4, val & -1);\r\n  } else {\r\n    view.setUint32(offset, 0xffffffff);\r\n    view.setUint32(offset + 4, 0xffffffff);\r\n  }\r\n}\r\n\r\n// https://gist.github.com/frsyuki/5432559 - v5 spec\r\n//\r\n// I've used one extension point from `fixext 1` to store `undefined`. On the wire this\r\n// should translate to exactly 0xd40000\r\n//\r\n// +--------+--------+--------+\r\n// |  0xd4  |  0x00  |  0x00  |\r\n// +--------+--------+--------+\r\n//    ^ fixext |        ^ value part unused (fixed to be 0)\r\n//             ^ indicates undefined value\r\n//\r\n\r\nclass Decoder {\r\n  offset: number;\r\n  view: DataView;\r\n\r\n  constructor(view: DataView, offset?: number) {\r\n    this.offset = offset || 0;\r\n    this.view = view;\r\n  }\r\n\r\n  map = (length: number) => {\r\n    const value: { [key: string]: ArrayBuffer } = {};\r\n    for (let i = 0; i < length; i++) {\r\n      const key = this.parse();\r\n      value[key as string] = this.parse() as ArrayBuffer;\r\n    }\r\n    return value;\r\n  };\r\n\r\n  bin = (length: number) => {\r\n    const value = new ArrayBuffer(length);\r\n    new Uint8Array(value).set(new Uint8Array(this.view.buffer, this.offset, length), 0);\r\n    this.offset += length;\r\n    return value;\r\n  };\r\n\r\n  buf = this.bin;\r\n\r\n  str = (length: number) => {\r\n    const value = utf8Read(this.view, this.offset, length);\r\n    this.offset += length;\r\n    return value;\r\n  };\r\n\r\n  array = (length: number) => {\r\n    const value = new Array(length);\r\n    for (let i = 0; i < length; i++) {\r\n      value[i] = this.parse();\r\n    }\r\n    return value;\r\n  };\r\n\r\n  ext = (length: number) => {\r\n    this.offset += length;\r\n    return {\r\n      type: this.view.getInt8(this.offset),\r\n      data: this.buf(length),\r\n    };\r\n  };\r\n\r\n  parse = (): unknown => {\r\n    const type = this.view.getUint8(this.offset);\r\n    let value, length;\r\n\r\n    // Positive FixInt - 0xxxxxxx\r\n    if ((type & 0x80) === 0x00) {\r\n      this.offset++;\r\n      return type;\r\n    }\r\n\r\n    // FixMap - 1000xxxx\r\n    if ((type & 0xf0) === 0x80) {\r\n      length = type & 0x0f;\r\n      this.offset++;\r\n      return this.map(length);\r\n    }\r\n\r\n    // FixArray - 1001xxxx\r\n    if ((type & 0xf0) === 0x90) {\r\n      length = type & 0x0f;\r\n      this.offset++;\r\n      return this.array(length);\r\n    }\r\n\r\n    // FixStr - 101xxxxx\r\n    if ((type & 0xe0) === 0xa0) {\r\n      length = type & 0x1f;\r\n      this.offset++;\r\n      return this.str(length);\r\n    }\r\n\r\n    // Negative FixInt - 111xxxxx\r\n    if ((type & 0xe0) === 0xe0) {\r\n      value = this.view.getInt8(this.offset);\r\n      this.offset++;\r\n      return value;\r\n    }\r\n\r\n    switch (type) {\r\n      // nil\r\n      case 0xc0:\r\n        this.offset++;\r\n        return null;\r\n\r\n      // 0xc1 never used - use for undefined (NON-STANDARD)\r\n      case 0xc1:\r\n        this.offset++;\r\n        return undefined;\r\n\r\n      // false\r\n      case 0xc2:\r\n        this.offset++;\r\n        return false;\r\n\r\n      // true\r\n      case 0xc3:\r\n        this.offset++;\r\n        return true;\r\n\r\n      // bin 8\r\n      case 0xc4:\r\n        length = this.view.getUint8(this.offset + 1);\r\n        this.offset += 2;\r\n        return this.bin(length);\r\n\r\n      // bin 16\r\n      case 0xc5:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.bin(length);\r\n\r\n      // bin 32\r\n      case 0xc6:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.bin(length);\r\n\r\n      // ext 8\r\n      case 0xc7:\r\n        length = this.view.getUint8(this.offset + 1);\r\n        this.offset += 2;\r\n        return this.ext(length);\r\n\r\n      // ext 16\r\n      case 0xc8:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.ext(length);\r\n\r\n      // ext 32\r\n      case 0xc9:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.ext(length);\r\n\r\n      // float 32\r\n      case 0xca:\r\n        value = this.view.getFloat32(this.offset + 1);\r\n        this.offset += 5;\r\n        return value;\r\n\r\n      // float 64\r\n      case 0xcb:\r\n        value = this.view.getFloat64(this.offset + 1);\r\n        this.offset += 9;\r\n        return value;\r\n\r\n      // uint8\r\n      case 0xcc:\r\n        value = this.view.getUint8(this.offset + 1);\r\n        this.offset += 2;\r\n        return value;\r\n\r\n      // uint 16\r\n      case 0xcd:\r\n        value = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return value;\r\n\r\n      // uint 32\r\n      case 0xce:\r\n        value = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return value;\r\n\r\n      // uint 64\r\n      case 0xcf:\r\n        value = getUint64(this.view, this.offset + 1);\r\n        this.offset += 9;\r\n        return value;\r\n\r\n      // int 8\r\n      case 0xd0:\r\n        value = this.view.getInt8(this.offset + 1);\r\n        this.offset += 2;\r\n        return value;\r\n\r\n      // int 16\r\n      case 0xd1:\r\n        value = this.view.getInt16(this.offset + 1);\r\n        this.offset += 3;\r\n        return value;\r\n\r\n      // int 32\r\n      case 0xd2:\r\n        value = this.view.getInt32(this.offset + 1);\r\n        this.offset += 5;\r\n        return value;\r\n\r\n      // int 64\r\n      case 0xd3:\r\n        value = getInt64(this.view, this.offset + 1);\r\n        this.offset += 9;\r\n        return value;\r\n\r\n      // fixext 1\r\n      case 0xd4:\r\n        length = 1;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // fixext 2\r\n      case 0xd5:\r\n        length = 2;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // fixext 4\r\n      case 0xd6:\r\n        length = 4;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // fixext 8\r\n      case 0xd7:\r\n        length = 8;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // fixext 16\r\n      case 0xd8:\r\n        length = 16;\r\n        this.offset++;\r\n        return this.ext(length);\r\n\r\n      // str8\r\n      case 0xd9:\r\n        length = this.view.getUint8(this.offset + 1);\r\n        this.offset += 2;\r\n        return this.str(length);\r\n\r\n      // str 16\r\n      case 0xda:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.str(length);\r\n\r\n      // str 32\r\n      case 0xdb:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.str(length);\r\n\r\n      // array 16\r\n      case 0xdc:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.array(length);\r\n\r\n      // array 32\r\n      case 0xdd:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.array(length);\r\n\r\n      // map 16\r\n      case 0xde:\r\n        length = this.view.getUint16(this.offset + 1);\r\n        this.offset += 3;\r\n        return this.map(length);\r\n\r\n      // map 32\r\n      case 0xdf:\r\n        length = this.view.getUint32(this.offset + 1);\r\n        this.offset += 5;\r\n        return this.map(length);\r\n    }\r\n    throw new Error('Unknown type 0x' + type.toString(16));\r\n  };\r\n}\r\n\r\nfunction decode(buffer: ArrayBuffer) {\r\n  const view = new DataView(buffer);\r\n  const decoder = new Decoder(view);\r\n  const value = decoder.parse();\r\n  if (decoder.offset !== buffer.byteLength) throw new Error(buffer.byteLength - decoder.offset + ' trailing bytes');\r\n  return value;\r\n}\r\n\r\nfunction encodeableKeys(value: { [key: string]: unknown }, sparse?: boolean) {\r\n  return Object.keys(value).filter(function (e) {\r\n    const val = value[e],\r\n      type = typeof val;\r\n    return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!(val as Date).toJSON);\r\n  });\r\n}\r\n\r\nfunction _encode(value: unknown, view: DataView, offset: number, sparse?: boolean): number {\r\n  const type = typeof value;\r\n\r\n  // Strings Bytes\r\n  // There are four string types: fixstr/str8/str16/str32\r\n  if (typeof value === 'string') {\r\n    const length = utf8ByteCount(value);\r\n\r\n    // fixstr\r\n    if (length < 0x20) {\r\n      view.setUint8(offset, length | 0xa0);\r\n      utf8Write(view, offset + 1, value);\r\n      return 1 + length;\r\n    }\r\n\r\n    // str8\r\n    if (length < 0x100) {\r\n      view.setUint8(offset, 0xd9);\r\n      view.setUint8(offset + 1, length);\r\n      utf8Write(view, offset + 2, value);\r\n      return 2 + length;\r\n    }\r\n\r\n    // str16\r\n    if (length < 0x10000) {\r\n      view.setUint8(offset, 0xda);\r\n      view.setUint16(offset + 1, length);\r\n      utf8Write(view, offset + 3, value);\r\n      return 3 + length;\r\n    }\r\n    // str32\r\n    if (length < 0x100000000) {\r\n      view.setUint8(offset, 0xdb);\r\n      view.setUint32(offset + 1, length);\r\n      utf8Write(view, offset + 5, value);\r\n      return 5 + length;\r\n    }\r\n  }\r\n\r\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\r\n    // extract the arraybuffer and fallthrough\r\n    value = value.buffer;\r\n  }\r\n\r\n  // There are three bin types: bin8/bin16/bin32\r\n  if (value instanceof ArrayBuffer) {\r\n    const length = value.byteLength;\r\n\r\n    // bin8\r\n    if (length < 0x100) {\r\n      view.setUint8(offset, 0xc4);\r\n      view.setUint8(offset + 1, length);\r\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);\r\n      return 2 + length;\r\n    }\r\n\r\n    // bin16\r\n    if (length < 0x10000) {\r\n      view.setUint8(offset, 0xc5);\r\n      view.setUint16(offset + 1, length);\r\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);\r\n      return 3 + length;\r\n    }\r\n\r\n    // bin 32\r\n    if (length < 0x100000000) {\r\n      view.setUint8(offset, 0xc6);\r\n      view.setUint32(offset + 1, length);\r\n      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);\r\n      return 5 + length;\r\n    }\r\n  }\r\n\r\n  if (typeof value === 'number') {\r\n    // Floating Point\r\n    // NOTE: We're always using float64\r\n    if (Math.floor(value) !== value) {\r\n      view.setUint8(offset, 0xcb);\r\n      view.setFloat64(offset + 1, value);\r\n      return 9;\r\n    }\r\n\r\n    // Integers\r\n    if (value >= 0) {\r\n      // positive fixnum\r\n      if (value < 0x80) {\r\n        view.setUint8(offset, value);\r\n        return 1;\r\n      }\r\n      // uint 8\r\n      if (value < 0x100) {\r\n        view.setUint8(offset, 0xcc);\r\n        view.setUint8(offset + 1, value);\r\n        return 2;\r\n      }\r\n      // uint 16\r\n      if (value < 0x10000) {\r\n        view.setUint8(offset, 0xcd);\r\n        view.setUint16(offset + 1, value);\r\n        return 3;\r\n      }\r\n      // uint 32\r\n      if (value < 0x100000000) {\r\n        view.setUint8(offset, 0xce);\r\n        view.setUint32(offset + 1, value);\r\n        return 5;\r\n      }\r\n      // uint 64\r\n      if (value < 0x10000000000000000) {\r\n        view.setUint8(offset, 0xcf);\r\n        setUint64(view, offset + 1, value);\r\n        return 9;\r\n      }\r\n      throw new Error('Number too big 0x' + value.toString(16));\r\n    }\r\n\r\n    // negative fixnum\r\n    if (value >= -0x20) {\r\n      view.setInt8(offset, value);\r\n      return 1;\r\n    }\r\n    // int 8\r\n    if (value >= -0x80) {\r\n      view.setUint8(offset, 0xd0);\r\n      view.setInt8(offset + 1, value);\r\n      return 2;\r\n    }\r\n    // int 16\r\n    if (value >= -0x8000) {\r\n      view.setUint8(offset, 0xd1);\r\n      view.setInt16(offset + 1, value);\r\n      return 3;\r\n    }\r\n    // int 32\r\n    if (value >= -0x80000000) {\r\n      view.setUint8(offset, 0xd2);\r\n      view.setInt32(offset + 1, value);\r\n      return 5;\r\n    }\r\n    // int 64\r\n    if (value >= -0x8000000000000000) {\r\n      view.setUint8(offset, 0xd3);\r\n      setInt64(view, offset + 1, value);\r\n      return 9;\r\n    }\r\n    throw new Error('Number too small -0x' + (-value).toString(16).substr(1));\r\n  }\r\n\r\n  // undefined - use d4 (NON-STANDARD)\r\n  if (type === 'undefined') {\r\n    if (sparse) return 0;\r\n    view.setUint8(offset, 0xd4);\r\n    view.setUint8(offset + 1, 0x00);\r\n    view.setUint8(offset + 2, 0x00);\r\n    return 3;\r\n  }\r\n\r\n  // null\r\n  if (value === null) {\r\n    if (sparse) return 0;\r\n    view.setUint8(offset, 0xc0);\r\n    return 1;\r\n  }\r\n\r\n  // Boolean\r\n  if (type === 'boolean') {\r\n    view.setUint8(offset, value ? 0xc3 : 0xc2);\r\n    return 1;\r\n  }\r\n\r\n  if ('function' === typeof (value as Date).toJSON) return _encode((value as Date).toJSON(), view, offset, sparse);\r\n\r\n  // Container Types\r\n  if (type === 'object') {\r\n    let length: number,\r\n      size = 0;\r\n    let keys: string[] | undefined;\r\n    const isArray = Array.isArray(value);\r\n\r\n    if (isArray) {\r\n      length = (value as unknown[]).length;\r\n    } else {\r\n      keys = encodeableKeys(value as { [key: string]: unknown }, sparse);\r\n      length = keys.length;\r\n    }\r\n\r\n    if (length < 0x10) {\r\n      view.setUint8(offset, length | (isArray ? 0x90 : 0x80));\r\n      size = 1;\r\n    } else if (length < 0x10000) {\r\n      view.setUint8(offset, isArray ? 0xdc : 0xde);\r\n      view.setUint16(offset + 1, length);\r\n      size = 3;\r\n    } else if (length < 0x100000000) {\r\n      view.setUint8(offset, isArray ? 0xdd : 0xdf);\r\n      view.setUint32(offset + 1, length);\r\n      size = 5;\r\n    }\r\n\r\n    if (isArray) {\r\n      for (let i = 0; i < length; i++) {\r\n        size += _encode((value as unknown[])[i], view, offset + size, sparse);\r\n      }\r\n    } else if (keys) {\r\n      for (let i = 0; i < length; i++) {\r\n        const key = keys[i];\r\n        size += _encode(key, view, offset + size);\r\n        size += _encode((value as { [key: string]: unknown })[key], view, offset + size, sparse);\r\n      }\r\n    }\r\n\r\n    return size;\r\n  }\r\n  if (type === 'function') return 0;\r\n\r\n  throw new Error('Unknown type ' + type);\r\n}\r\n\r\nfunction sizeof(value: unknown, sparse?: boolean): number {\r\n  const type = typeof value;\r\n\r\n  // fixstr or str8 or str16 or str32\r\n  if (type === 'string') {\r\n    const length = utf8ByteCount(value as string);\r\n    if (length < 0x20) {\r\n      return 1 + length;\r\n    }\r\n    if (length < 0x100) {\r\n      return 2 + length;\r\n    }\r\n    if (length < 0x10000) {\r\n      return 3 + length;\r\n    }\r\n    if (length < 0x100000000) {\r\n      return 5 + length;\r\n    }\r\n  }\r\n\r\n  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\r\n    // extract the arraybuffer and fallthrough\r\n    value = value.buffer;\r\n  }\r\n\r\n  // bin8 or bin16 or bin32\r\n  if (value instanceof ArrayBuffer) {\r\n    const length = value.byteLength;\r\n    if (length < 0x100) {\r\n      return 2 + length;\r\n    }\r\n    if (length < 0x10000) {\r\n      return 3 + length;\r\n    }\r\n    if (length < 0x100000000) {\r\n      return 5 + length;\r\n    }\r\n  }\r\n\r\n  if (typeof value === 'number') {\r\n    // Floating Point (32 bits)\r\n    // double\r\n    if (Math.floor(value) !== value) return 9;\r\n\r\n    // Integers\r\n    if (value >= 0) {\r\n      // positive fixint\r\n      if (value < 0x80) return 1;\r\n      // uint 8\r\n      if (value < 0x100) return 2;\r\n      // uint 16\r\n      if (value < 0x10000) return 3;\r\n      // uint 32\r\n      if (value < 0x100000000) return 5;\r\n      // uint 64\r\n      if (value < 0x10000000000000000) return 9;\r\n      // Too big\r\n      throw new Error('Number too big 0x' + value.toString(16));\r\n    }\r\n    // negative fixint\r\n    if (value >= -0x20) return 1;\r\n    // int 8\r\n    if (value >= -0x80) return 2;\r\n    // int 16\r\n    if (value >= -0x8000) return 3;\r\n    // int 32\r\n    if (value >= -0x80000000) return 5;\r\n    // int 64\r\n    if (value >= -0x8000000000000000) return 9;\r\n    // Too small\r\n    throw new Error('Number too small -0x' + value.toString(16).substr(1));\r\n  }\r\n\r\n  // Boolean\r\n  if (type === 'boolean') return 1;\r\n\r\n  // undefined, null\r\n  if (value === null) return sparse ? 0 : 1;\r\n  if (value === undefined) return sparse ? 0 : 3;\r\n\r\n  if ('function' === typeof (value as Date).toJSON) return sizeof((value as Date).toJSON(), sparse);\r\n\r\n  // Container Types\r\n  if (type === 'object') {\r\n    let length: number,\r\n      size = 0;\r\n    if (Array.isArray(value)) {\r\n      length = value.length;\r\n      for (let i = 0; i < length; i++) {\r\n        size += sizeof(value[i], sparse);\r\n      }\r\n    } else {\r\n      const keys = encodeableKeys(value as { [key: string]: unknown }, sparse);\r\n      length = keys.length;\r\n      for (let i = 0; i < length; i++) {\r\n        const key = keys[i];\r\n        size += sizeof(key) + sizeof((value as { [key: string]: unknown })[key], sparse);\r\n      }\r\n    }\r\n    if (length < 0x10) {\r\n      return 1 + size;\r\n    }\r\n    if (length < 0x10000) {\r\n      return 3 + size;\r\n    }\r\n    if (length < 0x100000000) {\r\n      return 5 + size;\r\n    }\r\n    throw new Error('Array or object too long 0x' + length.toString(16));\r\n  }\r\n  if (type === 'function') return 0;\r\n\r\n  throw new Error('Unknown type ' + type);\r\n}\r\n\r\nexport default {\r\n  encode,\r\n  decode,\r\n  inspect,\r\n  utf8Write,\r\n  utf8Read,\r\n  utf8ByteCount,\r\n};\r\n","import HttpMethods from 'common/constants/HttpMethods';\r\nimport BaseClient from 'common/lib/client/baseclient';\r\nimport ErrorInfo, { PartialErrorInfo } from 'common/lib/types/errorinfo';\r\nimport { RequestBody, RequestResultError, ResponseHeaders, RequestParams, RequestResult } from 'common/types/http';\r\nimport Platform from 'common/platform';\r\nimport Defaults from 'common/lib/util/defaults';\r\nimport * as Utils from 'common/lib/util/utils';\r\n\r\nfunction isAblyError(responseBody: unknown, headers: Headers): responseBody is { error?: ErrorInfo } {\r\n  return !!headers.get('x-ably-errorcode');\r\n}\r\n\r\nfunction getAblyError(responseBody: unknown, headers: Headers) {\r\n  if (isAblyError(responseBody, headers)) {\r\n    return responseBody.error && ErrorInfo.fromValues(responseBody.error);\r\n  }\r\n}\r\n\r\nfunction convertHeaders(headers: Headers) {\r\n  const result: ResponseHeaders = {};\r\n\r\n  headers.forEach((value, key) => {\r\n    result[key] = value;\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nexport default async function fetchRequest(\r\n  method: HttpMethods,\r\n  client: BaseClient | null,\r\n  uri: string,\r\n  headers: Record<string, string> | null,\r\n  params: RequestParams,\r\n  body: RequestBody | null,\r\n): Promise<RequestResult> {\r\n  const fetchHeaders = new Headers(headers || {});\r\n  const _method = method ? method.toUpperCase() : Utils.isNil(body) ? 'GET' : 'POST';\r\n\r\n  const controller = new AbortController();\r\n\r\n  let timeout: ReturnType<typeof setTimeout>; // This way we donâ€™t have to worry about the fact that the TypeScript compiler is â€” for reasons I havenâ€™t looked into â€” picking up the signature of the Node version of setTimeout, which has a different return type to the web one\r\n  const timeoutPromise: Promise<RequestResult> = new Promise((resolve) => {\r\n    timeout = setTimeout(\r\n      () => {\r\n        controller.abort();\r\n        resolve({ error: new PartialErrorInfo('Request timed out', null, 408) });\r\n      },\r\n      client ? client.options.timeouts.httpRequestTimeout : Defaults.TIMEOUTS.httpRequestTimeout,\r\n    );\r\n  });\r\n\r\n  const requestInit: RequestInit = {\r\n    method: _method,\r\n    headers: fetchHeaders,\r\n    body: body as any,\r\n  };\r\n\r\n  if (!Platform.Config.isWebworker) {\r\n    requestInit.credentials = fetchHeaders.has('authorization') ? 'include' : 'same-origin';\r\n  }\r\n\r\n  const resultPromise = (async (): Promise<RequestResult> => {\r\n    try {\r\n      const res = await Utils.getGlobalObject().fetch(uri + '?' + new URLSearchParams(params || {}), requestInit);\r\n\r\n      clearTimeout(timeout!);\r\n\r\n      const contentType = res.headers.get('Content-Type');\r\n      let body;\r\n      if (contentType && contentType.indexOf('application/x-msgpack') > -1) {\r\n        body = await res.arrayBuffer();\r\n      } else if (contentType && contentType.indexOf('application/json') > -1) {\r\n        body = await res.json();\r\n      } else {\r\n        body = await res.text();\r\n      }\r\n\r\n      const unpacked = !!contentType && contentType.indexOf('application/x-msgpack') === -1;\r\n      const headers = convertHeaders(res.headers);\r\n\r\n      if (!res.ok) {\r\n        const error =\r\n          getAblyError(body, res.headers) ||\r\n          new PartialErrorInfo(\r\n            'Error response received from server: ' + res.status + ' body was: ' + Platform.Config.inspect(body),\r\n            null,\r\n            res.status,\r\n          );\r\n\r\n        return { error, body, headers, unpacked, statusCode: res.status };\r\n      } else {\r\n        return { error: null, body, headers, unpacked, statusCode: res.status };\r\n      }\r\n    } catch (error) {\r\n      clearTimeout(timeout!);\r\n      return { error: error as RequestResultError };\r\n    }\r\n  })();\r\n\r\n  return Promise.race([timeoutPromise, resultPromise]);\r\n}\r\n","import { HTTPRequestImplementations } from '../http';\r\nimport XHRRequest from './xhrrequest';\r\nimport fetchRequest from './fetchrequest';\r\n\r\nexport const defaultBundledRequestImplementations: HTTPRequestImplementations = {\r\n  XHRRequest: XHRRequest,\r\n  FetchRequest: fetchRequest,\r\n};\r\n\r\nexport const modularBundledRequestImplementations: HTTPRequestImplementations = {};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}