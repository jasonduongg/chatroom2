"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.usePresence = void 0;
const react_1 = require("react");
const useAbly_js_1 = require("./useAbly.js");
const useChannelInstance_js_1 = require("./useChannelInstance.js");
const useStateErrors_js_1 = require("./useStateErrors.js");
const INACTIVE_CONNECTION_STATES = ['suspended', 'closing', 'closed', 'failed'];
function usePresence(channelNameOrNameAndOptions, messageOrPresenceObject) {
    const params = typeof channelNameOrNameAndOptions === 'object'
        ? channelNameOrNameAndOptions
        : { channelName: channelNameOrNameAndOptions };
    const skip = params.skip;
    const ably = (0, useAbly_js_1.useAbly)(params.ablyId);
    const { channel } = (0, useChannelInstance_js_1.useChannelInstance)(params.ablyId, params.channelName);
    const { connectionError, channelError } = (0, useStateErrors_js_1.useStateErrors)(params);
    // we can't simply add messageOrPresenceObject to dependency list in our useCallback/useEffect hooks,
    // since it will most likely cause an infinite loop of updates in cases when user calls this hook
    // with an object literal instead of a state or memoized object.
    // to prevent this from happening we store messageOrPresenceObject in a ref, and use that instead.
    // note that it still prevents us from automatically re-entering presence with new messageOrPresenceObject if it changes.
    // one of the options to fix this, is to use deep equals to check if the object has actually changed. see https://github.com/ably/ably-js/issues/1688.
    const messageOrPresenceObjectRef = (0, react_1.useRef)(messageOrPresenceObject);
    (0, react_1.useEffect)(() => {
        messageOrPresenceObjectRef.current = messageOrPresenceObject;
    }, [messageOrPresenceObject]);
    const onMount = (0, react_1.useCallback)(async () => {
        await channel.presence.enter(messageOrPresenceObjectRef.current);
    }, [channel.presence]);
    const onUnmount = (0, react_1.useCallback)(() => {
        // if connection is in one of inactive states, leave call will produce exception
        if (channel.state === 'attached' && !INACTIVE_CONNECTION_STATES.includes(ably.connection.state)) {
            channel.presence.leave();
        }
    }, [channel, ably.connection.state]);
    (0, react_1.useEffect)(() => {
        if (skip)
            return;
        onMount();
        return () => {
            onUnmount();
        };
    }, [skip, onMount, onUnmount]);
    const updateStatus = (0, react_1.useCallback)((messageOrPresenceObject) => {
        channel.presence.update(messageOrPresenceObject);
    }, [channel]);
    return { updateStatus, connectionError, channelError };
}
exports.usePresence = usePresence;
//# sourceMappingURL=usePresence.js.map